<!doctype html>
<html lang="en">
  <head>
    <title>US6895115B2 - Method for implementation of recursive hierarchical segmentation on parallel computers 
        - Google Patents</title>

    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta charset="UTF-8">
    <meta name="referrer" content="origin-when-crossorigin">
    <link rel="canonical" href="https://patents.google.com/patent/US6895115B2/en">
    <meta name="description" content="
     A method, computer readable storage, and apparatus for implementing a recursive hierarchical segmentation algorithm on a parallel computing platform. The method includes setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing, and setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation. The segmentation algorithm is implemented according to the set levels. The method can also include setting a convergence check level of recursion with which the first level of recursion communicates with when performing a convergence check. 
   
   ">
    
    <meta name="DC.type" content="patent">
    
    <meta name="DC.title" content="Method for implementation of recursive hierarchical segmentation on parallel computers 
       ">
    
    <meta name="DC.date" content="2001-04-23" scheme="dateSubmitted">
    
    <meta name="DC.description" content="
     A method, computer readable storage, and apparatus for implementing a recursive hierarchical segmentation algorithm on a parallel computing platform. The method includes setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing, and setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation. The segmentation algorithm is implemented according to the set levels. The method can also include setting a convergence check level of recursion with which the first level of recursion communicates with when performing a convergence check. 
   
   ">
    
    <meta name="citation_patent_application_number" content="US:09/839,147">
    
    <meta name="citation_pdf_url" content="https://patentimages.storage.googleapis.com/42/a1/a3/44a8f0e129fa3e/US6895115.pdf">
    
    <meta name="citation_patent_number" content="US:6895115">
    
    <meta name="DC.date" content="2005-05-17" scheme="issue">
    
    <meta name="DC.contributor" content="James C. Tilton" scheme="inventor">
    
    <meta name="DC.contributor" content="National Aeronautics and Space Administration (NASA)" scheme="assignee">
    
    <meta name="DC.relation" content="US:4791486" scheme="references">
    
    <meta name="DC.relation" content="US:5995668" scheme="references">
    
    <meta name="citation_reference" content="Beaulieu et al, Hierarchy in Picture Segmentation: A Stepwise Optimization Approach, IEEE Transactions on Pattern Analysis and Machine Intelligence, Feb. 1989, vol. 11, No. 2, pp. 150-163.*" scheme="references">
    
    <meta name="citation_reference" content="J.A. Hird, Multiresolution object detection and segmentation using top-down algorithms, Third International Conference on Image Processing and its Applications, Jul. 18-20, 1989, pp. 416-420.*" scheme="references">
    
    <meta name="citation_reference" content="J.C. Tilton, A recursive PVM implementation of an image segmentation algorithm with performance results comparing the HIVE and the Cray T3E, The Seventh Symposium on the Frontiers of Massively Parallel Computation, Feb. 21-25, 1999, pp. 146-153." scheme="references">
    
    <meta name="citation_reference" content="Schachter et al, Some experiments in image segmentation by clustering of local feature values, Pattern Recognition, 1979, vol. 11, No. 1, pp. 19-28.*" scheme="references">
    
    <meta name="citation_reference" content="Tilton et al, Segmentation of remotely sensed data using parallel region growing, Proceedings of the Ninth International Symposium on Machine Processing of Remotely Sensed Data, Jun. 1983, pp. 130-137.*" scheme="references">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:400,400italic,500,500italic,700">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Product+Sans">
    <style>
      body { transition: none; }
    </style>

    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-27188110-4', 'auto');

      version = 'patent-search.search_20191120_RC00';

      function sendFeedback() {
        userfeedback.api.startFeedback({
          'productId': '713680',
          'bucket': 'patent-search-web',
          'productVersion': version,
        });
      }

      window.experiments = {};
      window.experiments.patentCountries = "ae,ag,al,am,ao,ap,ar,at,au,aw,az,ba,bb,bd,be,bf,bg,bh,bj,bn,bo,br,bw,bx,by,bz,ca,cf,cg,ch,ci,cl,cm,cn,co,cr,cs,cu,cy,cz,dd,de,dj,dk,dm,do,dz,ea,ec,ee,eg,em,ep,es,fi,fr,ga,gb,gc,gd,ge,gh,gm,gn,gq,gr,gt,gw,hk,hn,hr,hu,ib,id,ie,il,in,ir,is,it,jo,jp,ke,kg,kh,km,kn,kp,kr,kw,kz,la,lc,li,lk,lr,ls,lt,lu,lv,ly,ma,mc,md,me,mg,mk,ml,mn,mo,mr,mt,mw,mx,my,mz,na,ne,ng,ni,nl,no,nz,oa,om,pa,pe,pg,ph,pl,pt,py,qa,ro,rs,ru,rw,sa,sc,sd,se,sg,si,sk,sl,sm,sn,st,su,sv,sy,sz,td,tg,th,tj,tm,tn,tr,tt,tw,tz,ua,ug,us,uy,uz,vc,ve,vn,wo,yu,za,zm,zw";
      
      
      window.profilePicture = "";

      window.Polymer = {
        dom: 'shady',
        lazyRegister: true,
      };
    </script>

    <script src="//www.gstatic.com/patent-search/frontend/patent-search.search_20191120_RC00/scs/compiled_dir/webcomponentsjs/webcomponents-lite.min.js"></script>
    
    <link rel="import" href="//www.gstatic.com/patent-search/frontend/patent-search.search_20191120_RC00/scs/compiled_dir/search-app-vulcanized.html">
    
  </head>
  <body unresolved>
    
    <script src="//www.gstatic.com/patent-search/frontend/patent-search.search_20191120_RC00/scs/compiled_dir/search-app-vulcanized.js"></script>
    
    <search-app>
      
      

      <article class="result" itemscope itemtype="http://schema.org/ScholarlyArticle">
  <h1 itemprop="pageTitle">US6895115B2 - Method for implementation of recursive hierarchical segmentation on parallel computers 
        - Google Patents</h1>
  <span itemprop="title">Method for implementation of recursive hierarchical segmentation on parallel computers 
       </span>

  <meta itemprop="type" content="patent">
  <a href="https://patentimages.storage.googleapis.com/42/a1/a3/44a8f0e129fa3e/US6895115.pdf" itemprop="pdfLink">Download PDF</a>
  <h2>Info</h2>

  <dl>
    <dt>Publication number</dt>
    <dd itemprop="publicationNumber">US6895115B2</dd>
    <meta itemprop="numberWithoutCodes" content="6895115">
    <meta itemprop="kindCode" content="B2">
    <meta itemprop="publicationDescription" content="Patent ( having previously published pre-grant publication)">
    
    <span>US6895115B2</span>
    
    <span>US09/839,147</span>
    
    <span>US83914701A</span>
    
    <span>US6895115B2</span>
    
    <span>US 6895115 B2</span>
    
    <span>US6895115 B2</span>
    
    <span>US 6895115B2</span>
    
    <span>  </span>
    
    <span> </span>
    
    <span> </span>
    
    <span>US 83914701 A</span>
    
    <span>US83914701 A</span>
    
    <span>US 83914701A</span>
    
    <span>US 6895115 B2</span>
    
    <span>US6895115 B2</span>
    
    <span>US 6895115B2</span>
    

    <dt>Authority</dt>
    <dd itemprop="countryCode">US</dd>
    <dd itemprop="countryName">United States</dd>

    <dt>Prior art keywords</dt>
    
    <dd itemprop="priorArtKeywords" repeat>data</dd>
    <dd itemprop="priorArtKeywords" repeat>level</dd>
    <dd itemprop="priorArtKeywords" repeat>region</dd>
    <dd itemprop="priorArtKeywords" repeat>recursion</dd>
    <dd itemprop="priorArtKeywords" repeat>spatial</dd>

    <dt>Prior art date</dt>
    <dd><time itemprop="priorArtDate" datetime="2001-04-23">2001-04-23</time></dd>

    <dt>Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)</dt>
    <dd itemprop="legalStatusIfi" itemscope>
      <span itemprop="status">Active</span>, expires <time itemprop="expiration" datetime="2023-04-09">2023-04-09</time>
    </dd>
  </dl>

  <dt>Application number</dt>
  <dd itemprop="applicationNumber">US09/839,147</dd>

  

  <dt>Other versions</dt>
  <dd itemprop="directAssociations" itemscope repeat>
    
    <a href="/patent/US20030081833A1/en">
      <span itemprop="publicationNumber">US20030081833A1</span>
      (<span itemprop="primaryLanguage">en</span>
    </a>
  </dd>

  <dt>Inventor</dt>
  <dd itemprop="inventor" repeat>James C. Tilton</dd>
  <dt>Current Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)</dt>
  <dd itemprop="assigneeCurrent" repeat>
    National Aeronautics and Space Administration (NASA)
  </dd>

  <dt>Original Assignee</dt>
  <dd itemprop="assigneeOriginal" repeat>National Aeronautics and Space Administration (NASA)</dd>

  <dt>Priority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)</dt>
  <dd><time itemprop="priorityDate" datetime="2001-04-23">2001-04-23</time></dd>

  <dt>Filing date</dt>
  <dd><time itemprop="filingDate" datetime="2001-04-23">2001-04-23</time></dd>

  <dt>Publication date</dt>
  <dd><time itemprop="publicationDate" datetime="2005-05-17">2005-05-17</time></dd>

  

  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2001-04-23">2001-04-23</time>
    <span itemprop="title">Application filed by National Aeronautics and Space Administration (NASA)</span>
    <span itemprop="type">filed</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    
    <span itemprop="assigneeSearch">National Aeronautics and Space Administration (NASA)</span>
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2001-04-23">2001-04-23</time>
    <span itemprop="title">Priority to US09/839,147</span>
    <span itemprop="type">priority</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    <span itemprop="documentId">patent/US6895115B2/en</span>
    
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2001-04-23">2001-04-23</time>
    <span itemprop="title">Assigned to NATIONAL AERONAUTICS AND SPACE ADMINISTRATION, UNITED STATES GOVERNMENT, AS REPRESENTED BY THE ADMINISTRATOR OF THE</span>
    <span itemprop="type">reassignment</span>
    
    
    
    
    <span itemprop="assigneeSearch">NATIONAL AERONAUTICS AND SPACE ADMINISTRATION, UNITED STATES GOVERNMENT, AS REPRESENTED BY THE ADMINISTRATOR OF THE</span>
    
    
    <span itemprop="description" repeat>ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS).</span>
    
    <span itemprop="description" repeat>Assignors: TILTON, JAMES C.</span>
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2003-05-01">2003-05-01</time>
    <span itemprop="title">Publication of US20030081833A1</span>
    <span itemprop="type">publication</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    <span itemprop="documentId">patent/US20030081833A1/en</span>
    
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2005-05-17">2005-05-17</time>
    <span itemprop="title">Application granted</span>
    <span itemprop="type">granted</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2005-05-17">2005-05-17</time>
    <span itemprop="title">Publication of US6895115B2</span>
    <span itemprop="type">publication</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    <span itemprop="documentId">patent/US6895115B2/en</span>
    
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2019-11-26">2019-11-26</time>
    <span itemprop="title">Application status is Active</span>
    <span itemprop="type">legal-status</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    
    
  </dd>
  
  <dd itemprop="events" itemscope repeat>
    <time itemprop="date" datetime="2023-04-09">2023-04-09</time>
    <span itemprop="title">Adjusted expiration</span>
    <span itemprop="type">legal-status</span>
    
    <span itemprop="critical" content="true" bool>Critical</span>
    
    
    
    
    
  </dd>
  

  <h2>Links</h2>

  <ul>
    
          <li itemprop="links" itemscope repeat>
            <meta itemprop="id" content="usptoLink">
            <a href="http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&p=1&u=/netahtml/PTO/srchnum.html&r=1&f=G&l=50&d=PALL&s1=6895115.PN." itemprop="url" target="_blank"><span itemprop="text">USPTO</span></a>
          </li>
        <li itemprop="links" itemscope repeat>
          <meta itemprop="id" content="usptoAssignmentLink">
          <a href="https://assignment.uspto.gov/patent/index.html#/patent/search/resultFilter?searchInput=6895115" itemprop="url" target="_blank"><span itemprop="text">USPTO Assignment</span></a>
        </li>

    <li itemprop="links" itemscope repeat>
        <meta itemprop="id" content="espacenetLink">
        <a href="http://worldwide.espacenet.com/publicationDetails/biblio?CC=US&amp;NR=6895115B2&amp;KC=B2&amp;FT=D" itemprop="url" target="_blank"><span itemprop="text">Espacenet</span></a>
      </li>
      

    

    
      <li itemprop="links" itemscope repeat>
          <meta itemprop="id" content="globalDossierLink">
          <a href="http://globaldossier.uspto.gov/#/result/patent/US/6895115/1" itemprop="url" target="_blank"><span itemprop="text">Global Dossier</span></a>
        </li>
      

      

      

      

      <li itemprop="links" itemscope repeat>
          <meta itemprop="id" content="stackexchangeLink">
          <a href="https://patents.stackexchange.com/questions/tagged/US6895115" itemprop="url"><span itemprop="text">Discuss</span></a>
        </li>
      
  </ul>

  
  <ul itemprop="concept" itemscope>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000011218</span>
      <span itemprop="name">segmentation</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>abstract</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="sections" repeat>title</span>
      
      <span itemprop="count">117</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000004422</span>
      <span itemprop="name">calculation algorithm</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>abstract</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">77</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000003860</span>
      <span itemprop="name">storage</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>abstract</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">18</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000000034</span>
      <span itemprop="name">methods</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">88</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000002609</span>
      <span itemprop="name">media</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">15</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000002349</span>
      <span itemprop="name">favourable</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>claims</span>
      
      <span itemprop="count">4</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000003595</span>
      <span itemprop="name">spectral</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">78</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000000872</span>
      <span itemprop="name">buffers</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">18</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000003709</span>
      <span itemprop="name">image segmentation</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">16</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000000875</span>
      <span itemprop="name">corresponding</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">15</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000000052</span>
      <span itemprop="name">comparative effects</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">14</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000005192</span>
      <span itemprop="name">partition</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">11</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000015654</span>
      <span itemprop="name">memory</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">10</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000002372</span>
      <span itemprop="name">labelling</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">9</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000009826</span>
      <span itemprop="name">distribution</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">8</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000004048</span>
      <span itemprop="name">modification</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">6</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000006011</span>
      <span itemprop="name">modification</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">6</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000004458</span>
      <span itemprop="name">analytical methods</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">5</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000007667</span>
      <span itemprop="name">floating</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">5</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000000977</span>
      <span itemprop="name">initiatory</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">4</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">229920002432</span>
      <span itemprop="name">poly(vinyl methyl ether) polymers</span>
      <span itemprop="domain">Polymers</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">4</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000000873</span>
      <span itemprop="name">masking</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">3</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000000203</span>
      <span itemprop="name">mixtures</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">3</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000005457</span>
      <span itemprop="name">optimization</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">3</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000007781</span>
      <span itemprop="name">pre-processing</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">3</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000000638</span>
      <span itemprop="name">solvent extraction</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">3</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000004364</span>
      <span itemprop="name">calculation methods</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">2</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000003247</span>
      <span itemprop="name">decreasing</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">2</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000005516</span>
      <span itemprop="name">engineering processes</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">2</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000000284</span>
      <span itemprop="name">extracts</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">2</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">229940102240</span>
      <span itemprop="name">Option 2</span>
      <span itemprop="domain">Drugs</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000003190</span>
      <span itemprop="name">augmentative</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000004891</span>
      <span itemprop="name">communication</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000000605</span>
      <span itemprop="name">extraction</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000000463</span>
      <span itemprop="name">materials</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000001575</span>
      <span itemprop="name">pathological</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000003909</span>
      <span itemprop="name">pattern recognition</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000003405</span>
      <span itemprop="name">preventing</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000000644</span>
      <span itemprop="name">propagated</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000001603</span>
      <span itemprop="name">reducing</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">230000002104</span>
      <span itemprop="name">routine</span>
      <span itemprop="domain">Effects</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">238000000926</span>
      <span itemprop="name">separation method</span>
      <span itemprop="domain">Methods</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
    <li itemprop="match" itemscope repeat>
      <span itemprop="id">239000011257</span>
      <span itemprop="name">shell materials</span>
      <span itemprop="domain">Substances</span>
      <span itemprop="svg_large"></span>
      <span itemprop="svg_small"></span>
      <span itemprop="smiles"></span>
      <span itemprop="inchi_key"></span>
      <span itemprop="similarity">0</span>
      
      <span itemprop="sections" repeat>description</span>
      
      <span itemprop="count">1</span>
    </li>
  
  </ul>
  

  <section>
    <h2>Images</h2>
    <ul>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/e8/67/3d/904906bf0c85d4/US06895115-20050517-D00000.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/46/99/7b/518630fa8762b5/US06895115-20050517-D00000.png">
        <ul>
          <li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="0">
            <meta itemprop="label" content="slave task">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1894">
              <meta itemprop="top" content="498">
              <meta itemprop="right" content="1931">
              <meta itemprop="bottom" content="552">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="10">
            <meta itemprop="label" content="UNICOS version">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1267">
              <meta itemprop="top" content="1290">
              <meta itemprop="right" content="1352">
              <meta itemprop="bottom" content="1355">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="11">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1452">
              <meta itemprop="top" content="1290">
              <meta itemprop="right" content="1526">
              <meta itemprop="bottom" content="1354">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="12">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1620">
              <meta itemprop="top" content="1285">
              <meta itemprop="right" content="1704">
              <meta itemprop="bottom" content="1357">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="13">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1858">
              <meta itemprop="top" content="1284">
              <meta itemprop="right" content="1924">
              <meta itemprop="bottom" content="1350">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="14">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2026">
              <meta itemprop="top" content="1284">
              <meta itemprop="right" content="2098">
              <meta itemprop="bottom" content="1346">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="15">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2202">
              <meta itemprop="top" content="1285">
              <meta itemprop="right" content="2274">
              <meta itemprop="bottom" content="1348">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="16">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2280">
              <meta itemprop="top" content="1278">
              <meta itemprop="right" content="2465">
              <meta itemprop="bottom" content="1355">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="18">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2788">
              <meta itemprop="top" content="1278">
              <meta itemprop="right" content="2869">
              <meta itemprop="bottom" content="1351">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1372">
              <meta itemprop="top" content="932">
              <meta itemprop="right" content="1424">
              <meta itemprop="bottom" content="996">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="20">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="3140">
              <meta itemprop="top" content="1280">
              <meta itemprop="right" content="3230">
              <meta itemprop="bottom" content="1348">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2293">
              <meta itemprop="top" content="927">
              <meta itemprop="right" content="2344">
              <meta itemprop="bottom" content="989">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="3053">
              <meta itemprop="top" content="926">
              <meta itemprop="right" content="3104">
              <meta itemprop="bottom" content="988">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="5">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="360">
              <meta itemprop="top" content="1305">
              <meta itemprop="right" content="403">
              <meta itemprop="bottom" content="1374">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="6">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="540">
              <meta itemprop="top" content="1300">
              <meta itemprop="right" content="574">
              <meta itemprop="bottom" content="1352">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="7">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="700">
              <meta itemprop="top" content="1292">
              <meta itemprop="right" content="768">
              <meta itemprop="bottom" content="1360">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="8">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="892">
              <meta itemprop="top" content="1298">
              <meta itemprop="right" content="924">
              <meta itemprop="bottom" content="1346">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="0">
            <meta itemprop="id" content="9">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1120">
              <meta itemprop="top" content="1296">
              <meta itemprop="right" content="1154">
              <meta itemprop="bottom" content="1348">
            </span>
          </li>
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/35/e0/55/964d2da62304cf/US06895115-20050517-D00001.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/f5/74/2f/056c0450a6d8a5/US06895115-20050517-D00001.png">
        <ul>
          
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/dc/5d/84/7fc0f2ee1a5c83/US06895115-20050517-D00002.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/12/2c/f0/a171d45bb2ed47/US06895115-20050517-D00002.png">
        <ul>
          
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/d2/0e/27/9e529a4639fe84/US06895115-20050517-D00003.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/48/4f/ff/4cb460afc30b9b/US06895115-20050517-D00003.png">
        <ul>
          
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/37/7b/39/66b400552b7845/US06895115-20050517-D00004.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/15/8f/11/3a6551bdfae909/US06895115-20050517-D00004.png">
        <ul>
          <li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1646">
              <meta itemprop="top" content="349">
              <meta itemprop="right" content="1683">
              <meta itemprop="bottom" content="420">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="300">
              <meta itemprop="top" content="1883">
              <meta itemprop="right" content="328">
              <meta itemprop="bottom" content="1936">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1918">
              <meta itemprop="top" content="2282">
              <meta itemprop="right" content="1930">
              <meta itemprop="bottom" content="2306">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="674">
              <meta itemprop="top" content="2454">
              <meta itemprop="right" content="686">
              <meta itemprop="bottom" content="2479">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="12">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1462">
              <meta itemprop="top" content="1813">
              <meta itemprop="right" content="1636">
              <meta itemprop="bottom" content="1883">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2128">
              <meta itemprop="top" content="350">
              <meta itemprop="right" content="2168">
              <meta itemprop="bottom" content="410">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="532">
              <meta itemprop="top" content="1880">
              <meta itemprop="right" content="569">
              <meta itemprop="bottom" content="1936">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1642">
              <meta itemprop="top" content="797">
              <meta itemprop="right" content="1703">
              <meta itemprop="bottom" content="870">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1462">
              <meta itemprop="top" content="1924">
              <meta itemprop="right" content="1534">
              <meta itemprop="bottom" content="1996">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="294">
              <meta itemprop="top" content="2105">
              <meta itemprop="right" content="332">
              <meta itemprop="bottom" content="2160">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="2132">
              <meta itemprop="top" content="802">
              <meta itemprop="right" content="2174">
              <meta itemprop="bottom" content="854">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1546">
              <meta itemprop="top" content="1939">
              <meta itemprop="right" content="1635">
              <meta itemprop="bottom" content="1984">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="4">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="527">
              <meta itemprop="top" content="2100">
              <meta itemprop="right" content="584">
              <meta itemprop="bottom" content="2169">
            </span>
          </li>
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/3e/8a/6d/9c68d5d5d2cf74/US06895115-20050517-D00005.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/fb/42/24/b2e274d8477c8d/US06895115-20050517-D00005.png">
        <ul>
          <li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="5">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="422">
              <meta itemprop="top" content="357">
              <meta itemprop="right" content="485">
              <meta itemprop="bottom" content="432">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="5">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="418">
              <meta itemprop="top" content="708">
              <meta itemprop="right" content="560">
              <meta itemprop="bottom" content="786">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="5">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="420">
              <meta itemprop="top" content="1067">
              <meta itemprop="right" content="561">
              <meta itemprop="bottom" content="1146">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="5">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="427">
              <meta itemprop="top" content="1426">
              <meta itemprop="right" content="488">
              <meta itemprop="bottom" content="1500">
            </span>
          </li>
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/ef/bd/ff/c15f4848bca447/US06895115-20050517-D00006.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/36/f7/f5/a4fb38eea51668/US06895115-20050517-D00006.png">
        <ul>
          <li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="676">
              <meta itemprop="top" content="558">
              <meta itemprop="right" content="732">
              <meta itemprop="bottom" content="626">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="1">
            <meta itemprop="label" content="region j &#43;">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="922">
              <meta itemprop="top" content="898">
              <meta itemprop="right" content="948">
              <meta itemprop="bottom" content="952">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="674">
              <meta itemprop="top" content="907">
              <meta itemprop="right" content="729">
              <meta itemprop="bottom" content="996">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="2">
            <meta itemprop="label" content="σ">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1089">
              <meta itemprop="top" content="892">
              <meta itemprop="right" content="1160">
              <meta itemprop="bottom" content="963">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1305">
              <meta itemprop="top" content="894">
              <meta itemprop="right" content="1337">
              <meta itemprop="bottom" content="955">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="3">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="680">
              <meta itemprop="top" content="1270">
              <meta itemprop="right" content="742">
              <meta itemprop="bottom" content="1344">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1493">
              <meta itemprop="top" content="896">
              <meta itemprop="right" content="1529">
              <meta itemprop="bottom" content="950">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="6">
            <meta itemprop="id" content="4">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="684">
              <meta itemprop="top" content="1622">
              <meta itemprop="right" content="725">
              <meta itemprop="bottom" content="1710">
            </span>
          </li>
        </ul>
      </li>
      <li itemprop="images" itemscope repeat>
        <img itemprop="thumbnail" src="https://patentimages.storage.googleapis.com/82/0d/cd/645a4b40427517/US06895115-20050517-D00007.png">
        <meta itemprop="full" content="https://patentimages.storage.googleapis.com/24/b9/48/7a6041795f201c/US06895115-20050517-D00007.png">
        <ul>
          <li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="0">
            <meta itemprop="label" content="slave task">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="520">
              <meta itemprop="top" content="1831">
              <meta itemprop="right" content="573">
              <meta itemprop="bottom" content="1866">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="20">
            <meta itemprop="label" content="processes">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1284">
              <meta itemprop="top" content="530">
              <meta itemprop="right" content="1388">
              <meta itemprop="bottom" content="610">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="5">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1328">
              <meta itemprop="top" content="3355">
              <meta itemprop="right" content="1393">
              <meta itemprop="bottom" content="3379">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="6">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1318">
              <meta itemprop="top" content="2605">
              <meta itemprop="right" content="1371">
              <meta itemprop="bottom" content="2640">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="6">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1297">
              <meta itemprop="top" content="700">
              <meta itemprop="right" content="1364">
              <meta itemprop="bottom" content="786">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="8">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1322">
              <meta itemprop="top" content="2829">
              <meta itemprop="right" content="1371">
              <meta itemprop="bottom" content="2870">
            </span>
          </li><li itemprop="callouts" itemscope repeat>
            <meta itemprop="figurePage" content="7">
            <meta itemprop="id" content="9">
            <meta itemprop="label" content="recursion level">
            
            <span itemprop="bounds" itemscope>
              <meta itemprop="left" content="1318">
              <meta itemprop="top" content="3181">
              <meta itemprop="right" content="1374">
              <meta itemprop="bottom" content="3218">
            </span>
          </li>
        </ul>
      </li>
      </ul>
  </section>

  <section>
    <h2>Classifications</h2>
    
    <ul>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K</span>&mdash;<span itemprop="Description">RECOGNITION OF DATA; PRESENTATION OF DATA; RECORD CARRIERS; HANDLING RECORD CARRIERS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00</span>&mdash;<span itemprop="Description">Methods or arrangements for reading or recognising printed or written characters or for recognising patterns, e.g. fingerprints</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/20</span>&mdash;<span itemprop="Description">Image acquisition</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/34</span>&mdash;<span itemprop="Description">Segmentation of touching or overlapping patterns in the image field</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/342</span>&mdash;<span itemprop="Description">Cutting or merging image elements, e.g. region growing, watershed, clustering-based techniques</span>
            <meta itemprop="Leaf" content="true">
            
            <meta itemprop="FirstCode" content="true">
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K</span>&mdash;<span itemprop="Description">RECOGNITION OF DATA; PRESENTATION OF DATA; RECORD CARRIERS; HANDLING RECORD CARRIERS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00</span>&mdash;<span itemprop="Description">Methods or arrangements for reading or recognising printed or written characters or for recognising patterns, e.g. fingerprints</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00624</span>&mdash;<span itemprop="Description">Recognising scenes, i.e. recognition of a whole field of perception; recognising scene-specific objects</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/0063</span>&mdash;<span itemprop="Description">Recognising patterns in remote scenes, e.g. aerial images, vegetation versus urban areas</span>
            <meta itemprop="Leaf" content="true">
            
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K</span>&mdash;<span itemprop="Description">RECOGNITION OF DATA; PRESENTATION OF DATA; RECORD CARRIERS; HANDLING RECORD CARRIERS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00</span>&mdash;<span itemprop="Description">Methods or arrangements for reading or recognising printed or written characters or for recognising patterns, e.g. fingerprints</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00973</span>&mdash;<span itemprop="Description">Hardware and software architectures for pattern recognition, e.g. modular organisation</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06K9/00986</span>&mdash;<span itemprop="Description">Hardware and software architectures for pattern recognition, e.g. modular organisation using specific electronic processors</span>
            <meta itemprop="Leaf" content="true">
            
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T</span>&mdash;<span itemprop="Description">IMAGE DATA PROCESSING OR GENERATION, IN GENERAL</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/00</span>&mdash;<span itemprop="Description">Image analysis</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/10</span>&mdash;<span itemprop="Description">Segmentation; Edge detection</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/11</span>&mdash;<span itemprop="Description">Region-based segmentation</span>
            <meta itemprop="Leaf" content="true">
            
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T</span>&mdash;<span itemprop="Description">IMAGE DATA PROCESSING OR GENERATION, IN GENERAL</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/00</span>&mdash;<span itemprop="Description">Image analysis</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/10</span>&mdash;<span itemprop="Description">Segmentation; Edge detection</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/168</span>&mdash;<span itemprop="Description">Segmentation; Edge detection involving transform domain methods</span>
            <meta itemprop="Leaf" content="true">
            
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T</span>&mdash;<span itemprop="Description">IMAGE DATA PROCESSING OR GENERATION, IN GENERAL</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/00</span>&mdash;<span itemprop="Description">Image analysis</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/10</span>&mdash;<span itemprop="Description">Segmentation; Edge detection</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T7/174</span>&mdash;<span itemprop="Description">Segmentation; Edge detection involving the use of two or more images</span>
            <meta itemprop="Leaf" content="true">
            
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T</span>&mdash;<span itemprop="Description">IMAGE DATA PROCESSING OR GENERATION, IN GENERAL</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/00</span>&mdash;<span itemprop="Description">Indexing scheme for image analysis or image enhancement</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/20</span>&mdash;<span itemprop="Description">Special algorithmic details</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/20016</span>&mdash;<span itemprop="Description">Hierarchical, coarse-to-fine, multiscale or multiresolution image processing; Pyramid transform</span>
            <meta itemprop="Leaf" content="true">
            <meta itemprop="Additional" content="true">
            
          </li>
          </ul>
      </li>
      <li>
        <ul itemprop="cpcs" itemscope repeat>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G</span>&mdash;<span itemprop="Description">PHYSICS</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06</span>&mdash;<span itemprop="Description">COMPUTING; CALCULATING; COUNTING</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T</span>&mdash;<span itemprop="Description">IMAGE DATA PROCESSING OR GENERATION, IN GENERAL</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/00</span>&mdash;<span itemprop="Description">Indexing scheme for image analysis or image enhancement</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/20</span>&mdash;<span itemprop="Description">Special algorithmic details</span>
            
            
            
          </li>
          <li itemprop="cpcs" itemscope repeat>
            <span itemprop="Code">G06T2207/20021</span>&mdash;<span itemprop="Description">Dividing image into blocks, subimages or windows</span>
            <meta itemprop="Leaf" content="true">
            <meta itemprop="Additional" content="true">
            
          </li>
          </ul>
      </li>
      </ul>
  </section>

  <section itemprop="abstract" itemscope>
    <h2>Abstract</h2>
    
    <div itemprop="content" html><abstract mxw-id="PA50826005" lang="EN" load-source="patent-office">
    <div num="p-0001" class="abstract">A method, computer readable storage, and apparatus for implementing a recursive hierarchical segmentation algorithm on a parallel computing platform. The method includes setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing, and setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation. The segmentation algorithm is implemented according to the set levels. The method can also include setting a convergence check level of recursion with which the first level of recursion communicates with when performing a convergence check.</div>
  </abstract>
  </div>
  </section>

  <section itemprop="description" itemscope>
    <h2>Description</h2>
    
    <div itemprop="content" html><div mxw-id="PDES15869482" lang="EN" load-source="patent-office" class="description">

  <heading>ORIGIN OF THE INVENTION</heading>
  <p num="p-0002">The invention described herein was made by an employee of the United States Government, and may be manufactured and used by or for the Government for governmental purposes without the payment of any royalties thereon or therefore.</p>


  <heading>BACKGROUND OF THE INVENTION</heading>
  <p num="p-0003">1. Field of the Invention</p>
  <p num="p-0004">The present invention relates to a method, apparatus, and computer readable storage for implementing a recursive hierarchical segmentation algorithm on parallel computers. More particularly, the present invention enables a computer system to utilize parallel processes to perform the hierarchical segmentation algorithm, therein decreasing computation time and enabling the creation of hierarchical segmentations on large data sets that would be impracticable just using serial processing.</p>
  <p num="p-0005">2. Description of the Related Art</p>
  <p num="p-0006">Image segmentation is a partitioning of an image into sections or regions. These regions may be later associated with ground cover type or land use, but the segmentation process simply gives generic labels (i.e. region <b>1</b>, region <b>2</b>, etc. . . . ) to each region. The regions consist of groups of multispectral or hyperspectral image pixels that have similar data feature values. These data feature values may be the multispectral or hyperspectral data values themselves and/or they may be derivative features such as band ratios or textural features.</p>
  <p num="p-0007"> <figref idrefs="DRAWINGS">FIG. 1</figref> illustrates a satellite image of the Baltimore, Md. region. <figref idrefs="DRAWINGS">FIG. 2</figref> illustrates the image of <figref idrefs="DRAWINGS">FIG. 1</figref> after undergoing segmentation into two region sets. As can be seen by <figref idrefs="DRAWINGS">FIG. 2</figref>, like regions have been joined. The darker colored region corresponds to bodies of water, while the lighter colored region represents the land. <figref idrefs="DRAWINGS">FIG. 3</figref> illustrates the image of <figref idrefs="DRAWINGS">FIG. 1</figref> after undergoing segmentation into three region sets. As can be seen by <figref idrefs="DRAWINGS">FIG. 3</figref>, the image is colored into three image sets, each image set containing a like region. The dark colored region corresponds to land, the medium colored region corresponds to water, and the light colored regions correspond to the industrial or dense urban regions.</p>
  <p num="p-0008">As can be seen by the <figref idrefs="DRAWINGS">FIGS. 1-3</figref>, the hierarchical image segmentations can be useful in a multitude of applications, including earth science applications where delineation of the spatial coverage of water or land is required. It can also be used as substitute ground reference data for the validation of the analysis of lower resolution global coverage remotely sensed data.</p>
  <p num="p-0009">There are numerous algorithms for achieving image segmentation, including recursive algorithms. However, most of these algorithms do not employ any form of optimization in performing segmentations. The following is the classic definition of image segmentation:
</p> <ul> <li id="ul0001-0001" num="0000"> <ul> <li id="ul0002-0001" num="0009">Let X be a two-dimensional array representing an image. A segmentation of X can be defined as a partition of X into disjoint subsets X<sub>1</sub>, X<sub>2</sub>, . . . , X<sub>N</sub>, such that 
<maths id="MATH-US-00001" num="00001"> <math overflow="scroll"> <mrow> <mrow> <mrow> <mn>1</mn> <mo>)</mo> </mrow> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mover> <munder> <mo>⋃</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> </munder> <mi>N</mi> </mover> <mo>⁢</mo> <msub> <mi>X</mi> <mi>i</mi> </msub> </mrow> <mo>=</mo> <mi>X</mi> </mrow> </math> </maths>
</li> <li id="ul0002-0002" num="0010">2) X<sub>i</sub>, i=1, 2, . . . , N is connected.</li> <li id="ul0002-0003" num="0011">3) P(X<sub>i</sub>)=TRUE for i=1, 2, . . . , N and</li> <li id="ul0002-0004" num="0012">4) P(X<sub>i</sub>∪X<sub>j</sub>)=FALSE for i≠j, where X<sub>i </sub>and X<sub>j </sub>are adjacent.</li> <li id="ul0002-0005" num="0013">P(X<sub>i</sub>) is a logical predicate that assigns the value TRUE or FALSE to X<sub>i</sub>, depending on the image data values in X<sub>i</sub>.
<br/>
S. W. Zucker, “Region growing: childhood and adolescence,” <i>Computer Graphics and Image Processing</i>, Vol. 5, pp. 382-399, 1976, summarized the above definition as follows: The first condition requires that every picture element (pixel) must be in a region. The second condition requires that each region must be connected, i.e. composed of contiguous image pixels. The third condition determines what kind of properties each region must satisfy, i.e. what properties the image pixels must satisfy to be considered similar enough to be in the same region. The fourth condition specifies that, in the final segmentation result, any merging of any adjacent regions would violate the third condition.
</li> </ul> </li> </ul>

  <p num="p-0010">A problem with this classic definition of image segmentation is that the segmentation so defined is not unique. The number, N and shape of the partitions, X<sub>i</sub>, X<sub>2</sub>, . . . , X<sub>N</sub>, depend on the order in which the image pixels are processed. In addition, there is no concept of optimality contained in this definition of image segmentation. Under this classic definition, all partitions that satisfy the conditions represent equally good or valid segmentations of the image.</p>
  <p num="p-0011">An ideal definition of image segmentation would be as follows:
</p> <ul> <li id="ul0003-0001" num="0000"> <ul> <li id="ul0004-0001" num="0016">Let X be a two-dimensional array representing an image. A segmentation of X into N regions can be defined as a partition of X into disjoint subsets X<sub>1</sub>, X<sub>2</sub>, . . . , X<sub>N</sub>, such that 
<maths id="MATH-US-00002" num="00002"> <math overflow="scroll"> <mrow> <mrow> <mrow> <mn>1</mn> <mo>)</mo> </mrow> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mover> <munder> <mo>⋃</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> </munder> <mi>N</mi> </mover> <mo>⁢</mo> <msub> <mi>X</mi> <mi>i</mi> </msub> </mrow> <mo>=</mo> <mi>X</mi> </mrow> </math> </maths>
</li> <li id="ul0004-0002" num="0017">2) X<sub>i</sub>, i=1, 2, . . . , N is connected. 
<maths id="MATH-US-00003" num="00003"> <math overflow="scroll"> <mrow> <mrow> <mrow> <mn>3</mn> <mo>)</mo> </mrow> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <mrow> <mi>G</mi> <mo>⁢</mo> <mrow> <mo>(</mo> <msub> <mi>X</mi> <mi>i</mi> </msub> <mo>)</mo> </mrow> </mrow> </mrow> </mrow> <mo>=</mo> <mi>MINIMUM</mi> </mrow> </math> </maths>
</li> <li id="ul0004-0003" num="0018"> over all partitions into N regions and</li> <li id="ul0004-0004" num="0019">4) G(X<sub>i</sub>∪X<sub>j</sub>)&gt;G(X<sub>i</sub>)+G(X<sub>j</sub>) for i≠j, where X<sub>i </sub>and X<sub>j </sub>are adjacent.</li> <li id="ul0004-0005" num="0020">G(X<sub>i</sub>) is a function that assigns a cost to partition X<sub>i</sub>, depending on the image data values in X<sub>i</sub>.</li> </ul> </li> </ul>

  <p num="p-0012">These conditions can be summarized as follows: The first condition requires that every picture element (pixel) must be in one of N regions. The second condition requires that each region must be connected, i.e. composed of contiguous image pixels. The third condition states that the partition must produce a minimum cost aggregated over all N regions. The fourth condition specifies that, in the final segmentation result, any merging of adjacent regions increases the minimum cost obtained in the third condition.</p>
  <p num="p-0013">As a result of these conditions, the order dependence problem is eliminated because the global minimum solution is found and this solution is the optimal solution. In practice, this ideal image segmentation is difficult, if not impossible, to find. The third condition implies that all possible image partitions consisting of N regions must be searched to find the minimum cost. Further, the question of the proper value for N is left undetermined.</p>
  <p num="p-0014">B. J. Schachter, L. S. Davis and A. Rosenfeld, “Some experiments in image segmentation by clustering of local feature vectors,” <i>Pattern Recognition</i>, Vol. 11, No. 1, pp. 19-28, 1979, suggest that an iterative parallel region growing process be used to eliminate the order dependence problem. R. L. Kettig and D. A. Landgrebe, “Computer classification of remotely sensed multispectral image data by extraction and classification of homogeneous objects,” <i>LARS Information Note </i>050975, Laboratory for Applications of Remote Sensing, Purdue University, West Lafayette, Ind., 1975, suggest an alternative partitioning logic in which the most similar neighboring region is merged first, but found this approach too difficult to implement in a sequential manner with the computing resources they had at that time. J. C. Tilton and S. C. Cox, “Segmentation of remotely sensed data using parallel region growing,” <i>Digest of the </i>1983 <i>International Geoscience and Remote Sensing Symposium</i>, San Francisco, Calif., pp. 9.1-9.6, Aug. 31-Sep. 2, 1983, propose implementing an iterative parallel approach to region growing on parallel processors in order to overcome the computational demands of this approach. In their approach, the most similar pair(s) of spatially adjacent regions is (are) merged at each iteration. This approach solved the order dependence problem (assuming a deterministic tie-breaking method is employed), but did not fully address the optimal segmentation problem. Merging the most similar pair(s) of spatially adjacent regions at each iteration does not guarantee that the segmentation result at a particular iteration is the optimal partition of the image data for the number of partitions obtained at that iteration. J.-M. Beaulieu and M. Goldberg, “Hierarchy in picture segmentation: A stepwise optimization approach,” <i>IEEE Trans. on Pattern Analysis and Machine Intelligence</i>, Vol. 11, No. 2, pp. 150-163, February 1989, provide a theoretical basis for Tilton and Cox&#39;s iterative parallel region growing approach in their theoretical analysis of their similar Hierarchical Stepwise Optimization algorithm (HSWO). They show that the HSWO algorithm produces the globally optimal segmentation result if each iteration is statistically independent. Even though each iteration will generally not be statistically independent for natural images, the HSWO approach is shown to still produce excellent results. Beaulieu and Goldberg also point out that the sequence of partitions generated by this iterative approach reflect the hierarchical structure of the imagery data: the partitions obtained in the early iterations preserve the small details and objects in the image, while the partitions obtained in the latter iterations preserve only the most important components of the image. They further note that these hierarchical partitions may carry information that may help in identifying the objects in the imagery data.</p>
  <p num="p-0015">The definition of image segmentation as followed by the HSWO algorithm is defined recursively as follows:
</p> <ul> <li id="ul0005-0001" num="0000"> <ul> <li id="ul0006-0001" num="0025">Let X be a two-dimensional array representing an image and let X<sub>i</sub>, X<sub>2</sub>, . . . , X<sub>N−1, X</sub> <sub>N </sub>be a partition of X into N regions such that 
<maths id="MATH-US-00004" num="00004"> <math overflow="scroll"> <mrow> <mrow> <mrow> <mn>1</mn> <mo>)</mo> </mrow> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mover> <munder> <mo>⋃</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> </munder> <mi>N</mi> </mover> <mo>⁢</mo> <msub> <mi>X</mi> <mi>i</mi> </msub> </mrow> <mo>=</mo> <mrow> <mi>X</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>and</mi> </mrow> </mrow> </math> </maths>
</li> <li id="ul0006-0002" num="0026">2) X<sub>i</sub>, i=1, 2, . . . , N is connected.</li> <li id="ul0006-0003" num="0027">Let G(X<sub>i</sub>) be a function that assigns a cost to partition X<sub>i</sub>, depending on the image data values in X<sub>i</sub>. Reorder the partition X<sub>i</sub>, X<sub>2</sub>, . . . , X<sub>N−1</sub>, X<sub>N </sub>such that G(X<sub>N−1</sub>∪X<sub>N</sub>)≦G(X<sub>i</sub>∪X<sub>j</sub>) for all i≠j where X<sub>N−1 </sub>and X<sub>N </sub>are adjacent and X<sub>i </sub>and X<sub>j</sub>, are adjacent. The segmentation of X into N−1 regions is defined as the partition X′<sub>1</sub>, X′<sub>2</sub>. . . , X′<sub>N−1 </sub>where X′<sub>i</sub>=X<sub>i </sub>for i=1, 2, . . . , N−2 and X′<sub>N−1</sub>=X<sub>N−1</sub>∪X<sub>N</sub>.
<br/>
The initial partition may assign each image pixel to a separate region, in which case the initial value of N is the number of pixels in the image (N<sub>p</sub>). Any other initial partition may be used, such as a partitioning of the image into n×n blocks, where n<sup>2</sup>&lt;&lt;N<sub>p</sub>, or any pre-segmentation with another algorithm.
</li> </ul> </li> </ul>

  <p num="p-0016">The region growing approach utilized by the hierarchical image segmentation algorithm, HSEG, is the same as that employed by Beaulieu and Goldberg&#39;s HSWO algorithm except that HSEG may optionally alternate spectral clustering iterations with region growing iterations to merge non-adjacent regions. Such spectral clustering adds robustness to the segmentation result and eliminates the bookkeeping overhead of separately accounting for essentially identical non-adjacent regions.</p>
  <p num="p-0017">A problem with implementing segmentation algorithms based on HSWO region growing is that these algorithms are processor intensive. A large high-resolution high-bit image can take a very long time to undergo segmentation using the prior art HSWO region growing algorithms and related technology.</p>
  <p num="p-0018">An additional problem common to all recursive segmentation algorithms is the requirement of large amounts of memory, making it likely that large images may require more memory than available, preventing large images from being segmented.</p>
  <heading>SUMMARY OF THE INVENTION</heading>
  <p num="p-0019">Accordingly, it is an object of the present invention to implement a recursive hierarchical segmentation algorithm on a parallel-computing platform, decreasing computation time.</p>
  <p num="p-0020">The foregoing object of the present invention is achieved by a method of implementing a recursive hierarchical segmentation algorithm on a parallel computing platform, including (a) setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing; (b) setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation; and (c) implementing the segmentation algorithm according to the set levels.</p>


  <description-of-drawings>
    <heading>BRIEF DESCRIPTIONS OF THE DRAWINGS</heading>
    <p num="p-0021">These and other advantages of the invention will become apparent and more readily appreciated from the following description of the preferred embodiments, taken in conjunction with the accompanying drawings of which:</p>
    <p num="p-0022"> <figref idrefs="DRAWINGS">FIG. 1</figref> is an example of a satellite image before segmentation;</p>
    <p num="p-0023"> <figref idrefs="DRAWINGS">FIG. 2</figref> is an example of the satellite image in <figref idrefs="DRAWINGS">FIG. 1</figref> after segmentation into two region sets;</p>
    <p num="p-0024"> <figref idrefs="DRAWINGS">FIG. 3</figref> is an example of the satellite image in <figref idrefs="DRAWINGS">FIG. 1</figref> after segmentation into three region sets;</p>
    <p num="p-0025"> <figref idrefs="DRAWINGS">FIGS. 4A</figref>, <b>4</b>B, <b>4</b>C, and <b>4</b>D are diagrams illustrating one example of how an image can be divided into quarters and sub-quarters recursively;</p>
    <p num="p-0026"> <figref idrefs="DRAWINGS">FIG. 5</figref> is a diagram illustrating an example of serial implementation;</p>
    <p num="p-0027"> <figref idrefs="DRAWINGS">FIG. 6</figref> is a diagram illustrating in more detail the significance of the inb_levels parameter;</p>
    <p num="p-0028"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a diagram illustrating an example of processing a 512 by 512 image with fnb_levels=2, inb_levels=3, and rnb_levels=5.</p>
  </description-of-drawings>


  <heading>DESCRIPTION OF THE PREFERRED EMBODIMENTS</heading>
  <p num="p-0029">Reference will now be made in detail to the present preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings, wherein like reference numerals refer to like elements throughout.</p>
  <p num="p-0030">The Basic Hierarchical Segmentation (HSEG) algorithm is as follows:
</p> <ul> <li id="ul0007-0001" num="0043">1. Give each image pixel a region label and set the global criterion value, critval, equal to zero. If a pre-segmentation is provided, label each image pixel according to the pre-segmentation. Otherwise, label each image pixel as a separate region.</li> <li id="ul0007-0002" num="0044">2. Calculate the dissimilarity criterion value between each spatially adjacent region.</li> <li id="ul0007-0003" num="0045">3. Find the smallest dissimilarity criterion value, and merge all pairs of spatially adjacent regions with this criterion value.</li> <li id="ul0007-0004" num="0046">4. Calculate the dissimilarity criterion value between all pairs of non-spatially adjacent regions.</li> <li id="ul0007-0005" num="0047">5. Merge all pairs of non-spatially adjacent regions with dissimilarity criterion value less than or equal to the criterion value found in operation <b>3</b>.</li> <li id="ul0007-0006" num="0048">6. If the number of regions remaining is less than the preset value chkregions, go to operation <b>7</b>. Otherwise, go to operation <b>2</b>.</li> <li id="ul0007-0007" num="0049">7. Let prevcritval=critval. Calculate the current global criterion value and set critval equal to this value. If prevcritval=zero, go to operation <b>2</b>. Otherwise calculate cvratio=critval/prevcritval. If cvratio is greater than the preset threshold convfact, save the region label map from the previous iteration as a “raw” segmentation result. Also, store the region number of pixels list, region mean vector list and region criterion value list for this previous iteration. (Note: The region criterion value is the portion of the global criterion value contributed by the image pixels covered by the region.) If the number of regions remaining is two or less, save the region label map from the current iteration as the coarsest instance of the final hierarchical segmentation result, and stop. Otherwise, go to operation <b>2</b>.</li> </ul>

  <p num="p-0031">Dissimilarity Criterion: The dissimilarity criterion can be any measure of distance between two vectors. The widely used vector norms, 1-norm, 2-norm and Infinity-norm (see G. W. Stewart, <i>Introduction to Matrix Computations</i>, p. 164, Academic Press: New York, N.Y., 1973), are implemented as options.</p>
  <p num="p-0032">Global Criterion: The global criterion is used to identify significant changes in the segmentation results from one iteration to the next. This criterion is same as the dissimilarity criterion, except that it compares the original image data with the region mean image from the current segmentation. The value of the global criterion is calculated by computing the dissimilarity function at each image point between the original image values and the region mean image and averaging the result over the entire image.</p>
  <p num="p-0033">The above algorithm can be implemented recursively using the Recursive Hierarchical Segmentation Algorithm (RHSEG) as follows:
</p> <ul> <li id="ul0008-0001" num="0053">1. Specify the number of levels of recursion required (rnb_levels), and pad the input image, if necessary, so that the width and height of the image can be evenly divided by 2<sup>rnb</sup> <sup> <sub2>—</sub2> </sup> <sup>levels−1</sup>. (A good value for rnb_levels results in an image section at level=rnb_levels consisting of roughly 500 to 2000 pixels.) Set level=1.</li> <li id="ul0008-0002" num="0054">2. Call recur_hseg(level,image).
<br/>
Outline of recur_hseg(level,image):
</li> <li id="ul0008-0003" num="0055">A. If level&lt;rnb_levels, divide the image data into quarters (in half in the width and height dimensions) and call recur_hseg(level+1,image/4) for each image quarter (represented as image/4). Otherwise, go to operation C.</li> <li id="ul0008-0004" num="0056">B. After all four calls to recur_hseg( ) from operation A complete processing, reassemble the image segmentation results.</li> <li id="ul0008-0005" num="0057">C. Execute the HSEG algorithm as described in the HSEG Basic Algorithm Description above (except that the reassembled segmentation results are used as the pre-segmentation when level&lt;rnb_levels), but with the following modification: If level&gt;1, terminate the algorithm when the number of regions reaches the preset value minregions, and do not check for critval or output any “raw” segmentation results.</li> </ul>

  <p num="p-0034"> <figref idrefs="DRAWINGS">FIGS. 4A</figref>, <b>4</b>B, <b>4</b>C and <b>4</b>D illustrate one example of how an image can be divided into quarters and sub-quarters recursively. <figref idrefs="DRAWINGS">FIG. 4A</figref> illustrates a starting image. <figref idrefs="DRAWINGS">FIG. 4B</figref> illustrates how an image is first divided into quarters labeled <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b>. <figref idrefs="DRAWINGS">FIG. 4C</figref> illustrates the subsequent level of recursion, where quarter <b>1</b> of <figref idrefs="DRAWINGS">FIG. 4B</figref> is divided up into sub-quarters labeled <b>5</b>, <b>6</b>, <b>7</b>, and <b>8</b>. <figref idrefs="DRAWINGS">FIG. 4D</figref> illustrates the subsequent level of recursion, where sub-quarter <b>5</b> of <figref idrefs="DRAWINGS">FIG. 4C</figref> is further divided up into additional sub-quarters labeled <b>9</b>, <b>10</b>, <b>11</b>, <b>12</b>. Note that while we use quarters to divide the image, the image could be divided using other shapes and other dividing methods as well.</p>
  <p num="p-0035">In order to implement the segmentation algorithm recursively, the parameter rnb_levels should be specified, which indicates the number of levels of recursion to be processed. If rnb_levels is set to equal 4, then the above algorithm will divide the image as illustrated in <figref idrefs="DRAWINGS">FIG. 4A</figref> (level <b>1</b>), <figref idrefs="DRAWINGS">FIG. 4B</figref> (level <b>2</b>), <figref idrefs="DRAWINGS">FIG. 4C</figref> (level <b>3</b>) and <figref idrefs="DRAWINGS">FIG. 4D</figref> (level <b>4</b>). When the current level becomes 4, because 4 is not &lt;rnb_levels (which is equal to 4), the recursive dividing will stop and then the lower recursion levels will subsequently return values to the higher levels, or the recursion will “come back up.”</p>
  <p num="p-0036">The algorithms described above can be implemented serially, using only one processor. <figref idrefs="DRAWINGS">FIG. 5</figref> illustrates the serial implementation of the above example. Referring now to <figref idrefs="DRAWINGS">FIG. 5</figref>, item <b>1</b> represents the first level of recursion, which then goes to item <b>2</b> which represents the second level of recursion, which then goes to item <b>3</b> which represents the third level of recursion, which then goes to item <b>4</b> which represents the last level of recursion. The recursion “stops” at item <b>4</b>, because rnb_levels is set to equal 4 in our example.</p>
  <p num="p-0037">As stated previously, the serial implementation of the above algorithm requires a large amount of computing time and resources. The implementation of the RHSEG algorithm on a parallel-processing platform is superior to the serial method with regard to computation time and computing resources.</p>
  <p num="p-0038">In the implementation of the RHSEG algorithm on a parallel computer, besides setting the above described rnb_levels (recursion levels), two other levels are specified, inb_levels (intermediate levels) and fnb_levels (final levels). It is required that fnb_levels&lt;=inb_levels&lt;=rnb_levels. Quarters and subsequent sub-quarters are initially processed in parallel, but when the level of recursion reaches inb_levels the sub-quarters are then processed serially instead of in parallel.</p>
  <p num="p-0039"> <figref idrefs="DRAWINGS">FIG. 6</figref> illustrates in more detail the significance of the inb_levels parameter and the parallel processes. In <figref idrefs="DRAWINGS">FIG. 6</figref>, recursion levels <b>1</b>, <b>2</b>, <b>3</b>, <b>4</b> are illustrated. The inb_levels parameter is set to 2, and the rnb_levels parameter is set to 4. As stated above, the rnb_levels parameter is where the recursion stops dividing the image, and returns to the higher levels using information calculated from the lower levels.</p>
  <p num="p-0040">Recursion level <b>1</b> can be associated with FIG. <b>4</b>A. Since recursion level <b>1</b> is less than 2 (inb_levels), the next level of recursion is performed in parallel. Thus, at recursion level <b>2</b> (inb_levels), four new processes are spawned which are performed in parallel. Recursion level <b>2</b> can be associated with FIG. <b>4</b>B. At recursion levels <b>3</b> and <b>4</b>, since these are higher than 2 (inb_levels), these levels of recursion are performed serially. Thus, at these levels, no new parallel processes are spawned. Instead, the previous process is used sequentially. Recursion level <b>3</b> can be associated with <figref idrefs="DRAWINGS">FIG. 4C</figref>, and recursion level <b>4</b> can be associated with FIG. <b>4</b>D.</p>
  <p num="p-0041">Thus, as illustrated in <figref idrefs="DRAWINGS">FIG. 6</figref>, there are four processes operating in parallel (five if you include the first process). Thus, the quarters labeled <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> in <figref idrefs="DRAWINGS">FIG. 4B</figref> are all initially processed in parallel. The sub-quarters labeled <b>5</b>, <b>6</b>, <b>7</b>, <b>8</b> in <figref idrefs="DRAWINGS">FIG. 4C</figref>, and the sub-quarters labeled <b>9</b>, <b>10</b>, <b>11</b>, <b>12</b> in <figref idrefs="DRAWINGS">FIG. 4D</figref> are all processed serially, using the process spawned to process section <b>1</b> of FIG. <b>4</b>B. Note of course there are additional sub-quarters (and their processes), which have not been labeled in FIG. <b>4</b>C and <figref idrefs="DRAWINGS">FIG. 4D</figref>, for simplicity.</p>
  <p num="p-0042">As can be seen by <figref idrefs="DRAWINGS">FIG. 6</figref>, the parallel implementation of the RHSEG algorithm can save time by first spawning parallel processes until the inb_levels of recursion is reached, and then using those parallel processes to process the further levels of recursions serially until rnb_levels is reached. The inb_levels should be set after taking into consideration how many processes the current computing platform can simultaneously handle.</p>
  <p num="p-0043">The third parameter to be specified in the parallel implementation of the RHSEG algorithm is fnb_levels. The fnb_levels parameter relates to the convergence checking (item #<b>7</b> in the above Basic Hierarchical Segmentation (HSEG) algorithm). At the fnb_levels of recursion the passing of data to higher levels is different than before (more on this in the example given below). In addition, when the current level of recursion reaches the first level, the processes at fnb_levels calculate and send their contribution to the value of critval to level <b>1</b>. The process running at level <b>1</b> computes the value of critval as the average dissimilarity value over the entire image and calculates cvratio=critval/prevcritval. If cvratio is greater than a preset threshold, then the slave tasks running at fnb_levels to send their region label map data to the master program. More on the convergence checking and fnb_levels will be presented later on.</p>
  <p num="p-0044"> <figref idrefs="DRAWINGS">FIG. 7</figref> illustrates an example of processing a 512 by 512 image with fnb_levels=2, inb_levels=3, and rnb_levels=5.</p>
  <p num="p-0045">As can be seen by <figref idrefs="DRAWINGS">FIG. 7</figref>, there are five (rnb_levels) recursion levels, L<b>1</b>, L<b>2</b>, L<b>3</b>, L<b>3</b>, and L<b>5</b>. In this example there are also 21 processes. Process <b>0</b> at recursion level L<b>1</b> spawns processes <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> at recursion level L<b>2</b>. Process <b>1</b> spawns processes <b>5</b>, <b>6</b>, <b>7</b>, and <b>8</b>, while process <b>2</b> spawns processes <b>9</b>, <b>10</b>, <b>11</b>, and <b>12</b>, while process <b>3</b> spawns processes <b>13</b>, <b>14</b>, <b>15</b> and <b>16</b>, while process <b>4</b> spawns processes <b>16</b>, <b>18</b>, <b>29</b> and <b>20</b>. At L<b>3</b> (inb_levels), each spawned process proceeds to process the lower levels of recursion serially. Therefore, when a new process is spawned to process another divided section of the image, this can be considered a parallel implementation. When a same process processes another divided section of the image, this can be considered a serial implementation.</p>
  <p num="p-0046">Also illustrated in <figref idrefs="DRAWINGS">FIG. 7</figref>, the image size of recursion level L<b>1</b> is 512×512, while the image size of recursion level L<b>2</b> is 256×256, while the image size of recursion level L<b>3</b> is 128×128, while the image size of recursion level L<b>4</b> is 64×64, while the image size of recursion level L<b>5</b> is 32×32.</p>
  <p num="p-0047">Regarding convergence checking, since fnb_levels is equal to two, processes <b>1</b>, <b>2</b>, <b>3</b>, and <b>4</b> will calculate the sum of the dissimilarity criterion over each region contained in the processing window, and send these values back to process <b>0</b> operating at recursion level L<b>1</b>. Process <b>0</b> computes critval as the average value of the values of dissimilarity function over the entire image from the dissimilarity function values obtained from processes <b>1</b>, <b>2</b>, <b>3</b> and <b>4</b> and calculates cvratio. If cvratio is greater than a preset threshold, the region map from the previous iteration is saved as a raw segmentation result.</p>
  <p num="p-0048">The designation of fnb_levels&lt;inb_levels reduces the amount of interprocessor communications required for the convergence criterion calculations. This is important for less expensive parallel processing systems such as the Beowulf systems constructed using relatively slow (but inexpensive) Ethernet connections to network off-the-shelf PCs together. In addition, the designation of fnb_levels&gt;1 reduces the RAM requirements for the parallel processing system. While the optimal setting for inb_levels varies depending upon the computing platform being used, on a <b>201</b> processor HIVE system (one master process plus 200 slave nodes), the optimum value of inb_levels is 5.</p>
  <p num="p-0049">We will now walk through an example of processing a large Landsat Thematic Mapper (TM) data set to illustrate how the system works. This TM data set has 7680 columns, 6912 rows and 6 spectral bands. Based on our prior experience with these parameters for the Hive Parallel System, we preset the values for the three levels of recursion as rnb_levels=9, inb_levels=5 and fnb_levels=3. When the master program on the parallel computing system calls the first slave task (the 0<sup>th </sup>task), it sends to that task several task specific parameters. Included among these parameters are:</p>
  <p num="p-0050"> <tables id="TABLE-US-00001" num="00001"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>first_sec</entry> <entry>first data section to be processed by the slave task</entry> </row> <row> <entry>last_sec</entry> <entry>last data section to be processed by the slave task</entry> </row> <row> <entry>calling_tid</entry> <entry>current task ID</entry> </row> <row> <entry>level</entry> <entry>current level of recursion + 1</entry> </row> <row> <entry>ncols</entry> <entry>number of columns in current section of data</entry> </row> <row> <entry>nrows</entry> <entry>number of rows in current section of data</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">        </tbody>  </table> </tables> <br/>
The first data section processed, first_sec, is the 0<sup>th </sup>section. The last data section processed is determined by the value of inb_levels through the formula:
<br/>last_sec=4<sup>(inb</sup> <sup> <sub2>—</sub2> </sup> <sup>—</sup>levels−1)−1.<br/>
Since in this case, since inb_levels=5, last_sec=255 (i.e., the data is processed in 256 sections at the recursive level inb_levels). The calling_tid is the task ID of the master program (the first slave task uses this to determine where to send its results back to). The recursion level, level, is equal to 1 for the 0<sup>th </sup>task (the master program is considered to at recursion level <b>0</b>). For our TM data set, ncols=7680 and nrows=6912.
</p>
  <p num="p-0051">Since the slave program for the 0<sup>th </sup>task is operating at a level of recursion less than inb_levels (its recursion level is “1” which is less than inb_levels=5), it sends a request to the master program for four branch slave task IDs. Upon receiving these four branch slave task IDs, the 0<sup>th </sup>task slave program initiates the 1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd </sup>and 4<sup>th </sup>tasks, respectively, on these four branch slave task IDs, with the task specific parameters again including first_sec, last_sec, calling_tid, level, ncols and nrows. The values of first_sec and last_sec are determined so as to process the 1<sup>st </sup>quarter of the data sections on the 1<sup>st </sup>task, the 2<sup>nd </sup>quarter of the data sections on the 2<sup>nd </sup>task, the 3<sup>rd </sup>quarter of the data sections on the 3<sup>rd </sup>task and the 4<sup>th </sup>quarter of the data sections on the 4<sup>th </sup>task. The calling_tid is the task ID of the recursion level=1 slave task (the called slave tasks use this to determine where to send their results back to). The recursion level, level, is equal to 2 for the 1<sup>st</sup>, 2<sup>nd</sup>, 3<sup>rd </sup>and 4<sup>th </sup>tasks. For our TM data set, ncols=3840 and nrows=3456 for the tasks at recursion level <b>2</b>.</p>
  <p num="p-0052">Since the slave programs operating at recursion level <b>2</b> are operating at a level of recursion less than inb_levels (=5), each of these tasks send a request to the master program for four branch slave task IDs. Upon receiving these four branch slave task IDs, each of the slave programs at recursion level <b>2</b> initiate 4 tasks, resulting in the initiation of 16 tasks (tasks <b>5</b> through <b>20</b>). Each slave task at recursion level <b>2</b> calls 4 slave tasks at recursion level <b>3</b> with task specific parameters again including first_sec, last_sec, calling_tid, level, ncols and nrows. The values of first_sec and last_sec are determined so as to process the one-quarter of the data sections on each of the 4 tasks called. The calling_tid is the task ID of the recursion level=2 slave task (the called slave tasks use this to determine where to send their results back to). The recursion level parameter, level, for the branch tasks is equal to 3. For our TM data set, ncols=1920 and nrows=1728 for the tasks at recursion level <b>3</b>.</p>
  <p num="p-0053">Again, since the slave programs operating at recursion level <b>3</b> are operating at a level of recursion less than inb_levels (=5), each of these tasks send a request to the master program for four branch slave task IDs. Upon receiving these four branch slave task IDs, each of the slave programs at recursion level <b>3</b> initiate 4 tasks, resulting in the initiation of 64 tasks (tasks <b>21</b> through <b>84</b>). Each slave task at recursion level <b>3</b> calls 4 slave tasks at recursion level <b>4</b> with task specific parameters again including first_sec, last_sec, calling_tid, level, ncols and nrows. The values of first sec and last_sec are determined so as to process the one-quarter of the data sections on each of the 4 tasks called. The calling_tid is the task ID of the recursion level=3 slave task (the called slave tasks use this to determine where to send their results back to). The recursion level parameter, level, for the branch tasks is equal to 4. For our TM data set, ncols=960 and nrows=864 for the tasks at recursion level <b>4</b>.</p>
  <p num="p-0054">Yet again, since the slave programs operating at recursion level <b>4</b> are operating at a level of recursion less than inb_levels (=5), each of these tasks send a request to the master program for four branch slave task IDs. Upon receiving these four branch slave task IDs, each of the slave programs at recursion level <b>4</b> initiate 4 tasks, resulting in the initiation of 256 tasks (tasks <b>85</b> through <b>340</b>). Each slave task at recursion level <b>4</b> calls 4 slave tasks at recursion level <b>5</b> with task specific parameters again including first_sec , last_sec, calling_tid, level, ncols and nrows. The values of first_sec and last_sec are determined so as to process the one-quarter of the data sections on each of the 4 tasks called. The calling_tid is the task ID of the recursion level=4 slave task (the called slave tasks use this to determine where to send their results back to). The recursion level parameter, level, for the branch tasks is equal to 5. For our TM data set, ncols=480 and nrows=432 for the tasks at recursion level <b>5</b>.</p>
  <p num="p-0055">For this example, the slave programs operating at recursion level <b>5</b> are operating at the intermediate recursion level, inb_levels (=5), each send a request to the master program for the input data for its section (section=first_sec=last_sec). Each of these programs then call the subroutine, lrhseg, which is a sequential implementation of the recur_hseg subroutine described above (for details on lrhseg see the section of this document entitled “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER. ” At recursion level <b>6</b>, lrhseg initiates the processing of the data with ncols=240 and nrows=216. At recursion level <b>7</b>, lrhseg initiates the processing of the data with ncols=120 and nrows=108. At recursion level <b>8</b>, lrhseg initiates the processing of the data with ncols=60 and nrows=54. Finally, at recursion level <b>9</b>, lrhseg initiates the processing of the data with ncols=30 and nrows=27.</p>
  <p num="p-0056">At recursion level <b>9</b>, lrhseg calls the hseg subroutine, which is an implementation of the basic HSEG algorithm described above, but without convergence checking (for details on hseg see the section of this document entitled “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER. When the number of regions reaches minregions (a preset parameter), the results are returned to the lrhseg subroutine at recursion level <b>8</b>. After all four calls are made and completed to lrhseg at recursion level <b>9</b>, the lrhseg subroutine at recursion level <b>8</b> calls the hseg subroutine. After all four calls are made and completed to lrhseg at recursion level <b>8</b>, the lrhseg subroutine at recursion level <b>7</b> calls the hseg subroutine. After all four calls are made and completed to lrhseg at recursion level <b>7</b>, the Irhseg subroutine at recursion level <b>6</b> calls the hseg subroutine. After all four calls are made and completed to lrhseg at recursion level <b>6</b>, the lrhseg subroutine at recursion level <b>5</b> calls the hseg subroutine.</p>
  <p num="p-0057">When the slave programs operating at recursion level <b>5</b> complete their calls to the hseg subroutine, they each return their results and their input data to the slave programs that called them at recursion level <b>4</b>. When the slave programs at recursion level <b>4</b> receive the results from each of their four branch tasks, each of them then call the hseg subroutine. When the slave programs operating at recursion level <b>4</b> complete their calls to the hseg subroutine, they each return their results and their input data to the slave programs that called them at recursion level <b>3</b>.</p>
  <p num="p-0058">When the slave programs at recursion level <b>3</b> receive the results from each of their four branch tasks, each of them then call the hseg subroutine. Now since these slave programs are operating at the final recursion level, fnb_levels=3, upon completion of the call to the hseg subroutine, they do not return their input data to the slave programs that called them at the recursion level <b>2</b>, and only return their segmentation results except for the region label map.</p>
  <p num="p-0059">When the slave programs at recursion level <b>2</b> receive the results from each of their four branch tasks, each of them then call the hseg subroutine. Upon completion of the call to the hseg subroutine, these slave programs make a special call to the slave programs at recursion level fnb_levels below them that updates the region label map based on the results from the hseg subroutine. Then these slave programs return their segmentations results (except for the region label map) to the slave program that called them at recursion level <b>1</b> (in this case, the slave program running task <b>0</b>).</p>
  <p num="p-0060">When the slave program at recursion level <b>1</b> (this is the slave program running task <b>0</b>) receives the results from each of its four branch tasks it calls the hseg subroutine, with minregions reset to the value of chkregions (see the HSEG Basic Algorithm Description above). Upon completion of the call to the hseg subroutine, this slave program makes a special call to the slave programs at recursion level fnb_levels to update the region label map based on the results from the hseg program. Then this slave program calls the phseg subroutine, which is an implementation of the basic HSEG algorithm with convergence.</p>
  <p num="p-0061">In lhseg the region label map data are not updated (the region label map data are updated all at once after lhseg exits). However, in phseg the region label map data, which is maintained by the slave programs running the tasks at recursion level fnb_levels, is updated after each group of region growing and spectral clustering merges (steps 2 through 5 of the basic HSEG algorithm described above). In addition, the global criterion value, critval, is calculated after each group of region growing and spectral clustering merges from information calculated by the slave programs running the tasks at recursion level fnb_levels and accumulated by the slave program running task <b>0</b> at recursion level <b>1</b>. When a convergence iteration is found, phseg sends its results to the master program and causes the slave programs running the tasks at recursion level fnb_levels to send their region label map data to the master program.</p>
  <p num="p-0062">If we had not used the above-described parallel implementation, it would not have been possible to process our example Landsat TM image on any presently available parallel computing platform. To simulate this situation, consider the case where rnb_levels=inb_levels=fnb_levels=9 and we try to process our 7680 columns by 6912 row Landsat TM image.</p>
  <p num="p-0063">In this case, the initialization portions of the descriptions for recursion levels <b>1</b> through <b>4</b> will the same as above with the following exception: last_sec would equal 65,535 (the data would be processed in 65,536 sections at the new value for inb_levels). In addition, at recursion level <b>5</b> (the previous value of inb_levels), no request for input data would be made. Instead, a request would be made to the master program for four-branch slave task IDs. This would result in the initiation of 1024 tasks for recursion level <b>6</b>. Similarly 4096 tasks would be initiated at recursion level <b>7</b>, 16,384 tasks would be initiated at recursion level <b>8</b> and 65,636 tasks would be initiated at recursion level <b>9</b>. This would result in a total of 87,381 slave tasks being initiated on the on the parallel computing system. This would either not be allowed by the parallel computing system, or would totally swamp the system, probably resulting in a system failure.</p>
  <p num="p-0064">Consider also the significance of setting the value of fnb_levels to a value less than inb_levels. To simulate this situation, consider the case where rnb_levels=9, inb_levels=fnb_levels=5. In this case, the phseg subroutine would have to communicate with 256 slave tasks at recursion level <b>5</b> to update the region label map, perform convergence checking, or cause the region label map results to be sent to the master program. When fnb_levels=3 as in the original example, the phseg subroutine only has to communicate with 16 slave tasks at recursion level <b>3</b> to perform these tasks, significantly reducing the interprocessor communication requirements of the program.</p>
  <p num="p-0065">Finally, consider yet another pathological situation where fnb_levels=1. In this case the slave task <b>0</b> would have to maintain in memory the full Landsat TM data set plus the full region label map. For our example, the data volume of just these items is about 425 megabytes. On the augmented HIVE system, if the RAM is distributed evenly among the processors, the Dell PCs have 125 megabytes RAM per processor, the Gateway PCs have 250 megabytes RAM per processor and the Pentium Pro PCs have just under 220 megabytes RAM per processor. Thus, slave task <b>0</b> would crash due to memory constraints on any of these processing nodes if fnb_levels was set to 1 for a Landsat TM data set of this size (7680 columns by 6912 rows).</p>
  <p num="p-0066">The description that follows is intended to assist one of ordinary skill in the art implement the present invention. The following description is merely one approach, and it can be appreciated by one of ordinary skill in the art that numerous other approaches are possible as well. The below materials assume familiarity with the “C” programming language, and with programming parallel computers using “PVM” software.</p>
  <p num="p-0067">While the implementation described here is the implementation for the HIVE, this implementation has also been applied, with minor modifications, to other MIMD parallel computers including the Cray T3E and IBM NetFinity computers. Based on this description, individuals should also be able to implement this approach using other programming languages and/or other system software for parallel computers on other parallel computers.</p>
  <p num="p-0068">The recursive hierarchical image segmentation algorithm, RHSEG, is implemented in three distinct parts:
</p> <ul> <li id="ul0009-0001" num="0093">i. a generic interface program that sets up a remote call to a parallel computer, and which should be runable on any workstation running UNIX or many of its variants,</li> <li id="ul0009-0002" num="0094">ii. a “master” program that runs on the front end of a parallel computer, accepts inputs from the part (i) program, calls many instances of the “slave” program (see below), provides the required inputs to the “slave” programs, accepts and assembles the results from the various “slave” programs, sending the assembled results back to the interface program of part (i), and</li> <li id="ul0009-0003" num="0095">iii. the “slave” program, many instances of which run on the multiple processors of the parallel computer and perform the recursive version of the hybrid region growing and spectral clustering algorithm summarily described in Section I, Part B above, sending the results back to the “master” program of part (ii).
<br/>
Note that part (i) of the RHSEG program could be run on the front end of the parallel computer, or combined with part (ii) of the parallel computer, if the parallel computer&#39;s host computer is running under a UNIX variant.
</li> </ul>

  <p num="p-0069">In addition, an optional graphical user interface (GUI) program, implemented under the KHOROS PRO 2000 Software Developer&#39;s Kit is available. This GUI program runs on any workstation running UNIX or many of its variants. It creates the parameter file and the headerless binary input data files required by the generic interface program (i). This GUI program is totally optional, as the parameter file and the headerless binary input data files required by the generic interface program (i) can be created manually. The optional user interface and data reformatting program outputs the results in the form of Khoros data objects. These Khoros data objects can be input to separate programs for further analysis.</p>
  <p num="p-0070">RHSEG requires the specification of the name of an input parameter file as a UNIX command line argument (fully qualified with path, if not in the local directory). This input parameter file must specify of a number of file names and several parameters. A user&#39;s guide-like description of these file names and parameters is given below:</p>
  <p num="p-0071"> <tables id="TABLE-US-00002" num="00002"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> <colspec colname="3" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>input</entry> <entry>(required input file)</entry> <entry>Input image data file</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The input image data file from which a hierarchical image segmentation is to be produced. This image data file is assumed to be a headerless binary image file in band sequential format. The number of columns, rows, spectral bands and the data type are specified by other required parameters (see below). Data types “unsigned char” and “unsigned short” are supported.
</p>
  <p num="p-0072"> <tables id="TABLE-US-00003" num="00003"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="28pt" align="left"> </colspec> <colspec colname="2" colwidth="63pt" align="left"> </colspec> <colspec colname="3" colwidth="63pt" align="left"> </colspec> <colspec colname="4" colwidth="63pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>mask</entry> <entry>(optional input file)</entry> <entry>Input data mask</entry> <entry>(default = {none})</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The optional input data mask must match the input image data in number of columns and rows. Even if the input image data has more than one spectral band, the input data mask need only have one spectral band. If the input data mask has more than one spectral band, only the first spectral band is used, and is assumed to apply to all spectral bands for the input image data. If the data value of the input data mask is “1” (TRUE), the corresponding value of the input image data object is taken to be a valid data value. If the data value of the input data mask object is “0” (FALSE), the corresponding value of the input image data object is taken to be invalid, and a region label of “0” is assigned to that spatial location in the output region label map data. The input data mask data type is assumed to be “unsigned char.”
</p>
  <p num="p-0073"> <tables id="TABLE-US-00004" num="00004"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="70pt" align="left"> </colspec> <colspec colname="3" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>rlblmap_in</entry> <entry>(optional input file)</entry> <entry>Input region label map</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = {none})</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The optional region label map must match the input image data in number of columns and rows. If provided, the image segmentation is initialized according to the input region label map instead of the default of each pixel as a separate region. Wherever a region label of “0” is given by the input region label map, the region labeling is assumed to be unknown, and the region label map is initialized to one pixel regions at those locations. The input region label map data type is assumed to be “unsigned short.”
</p>
  <p num="p-0074"> <tables id="TABLE-US-00005" num="00005"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> <colspec colname="3" colwidth="98pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>rlblmap</entry> <entry>(required output file)</entry> <entry>Output region label map data</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The hierarchical set of region label maps that are the main output of RHSEG. Region label values of “0” correspond to invalid input data values in the image data object. Valid region label values range from 1 through 65535. The data is of data type “unsigned short” and is stored in band sequential format, where band corresponds to the segmentation hierarchy level. If the optional region merges list, regmerges, is specified, only the first, most detailed, region label map from the segmentation hierarchy is stored.
</p>
  <p num="p-0075"> <tables id="TABLE-US-00006" num="00006"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="35pt" align="left"> </colspec> <colspec colname="2" colwidth="70pt" align="left"> </colspec> <colspec colname="3" colwidth="112pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>rnpixlist</entry> <entry>(required output file)</entry> <entry>Output region number of pixels list</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The region number of pixels list is a required output of RHSEG. This list consists of the number of pixels (of data type “unsigned int”) in each region stored as rows of values, with the column location (with counting starting at 1) corresponding to the region label value and the row location corresponding to the segmentation hierarchy level (with counting starting at 0).
</p>
  <p num="p-0076"> <tables id="TABLE-US-00007" num="00007"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="70pt" align="left"> </colspec> <colspec colname="3" colwidth="91pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>regmerges</entry> <entry>(optional output file)</entry> <entry>Output region merges list</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = {none})</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The region merges list is an optional output of RHSEG. This list consists of the renumberings of the region label map required to obtain the region label map for the second through the last (coarsest) level of the segmentation hierarchy from the region label map for the first (most detailed) level of the segmentation hierarchy (data type “unsigned short”). The data is stored as rows of values, with the column location (with counting starting at 1) corresponding to the region label value in the first (most detailed) level of the segmentation hierarchy and the row location corresponding to the segmentation hierarchy level (the l<sup>th </sup>row is the renumberings required to obtain the (l+1)<sup>th </sup>level of the segmentation hierarchy).
</p>
  <p num="p-0077"> <tables id="TABLE-US-00008" num="00008"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="70pt" align="left"> </colspec> <colspec colname="3" colwidth="91pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>rmeanlist</entry> <entry>(optional output file)</entry> <entry>Output region mean list</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = {none})</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The region mean list is an optional output of RHSEG. This list consists of the region mean value (of data type “float”) of each region stored as rows of values and groups of rows, with the column location (with counting starting at 1) corresponding to the region label value, the row location (in each row group) corresponding the spectral band, and row group corresponding to the segmentation hierarchy level (with counting starting at 0).
</p>
  <p num="p-0078"> <tables id="TABLE-US-00009" num="00009"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="70pt" align="left"> </colspec> <colspec colname="3" colwidth="105pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>rcvlist</entry> <entry>(optional output file)</entry> <entry>Output region criterion value list</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = {none})</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The region criterion value list is an optional output of RHSEG. This list consists of the region&#39;s contribution to the global criterion value (of data type “float”) stored as rows of values, with the column location (with counting starting at 1) corresponding to the region label value and the row location corresponding to the segmentation hierarchy level (with counting starting at 0).
</p>
  <p num="p-0079"> <tables id="TABLE-US-00010" num="00010"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="84pt" align="left"> </colspec> <colspec colname="3" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>oparam</entry> <entry>(required output file)</entry> <entry>output parameter file</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The required output parameter file contains (in binary form) the number of hierarchical segmentation levels (nslevels) in the hierarchical segmentation output, and the number of regions (onregions) in the hierarchical segmentation with the finest segmentation detail. These values are required to interpret the rnpixlist, regmerges, rmeanlist, and rcvlist output files.
</p>
  <p num="p-0080"> <tables id="TABLE-US-00011" num="00011"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="84pt" align="left"> </colspec> <colspec colname="3" colwidth="70pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>log_file</entry> <entry>(required output file)</entry> <entry>output log file</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
The required output log file records program parameters and the number of regions and global criterion ratio value for each level of the region segmentation hierarchy.
</p>
  <p num="p-0081">
    <tables id="TABLE-US-00012" num="00012">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="1" colwidth="35pt" align="left"> </colspec>
          <colspec colname="2" colwidth="56pt" align="left"> </colspec>
          <colspec colname="3" colwidth="126pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>(required integer)</entry>
              <entry>Number of columns in input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>(required integer)</entry>
              <entry>Number of rows in input image data</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>(required integer)</entry>
              <entry>Number of spectral bands in input image</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>data</entry>
            </row> <row>
              <entry>dtype</entry>
              <entry>(required integer)</entry>
              <entry>Data type of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>dtype = 4 designates “unsigned char”</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>dtype = 16 designates “unsigned short”</entry>
            </row> <row>
              <entry>normind</entry>
              <entry>(optional list</entry>
              <entry>Image normalization type</entry>
            </row> <row>
              <entry> </entry>
              <entry>selection)</entry>
            </row> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0082">1 “No Normalization”,</p>
  <p num="p-0083">2 “Normalize Across Bands”,</p>
  <p num="p-0084">3 “Normalize Bands Separately” [default: 2 “Normalize Across Bands”]
<br/>
Let X<sub>bi </sub>be the original value for the i<sup>th </sup>pixel (out of N pixels) in the b<sup>th </sup>band (out of B bands). The mean and variance of the b<sup>th </sup>band are 
<maths id="MATH-US-00005" num="00005"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> <mo>=</mo> <mrow> <mfrac> <mn>1</mn> <mi>N</mi> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <msub> <mi>x</mi> <mi>bi</mi> </msub> </mrow> </mrow> </mrow> <mo>,</mo> <mrow> <mrow> <mi>and</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <msubsup> <mi>σ</mi> <mi>b</mi> <mn>2</mn> </msubsup> </mrow> <mo>=</mo> <mrow> <mfrac> <mn>1</mn> <mrow> <mi>N</mi> <mo>-</mo> <mn>1</mn> </mrow> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <msup> <mrow> <mo>(</mo> <mrow> <msub> <mi>x</mi> <mi>bi</mi> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> </mrow> <mo>)</mo> </mrow> <mn>2</mn> </msup> </mrow> </mrow> </mrow> <mo>,</mo> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>1</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
respectively. To normalize the data to have mean=M<sub>b </sub>and variance=S<sup>2</sup>, set 
<maths id="MATH-US-00006" num="00006"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <msub> <mi>y</mi> <mi>bi</mi> </msub> <mo>=</mo> <mrow> <mrow> <mo>[</mo> <mrow> <mfrac> <mi>S</mi> <msub> <mi>σ</mi> <mi>b</mi> </msub> </mfrac> <mo>⁢</mo> <mrow> <mo>(</mo> <mrow> <msub> <mi>x</mi> <mi>bi</mi> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> </mrow> <mo>)</mo> </mrow> </mrow> <mo>]</mo> </mrow> <mo>+</mo> <mrow> <msub> <mi>M</mi> <mi>b</mi> </msub> <mo>.</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>2</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
For convenience, the data is normalized so that S<sup>2 </sup>(=S)=1. Since the entropy criterion requires that all data values be strictly positive, we set the mean value, M<sub>b</sub>, of the normalized data to be the value that will produce a minimum value of 2 (so as to avoid computational problems calculating ln(y<sub>bi</sub>). That is, 
<maths id="MATH-US-00007" num="00007"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <msub> <mi>M</mi> <mi>b</mi> </msub> <mo>=</mo> <mrow> <mn>2</mn> <mo>-</mo> <mrow> <mi>min</mi> <mo>⁢</mo> <mrow> <mrow> <mo>{</mo> <mrow> <mrow> <mrow> <mrow> <mo>[</mo> <mrow> <mfrac> <mn>1</mn> <msub> <mi>σ</mi> <mi>b</mi> </msub> </mfrac> <mo>⁢</mo> <mrow> <mo>(</mo> <mrow> <msub> <mi>x</mi> <mi>bi</mi> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> </mrow> <mo>)</mo> </mrow> </mrow> <mo>]</mo> </mrow> <mo>:</mo> <mi>i</mi> </mrow> <mo>=</mo> <mn>1</mn> </mrow> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mi>…</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>,</mo> <mi>N</mi> </mrow> <mo>}</mo> </mrow> <mo>.</mo> </mrow> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>3</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
The above description of image normalization applies to option <b>3</b>: “Normalize Bands Separately.” For option <b>2</b>: “Normalize Across Bands, ” use 
<maths id="MATH-US-00008" num="00008"> <math overflow="scroll"> <mrow> <mi>σ</mi> <mo>=</mo> <mrow> <munder> <mi>max</mi> <mi>b</mi> </munder> <mo>⁢</mo> <mrow> <mo>(</mo> <msub> <mi>σ</mi> <mi>b</mi> </msub> <mo>)</mo> </mrow> </mrow> </mrow> </math> </maths>
<br/>
for σ<sub>b </sub>in Equations (2) and (3), and perform the minimization in Equation (3) across all bands as well as across all image pixels.
</p>
  <p num="p-0085">
    <tables id="TABLE-US-00013" num="00013">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="1" colwidth="35pt" align="left"> </colspec>
          <colspec colname="2" colwidth="56pt" align="left"> </colspec>
          <colspec colname="3" colwidth="126pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>(optional integer)</entry>
              <entry>Value equals number of nearest neighbors</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(Permissible values: 4, 8, 12 or 20;</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 8)</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>(optional list</entry>
              <entry>Dissimilarity criterion</entry>
            </row> <row>
              <entry> </entry>
              <entry>selection)</entry>
            </row> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0086">1 “1-Norm”,</p>
  <p num="p-0087">2 “2-Norm”,</p>
  <p num="p-0088">3 “Infinity Norm”, [default: 1 “1-Norm”]
<br/>
Criterion for evaluating the dissimilarity of one region from another. The 1-Norm for regions j and k is (for B spectral bands) 
<maths id="MATH-US-00009" num="00009"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mn>1</mn> <mo>-</mo> <mi>Norm</mi> </mrow> <mo>=</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <mrow> <mrow> <mo></mo> <mrow> <mover> <msub> <mi>x</mi> <mi>b</mi> </msub> <mrow> <mo>-</mo> <mi>j</mi> </mrow> </mover> <mo>-</mo> <mover> <msub> <mi>x</mi> <mi>b</mi> </msub> <mrow> <mo>-</mo> <mi>k</mi> </mrow> </mover> </mrow> <mo></mo> </mrow> <mo>.</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>4</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
where 
<maths id="MATH-US-00010" num="00010"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mrow> <mn>2</mn> <mo>-</mo> <mi>Norm</mi> </mrow> <mo>=</mo> <msup> <mrow> <mo>[</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <msup> <mrow> <mo>(</mo> <mrow> <mover> <msub> <mi>x</mi> <mi>b</mi> </msub> <mrow> <mo>-</mo> <mi>j</mi> </mrow> </mover> <mo>-</mo> <mover> <msub> <mi>x</mi> <mi>b</mi> </msub> <mrow> <mo>-</mo> <mi>k</mi> </mrow> </mover> </mrow> <mo>)</mo> </mrow> <mn>2</mn> </msup> </mrow> <mo>]</mo> </mrow> <mrow> <mn>1</mn> <mo>/</mo> <mn>2</mn> </mrow> </msup> </mrow> <mo>,</mo> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>5</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
are the mean values for regions j and k, respectively, in spectral band b. Similarly, the 2-Norm is 
<maths id="MATH-US-00011" num="00011"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mrow> <mn>2</mn> <mo>⁢</mo> <mstyle> <mtext>-Norm</mtext> </mstyle> </mrow> <mo>=</mo> <msup> <mrow> <mo>[</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <msup> <mrow> <mo>(</mo> <mrow> <msubsup> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> <mi>j</mi> </msubsup> <mo>-</mo> <msubsup> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> <mi>k</mi> </msubsup> </mrow> <mo>)</mo> </mrow> <mn>2</mn> </msup> </mrow> <mo>]</mo> </mrow> <mfrac> <mn>1</mn> <mn>2</mn> </mfrac> </msup> </mrow> <mo>,</mo> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>5</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
and the Infinity-Norm is 
<maths id="MATH-US-00012" num="00012"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mstyle> <mtext>Infinity-Norm</mtext> </mstyle> <mo>=</mo> <mrow> <mi>max</mi> <mo>⁢</mo> <mrow> <mrow> <mo>{</mo> <mrow> <mrow> <mrow> <mrow> <mo>|</mo> <mrow> <msubsup> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> <mi>j</mi> </msubsup> <mo>-</mo> <msubsup> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> <mi>k</mi> </msubsup> </mrow> <mo>|</mo> </mrow> <mo>:</mo> <mi>b</mi> </mrow> <mo>=</mo> <mn>1</mn> </mrow> <mo>,</mo> <mn>2</mn> <mo>,</mo> <mi>…</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>,</mo> <mi>B</mi> </mrow> <mo>}</mo> </mrow> <mo>.</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>6</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
NOTE: Other dissimilarity criterion can be included as additional options without changing the nature of the RHSEG implementation.
</p>
  <p num="p-0089"> <tables id="TABLE-US-00014" num="00014"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> <colspec colname="3" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>extmean</entry> <entry>(optional Boolean)</entry> <entry>Flag for extracting mean</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(default = TRUE)</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
If this flag is set TRUE, the vector mean is subtracted from the spectral vectors before the dissimilarity criterion is calculated between two spectral vectors. The absolute difference between the two vector means is subsequently added back to the dissimilarity criterion. In the case of the 1-Norm, this is represented mathematically for regions j and k as follows (for B spectral bands): 
<maths id="MATH-US-00013" num="00013"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mrow> <mi>L</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>t</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <msub> <mi>z</mi> <mi>bj</mi> </msub> </mrow> <mo>=</mo> <mrow> <mrow> <msub> <mi>x</mi> <mi>bj</mi> </msub> <mo>-</mo> <mrow> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>j</mi> </msub> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>d</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <msub> <mi>z</mi> <mi>bk</mi> </msub> </mrow> </mrow> <mo>=</mo> <mrow> <msub> <mi>x</mi> <mi>bk</mi> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>k</mi> </msub> </mrow> </mrow> </mrow> <mo>,</mo> <mstyle> <mtext>
</mtext> </mstyle> <mo>⁢</mo> <mrow> <mrow> <mi>w</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>h</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>r</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>j</mi> </msub> </mrow> <mo>=</mo> <mrow> <mrow> <mfrac> <mn>1</mn> <mi>B</mi> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <mrow> <msub> <mi>x</mi> <mi>bj</mi> </msub> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>d</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>k</mi> </msub> </mrow> </mrow> </mrow> <mo>=</mo> <mrow> <mfrac> <mn>1</mn> <mi>B</mi> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <mrow> <mrow> <msub> <mi>x</mi> <mi>bk</mi> </msub> <mo>.</mo> <mstyle> <mtext>
</mtext> </mstyle> <mo>⁢</mo> <mi>T</mi> </mrow> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>h</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> </mrow> </mrow> </mrow> </mrow> </mrow> </mrow> </mtd> <mtd> <mstyle> <mtext> </mtext> </mstyle> </mtd> </mtr> <mtr> <mtd> <mrow> <mrow> <mn>1</mn> <mo>-</mo> <mrow> <mi>Norm</mi> <mo>⁡</mo> <mrow> <mo>(</mo> <mrow> <mi>extmean</mi> <mo>⩵</mo> <mrow> <mi>T</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>R</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>U</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>E</mi> </mrow> </mrow> <mo>)</mo> </mrow> </mrow> </mrow> <mo>=</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>b</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>B</mi> </munderover> <mo>⁢</mo> <mrow> <mo>|</mo> <mrow> <msub> <mi>z</mi> <mi>bj</mi> </msub> <mo>-</mo> <msub> <mi>z</mi> <mi>bk</mi> </msub> </mrow> <mo>|</mo> <mrow> <mo>+</mo> <mrow> <mo>|</mo> <mrow> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>j</mi> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>k</mi> </msub> </mrow> <mo>|</mo> <mo>.</mo> </mrow> </mrow> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>7</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths> <br/>
The extracted mean versions for the 2-Norm, Infinity-Norm and other dissimilarity criterion are defined similarly.
</p>
  <p num="p-0090"> <tables id="TABLE-US-00015" num="00015"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="28pt" align="left"> </colspec> <colspec colname="2" colwidth="63pt" align="left"> </colspec> <colspec colname="3" colwidth="126pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>spclust</entry> <entry>(optional Boolean)</entry> <entry>Spectral clustering flag (default = TRUE)</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  </table> </tables> <br/>
If the spectral clustering flag is TRUE, spectral clustering is performed in-between each iteration of region growing. Otherwise, no spectral clustering is performed.
</p>
  <p num="p-0091"> <tables id="TABLE-US-00016" num="00016"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="49pt" align="left"> </colspec> <colspec colname="3" colwidth="119pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_wght</entry> <entry>(optional float)</entry> <entry>Weight for spatial feature</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(spatial_wght &gt;= 0.0, default = 0.0)</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
If the value of spatial_wght is more than 0.0, the spatial_type parameter (below) determines whether the band maximum variance or standard deviation is used as a feature in the dissimilarity criterion in combination with the spectral band features. spatial_wght=1.0 weights the spatial feature equally with the spectral band features, spatial_wght&lt;1.0 weights the spatial feature less and spatial_wght&gt;1 weights the spatial feature more. If D is the dissimilarity function value before combination with the spatial feature value, the combined dissimilarity function value (comparing regions j and k), D<sup>C</sup>, is:
<br/> <i>D</i> <sup>C</sup> <i>=D+spatial</i>_wght*|<i>sf</i> <sub>j</sub> <i>−sf</i> <sub>k</sub>|  (8)<br/>
where sf<sub>j </sub>and sf<sub>k </sub>are the spatial feature values for regions j and k, respectively.
</p>
  <p num="p-0092"> <tables id="TABLE-US-00017" num="00017"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> <colspec colname="3" colwidth="98pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_type</entry> <entry>(optional list selection)</entry> <entry>Spatial feature type</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>1 “Variance”,</entry> <entry> </entry> </row> <row> <entry> </entry> <entry>2 “Standard Deviation”</entry> <entry>[default: 2 “Standard Deviation”</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The (optional) spatial feature is either the spectral band maximum region variance or spectral band maximum region standard deviation. This parameter is ignored if spatial_wght=0.0.
</p>
  <p num="p-0093">For regions consisting of 9 or more pixels, the region variance for spectral band b is: 
<maths id="MATH-US-00014" num="00014"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <msubsup> <mi>σ</mi> <mi>b</mi> <mn>2</mn> </msubsup> <mo>=</mo> <mrow> <mrow> <mfrac> <mn>1</mn> <mrow> <mi>N</mi> <mo>-</mo> <mn>1</mn> </mrow> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <msup> <mrow> <mo>(</mo> <mrow> <msub> <mi>x</mi> <mrow> <mi>b</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> </mrow> </msub> <mo>-</mo> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> </mrow> <mo>)</mo> </mrow> <mn>2</mn> </msup> </mrow> </mrow> <mo>=</mo> <mrow> <mfrac> <mn>1</mn> <mrow> <mi>N</mi> <mo>-</mo> <mn>1</mn> </mrow> </mfrac> <mo>⁡</mo> <mrow> <mo>[</mo> <mrow> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <msubsup> <mi>x</mi> <mrow> <mi>b</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> </mrow> <mn>2</mn> </msubsup> </mrow> <mo>-</mo> <mrow> <mi>N</mi> <mo>⁢</mo> <msubsup> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> <mn>2</mn> </msubsup> </mrow> </mrow> <mo>]</mo> </mrow> </mrow> </mrow> </mrow> <mo>,</mo> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>9</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
where N is the number of pixels in the region, and {overscore (x)}<sub>b </sub>is the region mean for spectral band b: 
<maths id="MATH-US-00015" num="00015"> <math overflow="scroll"> <mrow> <msub> <mover> <mi>x</mi> <mi>_</mi> </mover> <mi>b</mi> </msub> <mo>=</mo> <mrow> <mfrac> <mn>1</mn> <mi>N</mi> </mfrac> <mo>⁢</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mi>N</mi> </munderover> <mo>⁢</mo> <mrow> <msub> <mi>x</mi> <mrow> <mi>b</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> </mrow> </msub> <mo>.</mo> </mrow> </mrow> </mrow> </mrow> </math> </maths>
<br/>
The region spatial feature value is then defined as:
<br/>
σ<sup>2</sup>=max{σ<sub>b</sub> <sup>2</sup> <i>:b</i>=1,2, . . . , <i>B}</i>  (10)
<br/>
where B is the number of spectral bands.
</p>
  <p num="p-0094">For regions consisting only 1 pixel, the maximum over bands of the minimum local variance (mlσ<sup>2</sup>) calculated over all possible 3×3 windows containing the pixel is used as a substitute for the band maximum region variance.</p>
  <p num="p-0095">For regions consisting of 2 up through 8 pixels, a weighted average of the band maximum minimum local variance and the band maximum region variance is substituted for the band maximum region variance as follows: 
<maths id="MATH-US-00016" num="00016"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mtable> <mtr> <mtd> <mrow> <mn>2</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.875</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.125</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>3</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.75</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.25</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>4</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.625</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.375</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>5</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.50</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.50</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>6</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.375</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.625</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>7</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.25</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.75</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mn>8</mn> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>pixels</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>regions</mi> <mo>:</mo> </mrow> </mrow> </mtd> <mtd> <mrow> <mrow> <mn>0.125</mn> <mo>*</mo> <msup> <mrow> <mi>ml</mi> <mo>⁢</mo> <mi>σ</mi> </mrow> <mn>2</mn> </msup> </mrow> <mo>+</mo> <mrow> <mn>0.875</mn> <mo>*</mo> <msup> <mi>σ</mi> <mn>2</mn> </msup> </mrow> </mrow> </mtd> </mtr> </mtable> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>11</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
If the spatial_type “Standard Deviation” is chosen, substitute the region standard deviation (σ<sub>b</sub>=sqrt(σ<sub>b</sub> <sup>2</sup>)) for the region variance (σ<sub>b</sub> <sup>2</sup>) in the above discussion.
</p>
  <p num="p-0096">
    <tables id="TABLE-US-00018" num="00018">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="35pt" align="left"> </colspec>
          <colspec colname="3" colwidth="133pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>(optional</entry>
              <entry>Total number of recursive levels</entry>
            </row> <row>
              <entry> </entry>
              <entry>integer)</entry>
              <entry>(1 &lt;= rnb_levels &lt;= 9, default = 4)</entry>
            </row> <row>
              <entry>inb_levels</entry>
              <entry>(optional</entry>
              <entry>Recursive level of intermediate level</entry>
            </row> <row>
              <entry> </entry>
              <entry>integer)</entry>
              <entry>(1 &lt;= inb_levels &lt;= 9, default = 4)</entry>
            </row> <row>
              <entry>fnb_levels</entry>
              <entry>(optional</entry>
              <entry>Number of recursive levels in final stage</entry>
            </row> <row>
              <entry> </entry>
              <entry>integer)</entry>
              <entry>(1 &lt;= fnb_levels &lt;= 9, default = 4)</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>(optional</entry>
              <entry>Number of regions for convergence in</entry>
            </row> <row>
              <entry> </entry>
              <entry>integer)</entry>
              <entry>recursive stages</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(2 &lt;= minregions &lt;= 4096, default = 384)</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>(optional</entry>
              <entry>Number of regions at which convergence</entry>
            </row> <row>
              <entry> </entry>
              <entry>integer)</entry>
              <entry>factor checking is initiated in final stage</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(2 &lt;= chkregions &lt;= 4096, default = 512)</entry>
            </row> <row>
              <entry>convfact</entry>
              <entry>(optional</entry>
              <entry>Convergence factor</entry>
            </row> <row>
              <entry> </entry>
              <entry>float)</entry>
              <entry>(1 &lt;= convfact &lt;= 100, default = 1.01)</entry>
            </row> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry namest="1" nameend="3" align="left">NOTE: </entry>
            </row> <row>
              <entry namest="1" nameend="3" align="left">It is required that fnb_levels &lt;= inb_levels &lt;= rnb_levels. </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0097">As specified in the HSEG Basic Algorithm Description, if the calculated cvratio is greater than convfact, “raw” segmentation results are output from the previous iteration. The set of such segmentation results output make up the hierarchical segmentation output. The value of cvratio is computed as the ratio between critval, the global criterion value for the current iteration, and prevcritval, the global criterion value for the previous iteration. The value of the global criterion is calculated by computing the dissimilarity function at each image point between the original image values and the region mean image and averaging the result over the entire image.</p>
  <p num="p-0098"> <tables id="TABLE-US-00019" num="00019"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="91pt" align="left"> </colspec> <colspec colname="3" colwidth="70pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>process</entry> <entry>(optional list selection)</entry> <entry>Processing options flag</entry> </row> <row> <entry> </entry> <entry>1 “All Stages Locally”,</entry> </row> <row> <entry> </entry> <entry>2 “All Stages on HIVE”,</entry> </row> <row> <entry> </entry> <entry>3 “All Stages on Cray T3E”,</entry> </row> <row> <entry> </entry> <entry>4 “All Stages on NetFinity”</entry> </row> <row> <entry>nb_pes</entry> <entry>(optional integer)</entry> <entry>Maximum number of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>tasks or Cray PEs to</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>be utilized</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = 384)</entry> </row> <row> <entry>cray_time_limit</entry> <entry>(optional list selection)</entry> <entry>Cray time limit used to</entry> </row> <row> <entry> </entry> <entry>1 “20 minutes: pipe queue”,</entry> <entry>select queue</entry> </row> <row> <entry> </entry> <entry>2 “60 minutes:</entry> </row> <row> <entry> </entry> <entry>  all_60_queue”,</entry> </row> <row> <entry> </entry> <entry>3 “4.4 hours: t3e_all_queue”</entry> <entry>[default: 1 “20 </entry> </row> <row> <entry> </entry> <entry> </entry> <entry>minutes: pipe queue”,</entry> </row> <row> <entry>host</entry> <entry>(required string)</entry> <entry>Workstation hostname</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = {none})</entry> </row> <row> <entry>tmpdir</entry> <entry>(optional string)</entry> <entry>Path name to directory</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>in which temporary</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>files are to be stored</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(default = $TMPDIR)</entry> </row> <row> <entry>tempfile</entry> <entry>(optional string)</entry> <entry>Prefix for temporary</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>file names (default</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>RHSEG#########,</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>where the # are</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>random characters)</entry> </row> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                            </tbody>  </table> </tables> <br/>
Previous disclosures did not reveal a number of implementation details revealed by the above user&#39;s guide description of RHSEG. The variables inb_levels, and fnb_levels did not exist in implementations previously disclosed. In these previously disclosed implementations, a single variable, rnb_levels (or nb_levels), took the place of these new variables. This is a key distinction between previously disclosed implementations and the implementation described in this patent application which enables RHSEG to run significantly faster on a parallel computer, such as the HIVE. See <figref idrefs="DRAWINGS">FIG. 7</figref> for a graphical depiction of how the values of rnb_levels, inb_levels, and fnb_levels control how processes are allocated and utilized on a parallel computer.
</p>
  <p num="p-0099"> <figref idrefs="DRAWINGS">FIG. 7</figref> is a graphical representation of the “master” process and “slave” processes executing the RHSEG program on a parallel computer. In this case, fnb_levels is 2 (2×2), inb_levels is 3 (4×4) and rnb_levels is 5 (16×16), and the input image has 512 columns and 512 rows. Slave tasks at the highest level of recursion (here rnb_levels 5) process 32-by-32 pixel sections of data. A total of 21 slave processes (tasks) are utilized. The number next to each slave process node is the slave task number. Slave tasks at level&gt;=inb_levels make serial recursive calls within the same task and slave tasks at level&lt;inb_levels make parallel recursive calls to different slave tasks (branch tasks). Data is inputted at level=inb_levels and the region label map output is made from level=fnb_levels .</p>
  <p num="h-0006">C. Functional Operation</p>
  <p num="p-0100">Description of part (i) of the RHSEG implementation: Part (i) of the RHSEG program was implemented in “C” under the gcc version 2.8.1 compiler. It was developed under the Solaris 7 operating system on a SUN Workstation, but it should both compile and run with other “C” compilers and under other UNIX-type operating systems, possibly with minor modification.</p>
  <p num="p-0101">The RHSEG program initially determines the name of the parameter file from the command line input, and reads in the parameters from the file using the function read_param( ). If a prefix for the temporary filenames in not provided in the parameter file, the program generates a character string to used at a prefix for file names for temporary files required by the program. The “C” library function tempnam( ) is used for this purpose. For the discussion below, this prefix is assumed to be “RHSEG0000 .”</p>
  <p num="p-0102">At this point the RHSEG main program opens the log file and outputs to it the program parameters using the function print_param( ). The following parameters are declared as external variables, and can be utilized in the main program and any “C” functions called subsequently.</p>
  <p num="p-0103">
    <tables id="TABLE-US-00020" num="00020">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>inputf</entry>
              <entry>A char array containing the name of the input</entry>
            </row> <row>
              <entry> </entry>
              <entry>image data file</entry>
            </row> <row>
              <entry>maskf</entry>
              <entry>A char array containing the name of the mask data</entry>
            </row> <row>
              <entry> </entry>
              <entry>file, if it exists. If no mask data file exists,</entry>
            </row> <row>
              <entry> </entry>
              <entry>maskf has the value “NULL.”</entry>
            </row> <row>
              <entry>rlblmap_inf</entry>
              <entry>A char array containing the name of the input</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data file, if it exists. If no</entry>
            </row> <row>
              <entry> </entry>
              <entry>mask data file exists, rlblmap_inf has the value</entry>
            </row> <row>
              <entry> </entry>
              <entry>“NULL.”</entry>
            </row> <row>
              <entry>rlblmapf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data file.</entry>
            </row> <row>
              <entry>rnpixlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region number of pixels list data file.</entry>
            </row> <row>
              <entry>regmergesf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region merges list data file, if requested. If</entry>
            </row> <row>
              <entry> </entry>
              <entry>the output region merges list data file is not</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested, regmergesf has the value “NULL.”</entry>
            </row> <row>
              <entry>rmeanlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region mean list data file, if requested. If the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region mean list data file is not</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested, rmeanlistf has the value “NULL.”</entry>
            </row> <row>
              <entry>rcvlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region criterion value list data file, if</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested. If the output region criterion value</entry>
            </row> <row>
              <entry> </entry>
              <entry>list data file is not requested, rcvlistf has</entry>
            </row> <row>
              <entry> </entry>
              <entry>the value “NULL.”</entry>
            </row> <row>
              <entry>oparamf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>parameter file.</entry>
            </row> <row>
              <entry>log_file</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>log file.</entry>
            </row> <row>
              <entry>host</entry>
              <entry>A char array containing the name of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>workstation running part (i) of the RHSEG</entry>
            </row> <row>
              <entry> </entry>
              <entry>implementation.</entry>
            </row> <row>
              <entry>tmpdir</entry>
              <entry>A char array containing the path name to the</entry>
            </row> <row>
              <entry> </entry>
              <entry>directory where temporary files are to be stored.</entry>
            </row> <row>
              <entry>tempfile</entry>
              <entry>A char array containing the prefix for temporary</entry>
            </row> <row>
              <entry> </entry>
              <entry>file names.</entry>
            </row> <row>
              <entry>mask_flag</entry>
              <entry>An int variable which has value TRUE if mask</entry>
            </row> <row>
              <entry> </entry>
              <entry>data exist (FALSE otherwise).</entry>
            </row> <row>
              <entry>rlblmap_in_flag</entry>
              <entry>An int variable which has value TRUE if input</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data is given (FALSE otherwise).</entry>
            </row> <row>
              <entry>regmerges_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region merges list is requested (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>rmeanlist_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region mean list is requested (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>rcvlist_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region criterion value list is requested</entry>
            </row> <row>
              <entry> </entry>
              <entry>(FALSE otherwise).</entry>
            </row> <row>
              <entry>spclust_flag</entry>
              <entry>An int variable that is TRUE if spectral</entry>
            </row> <row>
              <entry> </entry>
              <entry>clustering is to be performed (FALSE otherwise).</entry>
            </row> <row>
              <entry>process</entry>
              <entry>An int variable that specifies the computing</entry>
            </row> <row>
              <entry> </entry>
              <entry>platform to be utilized. Currently “1” signifies</entry>
            </row> <row>
              <entry> </entry>
              <entry>the local workstation, “2” signifies the HIVE,</entry>
            </row> <row>
              <entry> </entry>
              <entry>“3” signifies the Cray T3E and “4”</entry>
            </row> <row>
              <entry> </entry>
              <entry>signifies the IBM NetFinity.</entry>
            </row> <row>
              <entry>nb_pes</entry>
              <entry>An int variable specifying the maximum number</entry>
            </row> <row>
              <entry> </entry>
              <entry>of PEs (processing elements) to be requested</entry>
            </row> <row>
              <entry> </entry>
              <entry>on the Cray T3E. Utilized only if process = 3.</entry>
            </row> <row>
              <entry>cray_time_limit</entry>
              <entry>An int variable specifying the processing time</entry>
            </row> <row>
              <entry> </entry>
              <entry>limit to be used in determining which queue to</entry>
            </row> <row>
              <entry> </entry>
              <entry>request on the Cray T3E. Utilized only if</entry>
            </row> <row>
              <entry> </entry>
              <entry>process = 3.</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>spectral bands in the input image data.</entry>
            </row> <row>
              <entry>dtype</entry>
              <entry>An int variable containing an indicator of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>data type of the input image data. (dtype ==</entry>
            </row> <row>
              <entry> </entry>
              <entry>4 designates unsigned char and dtype == 16</entry>
            </row> <row>
              <entry> </entry>
              <entry>designates unsigned short).</entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>nearest neighbors considered.</entry>
            </row> <row>
              <entry>normind</entry>
              <entry>An int variable containing an indicator of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>type of normalization requested. (normind ==</entry>
            </row> <row>
              <entry> </entry>
              <entry>1 designates “No Normalization,”</entry>
            </row> <row>
              <entry> </entry>
              <entry>normind == 2 designates “Normalization</entry>
            </row> <row>
              <entry> </entry>
              <entry>Across Bands,” and normind == 3</entry>
            </row> <row>
              <entry> </entry>
              <entry>designates “Normalize Bands Separately”).</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>An int variable indicating the dissimilarity</entry>
            </row> <row>
              <entry> </entry>
              <entry>criterion to be used.</entry>
            </row> <row>
              <entry>extmean</entry>
              <entry>An int variable that is TRUE if the vector</entry>
            </row> <row>
              <entry> </entry>
              <entry>mean is subtracted from the spectral vectors</entry>
            </row> <row>
              <entry> </entry>
              <entry>before the dissimilarity criterion is</entry>
            </row> <row>
              <entry> </entry>
              <entry>calculated, FALSE otherwise.</entry>
            </row> <row>
              <entry>spatial_type</entry>
              <entry>An int variable indicating the spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry>type employed (1 =&gt; “Variance”, and</entry>
            </row> <row>
              <entry> </entry>
              <entry>2 =&gt; “Standard Deviation”).</entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>An int variable containing the total number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>recursive levels to be utilized</entry>
            </row> <row>
              <entry>inb_levels</entry>
              <entry>An int variable containing the recursive level</entry>
            </row> <row>
              <entry> </entry>
              <entry>of the intermediate level</entry>
            </row> <row>
              <entry>fnb_levels</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>recursive levels used in the final stage</entry>
            </row> <row>
              <entry>sub_ncols</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>columns of input data to be processed at the</entry>
            </row> <row>
              <entry> </entry>
              <entry>highest level of recursion</entry>
            </row> <row>
              <entry>sub_nrows</entry>
              <entry>An int variable containing the number of rows</entry>
            </row> <row>
              <entry> </entry>
              <entry>of input data to be processed at the highest</entry>
            </row> <row>
              <entry> </entry>
              <entry>level of recursion</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>An int variable containing the number of regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>for convergence in the recursive stages</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>An int variable containing the number of regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>at which convergence factor checking is initiated.</entry>
            </row> <row>
              <entry>max_nregions</entry>
              <entry>An int variable containing the maximum number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>regions that will be encountered in processing</entry>
            </row> <row>
              <entry> </entry>
              <entry>the data.</entry>
            </row> <row>
              <entry>spatial_wght</entry>
              <entry>A float variable which contains the value of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>weight for the spatial feature (a value of 0.0</entry>
            </row> <row>
              <entry> </entry>
              <entry>indicates the spatial feature is not employed).</entry>
            </row> <row>
              <entry>convfact</entry>
              <entry>A float variable containing the value of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>convergence factor for detecting natural</entry>
            </row> <row>
              <entry> </entry>
              <entry>convergence points.</entry>
            </row> <row>
              <entry>scale</entry>
              <entry>A float array containing the multispectral scale</entry>
            </row> <row>
              <entry> </entry>
              <entry>factor(s) for normalization.</entry>
            </row> <row>
              <entry>offset</entry>
              <entry>A float array containing multispectral offset</entry>
            </row> <row>
              <entry> </entry>
              <entry>factor(s) for normalization.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0104">The program next sets the number of columns (sub_ncols) and number of rows (sub_nrows) of the image data sections to be processed at the highest level of recursion, based on the value of rnb_levels.</p>
  <p num="p-0105">The RHSEG program must perform some preprocessing of the input data prior to calling part (ii) of the RHSEG implementation (on the parallel computer&#39;s host computer). If the input data set is very large, the input data will need to be sectioned for processing. At this point in the program, the RHSEG program checks to see if a large enough buffer can be allocated to handle the input data and other associated data arrays. If not, it recursively decreases the buffer size by a factor of 2 until the allocation can be made. This determines the value of proc_nsecs, the number of sections in which the data is processed in the preprocessing portion of part (i).</p>
  <p num="p-0106">The RHSEG main program next continues into a preprocessing stage in which it computes image statistics. If image normalization is requested, the image sum, sum of squares and minimum values in each band are computed, along with the number of image pixels. If image normalization is not requested, only the number of image pixels is found. If image normalization is requested, the sum_stat, sumsq_stat and min_stat arrays are declared and allocated as follows:</p>
  <p num="p-0107"> <tables id="TABLE-US-00021" num="00021"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="42pt" align="left"> </colspec> <colspec colname="3" colwidth="35pt" align="left"> </colspec> <colspec colname="4" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>sum_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>Sum of the input image</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data in each band</entry> </row> <row> <entry>sumsq_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>Sum of the squares of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>input image data in each</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>band</entry> </row> <row> <entry>min_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>The minimum input</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>image data value in each</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>band</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">          </tbody>  </table> </tables> <br/>
If required, the sum_stat and sumsq_stat arrays are initialized to “0”, and the min_stat array is initialized to “MAXFLOAT” (the maximum floating point value on the system).
</p>
  <p num="p-0108">If proc_nsecs==1, the RHSEG main program continues in the manner described in the section of this document labeled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</p>
  <p num="p-0109">by allocating the input_data, mask_data (if necessary) and rlblmap_data data arrays, calling the function read_data( ) to read the input data into the allocated arrays, and calling the function find_stats( ) to compute the number of image pixels, npixels, and, if normalization is requested, the image statistics sum_stat, sumsq_stat and min_stat.</p>
  <p num="p-0110">If proc_nsecs&gt;1, the RHSEG main program must stage through the data to compute the image statistics. To do so, RHSEG allocates memory for the input_data array and, if necessary, for the mask_data array using proc_nrows (the number of rows in each section processed) instead of nrows for the rows dimension:</p>
  <p num="p-0111"> <tables id="TABLE-US-00022" num="00022"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="49pt" align="left"> </colspec> <colspec colname="3" colwidth="63pt" align="left"> </colspec> <colspec colname="4" colwidth="56pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>unsigned short</entry> <entry>ncols*proc_nrows*</entry> <entry>Input image data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>nbands</entry> </row> <row> <entry>mask_data</entry> <entry>unsigned char</entry> <entry>ncols*proc_nrows</entry> <entry>Input mask data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(if any)</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">      </tbody>  </table> </tables> <br/>
The input data files are opened, the variable npixels is initialized to zero (0), and a loop is entered which is repeated proc_nsecs times. In this loop, proc_nrows of the input data is read, and the function find_stats( ) is called with the following parameters and array variables:
</p>
  <p num="p-0112"> <tables id="TABLE-US-00023" num="00023"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="175pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing proc_nrows of the</entry> </row> <row> <entry> </entry> <entry>input image data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing proc_nrows of the mask</entry> </row> <row> <entry> </entry> <entry>data (if any)</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in the</entry> </row> <row> <entry> </entry> <entry>input image data.</entry> </row> <row> <entry>maxnrow</entry> <entry>An int variable containing the number of rows in this</entry> </row> <row> <entry> </entry> <entry>section of input image data (equal to proc_nrows).</entry> </row> <row> <entry>sum_stat</entry> <entry>A double array containing the sum of the (possibly</entry> </row> <row> <entry> </entry> <entry>masked) input image data in each band for the portion</entry> </row> <row> <entry> </entry> <entry>of data previously processed.</entry> </row> <row> <entry>sumsq_stat</entry> <entry>A double array containing the sum of square of the</entry> </row> <row> <entry> </entry> <entry>(possibly masked) input image data in each band for</entry> </row> <row> <entry> </entry> <entry>the portion of data previously processed.</entry> </row> <row> <entry>min_stat</entry> <entry>A double array containing the minimum value of the</entry> </row> <row> <entry> </entry> <entry>(possibly masked) input image data in each band for</entry> </row> <row> <entry> </entry> <entry>the portion of data previously processed.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                   </tbody>  </table> </tables> <br/>
The global variables mask_flag, nbands and normind are also used as inputs by find_stats( ). The following arrays are output by find_stats( ):
</p>
  <p num="p-0113">
    <tables id="TABLE-US-00024" num="00024">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="42pt" align="left"> </colspec>
          <colspec colname="2" colwidth="175pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>sum_stat</entry>
              <entry>A double array containing the sum of the (possibly masked)</entry>
            </row> <row>
              <entry> </entry>
              <entry>input image data in each band for all portions of data</entry>
            </row> <row>
              <entry> </entry>
              <entry>processed.</entry>
            </row> <row>
              <entry>sumsq_stat</entry>
              <entry>A double array containing the sum of square of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>(possibly masked) input image data in each band for all</entry>
            </row> <row>
              <entry> </entry>
              <entry>portions of data processed.</entry>
            </row> <row>
              <entry>min_stat</entry>
              <entry>A double array containing the minimum value of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>(possibly masked) input image data in each band for all</entry>
            </row> <row>
              <entry> </entry>
              <entry>portions of data processed..</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0114">The number of input pixels in this section of input data is returned as the value of the function find_stats( ), and is added to the current value of npixels. If image normalization is not requested, and no mask data is provided, the find_stats( ) function simply calculates the image number of pixels as ncols*maxrow and returns. If image normalization is not requested, and mask data is provided, the find_stats( ) function finds the image number of pixels by counting the number of non-zero entries in mask_data and returns. If image normalization is requested, the function find_stats( ) scans through the input image data, taking the image masking in account if provided, and accumulates the sum, sum of squares and minimum data values for each band, along with the image number of pixels, and then returns.</p>
  <p num="p-0115">After the program exits the loop over proc_nsecs, the input files are closed.</p>
  <p num="p-0116">The RHSEG main program now proceeds to allocate and compute the scale and offset arrays for image normalization. This is done in the same manner described in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</p>
  <p num="p-0117">Depending on the parallel processor being utilized, the RHSEG main program allocates and initializes a character array, platform. For the HIVE, platform “hive”, for the Cray T3E, platform=“t3e”, and for the IBM Netfinity, platform=“netf”. This platform array is arbitrary, and is used to flag which files need to be copied over to the parallel platform&#39;s host computer.</p>
  <p num="p-0118">If spatial_wght&gt;0.0, the RHSEG main program now proceeds to compute and write to a file (RHSEG0000.spatial.platform, where platform was defined in the previous paragraph) the minimum over a 3×3 window of the maximum over the spectral bands of the spatial feature (variance or standard deviation) calculated over a 3×3 window. The input variable spatial_wght is multiplied by nbands so that the spatial feature will have the same weighting and the spectral features when the initial input value of spatial_wght is 1.0.</p>
  <p num="p-0119">If proc_nsecs=1, the spatial feature data array is computed in the same manner as described in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER,” with a single call to the function compute_sptatial( ). If proc_nsecs&gt;1, the program must stage through the input data in doing this computation, as described in the next few paragraphs.</p>
  <p num="p-0120">In setting up the staged approach of computing and writing the spatial feature file, the input data array, and, if necessary, the mask data array are reallocated. In addition, the spatial feature data array and some temporary arrays are allocated. These arrays end up being allocated as follows:</p>
  <p num="p-0121">
    <tables id="TABLE-US-00025" num="00025">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="42pt" align="left"> </colspec>
          <colspec colname="2" colwidth="35pt" align="left"> </colspec>
          <colspec colname="3" colwidth="63pt" align="left"> </colspec>
          <colspec colname="4" colwidth="77pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_data</entry>
              <entry>unsigned</entry>
              <entry>ncols*</entry>
              <entry>Input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>short</entry>
              <entry>(proc_nrows + 1)*</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>nbands</entry>
            </row> <row>
              <entry>input_sub</entry>
              <entry>unsigned</entry>
              <entry>3*ncols*nbands</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry>short</entry>
              <entry> </entry>
              <entry>buffer 3 lines of input</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>data</entry>
            </row> <row>
              <entry>mask_data</entry>
              <entry>unsigned</entry>
              <entry>ncols*</entry>
              <entry>Input mask data (if any)</entry>
            </row> <row>
              <entry> </entry>
              <entry>char</entry>
              <entry>(proc_nrows + 1)</entry>
            </row> <row>
              <entry>mask_sub</entry>
              <entry>unsigned</entry>
              <entry>3*ncols</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry>char</entry>
              <entry> </entry>
              <entry>buffer 3 lines of mask</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>data (if any)</entry>
            </row> <row>
              <entry>spatial_init</entry>
              <entry>float</entry>
              <entry>ncols*</entry>
              <entry>Spatial feature data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(proc_nrows + 1)</entry>
              <entry>(local image variance</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>or standard deviation)</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0122">The input files, and an output file (RHSEG0000.max) are opened, and the following variables are initialized: init_flg=TRUE, last_flg=FALSE, nelements=ncols*(proc_nrows+1) and marrow=proc_nrows. Then a loop is entered, which is repeated proc_nsecs times. Each time through the loop, nelements of input data are read. The last time through the loop, nelements is readjusted to be ncols*(maxrow-1), and last_flg set equal to TRUE. Other times through the loop (except the first), nelements is readjusted to be ncols*proc_nrows and initflg is set equal to FALSE. Each time through the loop, the maximum over spectral bands of the local spatial feature values over 3×3 pixel areas is now calculated by calling the function compute_sptatial( ) with the following input arrays and parameters:</p>
  <p num="p-0123"> <tables id="TABLE-US-00026" num="00026"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the current section</entry> </row> <row> <entry> </entry> <entry>of input image data.</entry> </row> <row> <entry>input_sub</entry> <entry>An unsigned short array to buffer 3 lines of input</entry> </row> <row> <entry> </entry> <entry>image data.</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the current section</entry> </row> <row> <entry> </entry> <entry>of mask data (if any).</entry> </row> <row> <entry>mask_sub</entry> <entry>An unsigned char array to buffer 3 lines of mask data</entry> </row> <row> <entry> </entry> <entry>(if any).</entry> </row> <row> <entry>init_flg</entry> <entry>An int variable that is TRUE if this is the first section</entry> </row> <row> <entry> </entry> <entry>of data processed, and FALSE otherwise.</entry> </row> <row> <entry>last_flg</entry> <entry>An int variable that is TRUE if this is the last section</entry> </row> <row> <entry> </entry> <entry>of data processed, and FALSE otherwise.</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in the</entry> </row> <row> <entry> </entry> <entry>input image data.</entry> </row> <row> <entry>maxrow</entry> <entry>An int variable containing the number of rows processed</entry> </row> <row> <entry> </entry> <entry>in this section of the input image data.</entry> </row> <row> <entry>num_points</entry> <entry>An int variable containing the size of data element</entry> </row> <row> <entry> </entry> <entry>offset between bands of input image data. Equal to</entry> </row> <row> <entry> </entry> <entry>nelements in this case.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                     </tbody>  </table> </tables> <br/>
The global parameters mask_flag, nbands, scale, and offset are also used as inputs to compute_spatial( ). The following data array is output by compute spatial( ):
</p>
  <p num="p-0124"> <tables id="TABLE-US-00027" num="00027"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the maximum over spectral</entry> </row> <row> <entry> </entry> <entry>bands of the spatial feature calculated over a 3 × 3</entry> </row> <row> <entry> </entry> <entry>window for the current section of data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">     </tbody>  </table> </tables> <br/>
Note that when mask_data is provided, the value of spatial init is set equal to MAXFLOAT (the maximum floating point value) whenever ANY data point in the 3×3 window is masked out. Also, spatial_init is set equal to MAXFLOAT for the first and last data rows and columns. (Internal to the compute_spatial( ) function, the three line buffers, input_sub and mask_sub, if necessary, are maintained such that the middle line of the three line buffers correspond to the line currently being calculated of the spatial_init array.)
</p>
  <p num="p-0125">After each call to compute_sptatial( ), ncols*maxrow elements of the spatial_init are written to the file RHSEG0000.max. After the program exits the loop over proc_nsecs, the input and output files are closed. The input_sub and mask_sub arrays are also freed.</p>
  <p num="p-0126">An additional data array is now allocated:</p>
  <p num="p-0127">
    <tables id="TABLE-US-00028" num="00028">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="42pt" align="left"> </colspec>
          <colspec colname="3" colwidth="35pt" align="left"> </colspec>
          <colspec colname="4" colwidth="77pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>spatial_init_sub</entry>
              <entry>float</entry>
              <entry>3*ncols</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>buffer 3 lines of spatial</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>feature data</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0128">The computation of the spatial feature data array continues with the finding of the minimum over 3×3 pixel areas of the data array computed above by the function compute_spatial( ). If proc_nsecs=1, the spatial feature data array is computed in the same manner as described in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER,” with a single call to the function find_min( ). If proc_nsecs&gt;1, the program must stage through the data in doing this computation, as described in the next few paragraphs.</p>
  <p num="p-0129">The input file (RHSEG000.max), and the output file (RHSEG0000.spatial.platform) are opened, and the following variables are initialized: init_flg=TRUE, last_flg=FALSE, nelements=ncols*(proc_nrows+1) and maxrow=proc_nrows. Then a loop is entered, which is repeated proc_nsecs times. Each time through the loop, nelements of input data are read. The last time through the loop, nelements is readjusted to be ncols*(maxrow-1) and last_flg is set equal to TRUE. Other times through the loop (except the first), nelements is readjusted to be ncols*proc_nrows and init_flg is set equal to FALSE. Each time through the loop, the minimum over 3×3 pixel areas of maximum over spectral bands of the local spatial feature values over 3×3 pixel areas is found by calling the function find_min( ) with the following input arrays and parameters:</p>
  <p num="p-0130"> <tables id="TABLE-US-00029" num="00029"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the maximum over spectral</entry> </row> <row> <entry> </entry> <entry>bands of the spatial feature calculated over a 3 × 3</entry> </row> <row> <entry> </entry> <entry>window for the current section of data.</entry> </row> <row> <entry>spatial_init_sub</entry> <entry>An float array to buffer 3 lines of spatial feature</entry> </row> <row> <entry> </entry> <entry>data.</entry> </row> <row> <entry>init_flg</entry> <entry>An int variable that is TRUE if this is the first</entry> </row> <row> <entry> </entry> <entry>section of data processed, and FALSE otherwise.</entry> </row> <row> <entry>last_flg</entry> <entry>An int variable that is TRUE if this is the last</entry> </row> <row> <entry> </entry> <entry>section of data processed, and FALSE otherwise.</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns</entry> </row> <row> <entry> </entry> <entry>in the input image data.</entry> </row> <row> <entry>maxrow</entry> <entry>An int variable containing the number of rows</entry> </row> <row> <entry> </entry> <entry>processed in this section of the input image data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">               </tbody>  </table> </tables> <br/>
The following data array is output by find_min( ):
</p>
  <p num="p-0131"> <tables id="TABLE-US-00030" num="00030"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="175pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the minimum over a 3 × 3 window</entry> </row> <row> <entry> </entry> <entry>of the maximum over spectral bands of the spatial</entry> </row> <row> <entry> </entry> <entry>feature calculated over a 3 × 3 window for the current</entry> </row> <row> <entry> </entry> <entry>section of data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">      </tbody>  </table> </tables> <br/>
(Internal to the find_min( ) function, the three line buffer, spatial_init_sub is maintained such that the middle line of the three line buffer corresponds to the line currently being calculated of the output spatial_init array.)
</p>
  <p num="p-0132">After each call to the function find_min( ), ncols*maxrow elements of the spatial_init are written to the file RHSEG0000.spatial.platform. After the program exits the loop over proc_nsecs, the input and output files are closed. The spatial_init and spatial_init_sub arrays are also freed.</p>
  <p num="p-0133">The RHSEG main program continues by copying the input data file, inputf, to RHSEG0000.input.platform, and if provided, the mask data file, mask to RHSEG0000.mask.platform, and the input region label map data file, rlblmap_inf, to RHSEG0000.rlblmap.platform. (If the Cray T3E, Netfinity or other parallel machine besides the HIVE is to be utilized, substitute the appropriate string for “hive”.)</p>
  <p num="p-0134">The maximum number of regions, max_nregions, that will be encountered in processing any subsection of data is now computed as equal to the maximum of 4* minregions and sub_ncols*sub_nrows.</p>
  <p num="p-0135">The actual call to the parallel computer system is made through a call to the function call_parallel( ), with ncols and nrows as input parameters. The functional description of call parallel( ) is given in a later section. The global variables log_file, host, tmpdir, tempfile, mask_flag, rlblmap_in_flag, regmerges_flag, spclust_flag, process, nb_pes, cray_time_limit, nbands, dtype, maxmdir, simcrit, extmean, spatial_type, rnb_levels , inb_levels, fnb_levels, sub_ncols, sub_nrows, minregions chkregions, max_nregions, spatial_wght, convfact, scale, and offset are also utilized by the function call_parallel( ).</p>
  <p num="p-0136">After the function call parallel( ) returns, the output parameter file (output from the part (ii) of the program, run on the parallel machine host), RHSEG0000.oparam, is read to determine the number of hierarchical segmentation levels, nslevels, and maximum region label in the finest segmentation, onregions, that were produced on the parallel computing platform by part (ii) of the RHSEG implementation. Besides the log file, RHSEG0000.log, the other files output from part (ii) of the RHSEG implementation are RHSEG0000.npix.il (l=0 to nslevels-1), RHSEG0000.mean.sbb.il (b=0 to nbands-1; l=0 to nslevels-1), and RHSEG0000.critval.il (l=0 to nslevels-1). If regmerges_flag==FALSE, RHSEG0000.rlblmap.il (l=0 to nslevels-1) are also output, and if regmerges_flag==TRUE, RHSEG0000.rlblmap.i0 and RHSEG0000.regmerges.il (l=1 to nslevels-1) are also output. These files are concatenated together appropriately to form the files rlblmap, regmerges, rnpixlist, rmeanlist, and rcvlist, which were described previously.</p>
  <p num="p-0137">Functional description of the call_parallel( ) function: The call_parallel( ) function first determines the number of parallel tasks required based on the value of inb_levels. (Note that this is one less than the total number of tasks as listed in Table 1 of Section 1.C.) The number of parallel tasks, inb_tasks, is related mathematically to inb_levels , by the equation: 
<maths id="MATH-US-00017" num="00017"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mi>i</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>b</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>_</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>t</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>a</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>s</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>k</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>s</mi> </mrow> <mo>=</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>i</mi> <mo>=</mo> <mn>1</mn> </mrow> <mrow> <mi>i</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>b</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>_</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>l</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>v</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>l</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>s</mi> </mrow> </munderover> <mo>⁢</mo> <mrow> <msup> <mn>2</mn> <mrow> <mn>2</mn> <mo>⁢</mo> <mrow> <mo>(</mo> <mrow> <mi>i</mi> <mo>-</mo> <mn>1</mn> </mrow> <mo>)</mo> </mrow> </mrow> </msup> <mo>.</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>12</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
</p>
  <p num="p-0138">For the 200 processor HIVE, inb_levels values of 4 or 5 are most appropriate, resulting in 85 or 341 tasks, respectively. The available processors are somewhat underutilized with 85 tasks, but 341 tasks require some multitasking (up to 2 tasks per processor). However, due to the recursive structure of the implementation, a maximum of 256 tasks out of the 341 are actually performing computations at any particular instance of time for inb_levels=5.</p>
  <p num="p-0139">A parameter file, “RHSEG0000.iparam,” is now generated through which the required parameters are transferred to the parallel program. The required parameters are:</p>
  <p num="p-0140">
    <tables id="TABLE-US-00031" num="00031">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>mask_flag</entry>
              <entry>TRUE if a mask data file exists</entry>
            </row> <row>
              <entry>rlblmap_in_flag</entry>
              <entry>TRUE if an input region label data file exists</entry>
            </row> <row>
              <entry>regmerges_flag</entry>
              <entry>TRUE if an output region merges list file is requested</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>input image number of columns</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>input image number of rows</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>input image number of spectral bands</entry>
            </row> <row>
              <entry>dtype</entry>
              <entry>input image data type</entry>
            </row> <row>
              <entry> </entry>
              <entry>(4 =&gt; “unsigned byte”, 16 =&gt; “unsigned short)</entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>value equals number of nearest neighbors</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>dissimilarity criterion (1 =&gt; “1-norm”, 2 =&gt; “2-</entry>
            </row> <row>
              <entry> </entry>
              <entry>norm”, and 3 =&gt; “Infinity-norm”.)</entry>
            </row> <row>
              <entry>extmean</entry>
              <entry>TRUE if vector mean is to be subtracted</entry>
            </row> <row>
              <entry>spclust_flag</entry>
              <entry>TRUE if spectral clustering is to be performed</entry>
            </row> <row>
              <entry>spatial_wght</entry>
              <entry>weight for spatial feature</entry>
            </row> <row>
              <entry>spatial_type</entry>
              <entry>spatial feature type (1 =&gt; “variance”, and 2 =&gt;</entry>
            </row> <row>
              <entry> </entry>
              <entry>“standard deviation”)</entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>total number of recursive levels</entry>
            </row> <row>
              <entry>inb_levels</entry>
              <entry>recursive level of intermediate level</entry>
            </row> <row>
              <entry>inb_tasks</entry>
              <entry>number of parallel tasks required</entry>
            </row> <row>
              <entry>fnb_levels</entry>
              <entry>number of recursive levels used in the final stage</entry>
            </row> <row>
              <entry>sub_ncols</entry>
              <entry>number of columns of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the highest level of recursion</entry>
            </row> <row>
              <entry>sub_nrows</entry>
              <entry>number of rows of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the highest level of recursion</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>number of regions for convergence in recursive stages</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>number of regions at which convergence factor</entry>
            </row> <row>
              <entry> </entry>
              <entry>checking is initiated</entry>
            </row> <row>
              <entry>convfact</entry>
              <entry>convergence factor</entry>
            </row> <row>
              <entry>scale</entry>
              <entry>multispectral scale factor(s) for normalization</entry>
            </row> <row>
              <entry>offset</entry>
              <entry>multispectral offset factor(s) for normalization</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0141">Also required for the HIVE and NetFinity implementations are the following:</p>
  <p num="p-0142">
    <tables id="TABLE-US-00032" num="00032">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="42pt" align="left"> </colspec>
          <colspec colname="2" colwidth="175pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>host</entry>
              <entry>Hostname of the workstation setting up the parallel call</entry>
            </row> <row>
              <entry>tmpdir</entry>
              <entry>Directory for temporary files on the calling workstation</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0143">The files RHSEG0000.iparam, RHSEG0000.input.platform, RHSEG0000.mask.platform and RHSEG0000.spatial.platform are remotely copied with the UNIX “rcp” command to the parallel computing platform, and a UNIX remote shell call is execute to start the parallel program implementing part (ii) of the RHSEG implementation. After the parallel program completes, the output files are remotely copied from the parallel-computing platform. Besides the log file, RHSEG000.log, and the output parameter file, RHSEG0000.oparam, the other files output from part (ii) of the RHSEG implementation are RHSEG0000.npix.il (l=0 to nslevels-1), RHSEG0000.mean.sbb.il (b=0 to nbands-1; l=0 to nslevels-1), and RHSEG0000.critval.il (l=0 to nslevels-1). If regmerges<sub>13 </sub>flag==FALSE, RHSEG0000.rlblmap.il (l=0 to nslevels-1) are also output and if regmerges flag==TRUE, RHSEG0000.rlblmap.i0 and RHSEG0000.regmerges.il (l=1 to nslevels-1) are also output.</p>
  <p num="p-0144">Description of part (ii) of the RHSEG implementation: As mentioned in previously, part (ii) of the RHSEG implementation is a “master” program that accepts inputs from part (i), and calls many instances of the part (iii) “slave” program, provides the required inputs to the “slave” programs, aggregates the results from the “slave” programs, and sends the results back to part (i).</p>
  <p num="p-0145">The master program first determines the parameter file name from the command line and reads in the program parameters. Then, based on the values of rnb_levels , inb_levels , sub_ncols and sub_nrows, the program determines isub_ncols and isub_nrows, the number of columns and rows at the intermediate level of recursion. The program also similarly determines fsub_ncols and fsub_nrows based on the values of inb_levels, fnb_levels , isub_ncols and isub_nrows.</p>
  <p num="p-0146">Based on the values of ncols and sub_ncols, the master program finds the smallest full image size (pad_ncols and pad_nrows) that is an integer multiple of ncols and nrows. Note that pad_ncols&gt;=ncols and pad_nrows&gt;=nrows.</p>
  <p num="p-0147">The master program then determines the total number of processing sections for the final stage, tot_nb_secs=(ncols/fsub_ncols)<sup>2</sup>, and the task, processing section correspondence array (task-sec) at the final stage recursive level.</p>
  <p num="p-0148">On the HIVE, NetFinity and similar parallel computing platforms, the master program then spawns the required number of tasks (inb_tasks), using the “pvm_spawn” command to spread the tasks across the available slave processors. The task IDs of the spawned tasks are recorded in an array (bee_tid[*]). On the Cray T3E, the “start_pes” command is used to start processes on ibn_tasks+1 processors, and the rest of the master program is run on the last processor. The master program is provided with the task IDs of the slave tasks by the slave tasks explicitly sending their processor number and task IDs to the master program with a “pvm_send” call.</p>
  <p num="p-0149">Special note: For load balancing purposes on the HIVE, the tasks are allocated to PCs as follows: Tasks <b>0</b>-<b>4</b> are allocated to Dell PCs <b>5</b>-<b>9</b>. Tasks <b>5</b>-<b>52</b> are spread evenly across the 16 Gateway PCs. Tasks <b>53</b>-<b>84</b> are spread evenly across the 10 Dell PCs. Tasks <b>85</b> through <b>340</b> are first spread across the Pentium Pro PCs until 2 tasks are allocated to each available Pentium Pro PC. Then the remaining tasks are spread evenly across the Gateway and Dell PCs. This load balancing strategy takes into account that the clock speeds of the Dell and Gateway PCs are twice as fast as the Pentium Pro PCs, and that the Pentium Pro PCs and Gateway PCs have two processors per PC and the Dell PCs have four processors per PCs. The load balancing strategy should be modified accordingly for different heterogeneous Beowulf-type clusters. Such tailored load balancing strategies are not necessary on homogeneous clusters such as the Cray T3E and NetFinity.</p>
  <p num="p-0150">The master program then multicasts the common parameters to all slave tasks with the pvm_mcast routine. The common parameters are:</p>
  <p num="p-0151">
    <tables id="TABLE-US-00033" num="00033">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>mask_flag</entry>
              <entry>TRUE if a mask file exists or if padding is required</entry>
            </row> <row>
              <entry>rlblmap_in_flag</entry>
              <entry>TRUE if an input region label map is provided</entry>
            </row> <row>
              <entry>regmerges_flag</entry>
              <entry>TRUE if an output region merge list file is requested</entry>
            </row> <row>
              <entry>spatial_wght</entry>
              <entry>weight for spatial feature</entry>
            </row> <row>
              <entry>spatial_type</entry>
              <entry>spatial feature type (1 =&gt; “variance”, and 2 =&gt;</entry>
            </row> <row>
              <entry> </entry>
              <entry>“standard deviation”)</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>input image number of spectral bands</entry>
            </row> <row>
              <entry>sub_ncols</entry>
              <entry>number of columns of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the highest level of recursion</entry>
            </row> <row>
              <entry>sub_nrows</entry>
              <entry>number of rows of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the highest level of recursion</entry>
            </row> <row>
              <entry>isub_ncols</entry>
              <entry>number of columns of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the intermediate level</entry>
            </row> <row>
              <entry>isub_nrows</entry>
              <entry>number of rows of image data section processed at</entry>
            </row> <row>
              <entry> </entry>
              <entry>the intermediate level</entry>
            </row> <row>
              <entry>fsub_ncols</entry>
              <entry>number of columns of image data section processed</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the final stage</entry>
            </row> <row>
              <entry>fsub_nrows</entry>
              <entry>number of rows of image data section processed</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the final stage</entry>
            </row> <row>
              <entry>scale</entry>
              <entry>multispectral scale factor(s) for normalization</entry>
            </row> <row>
              <entry>offset</entry>
              <entry>multispectral offset factor(s) for normalization</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>dissimilarity criterion (1 =&gt; “1-norm”, 2 =&gt; “2-</entry>
            </row> <row>
              <entry> </entry>
              <entry>norm”, and 3 =&gt; “Infinity-norm”.)</entry>
            </row> <row>
              <entry>extmean</entry>
              <entry>TRUE if vector mean is to be subtracted</entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>value equals number of nearest neighbors</entry>
            </row> <row>
              <entry>spclust_flag</entry>
              <entry>TRUE if spectral clustering is to be performed</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>number of regions for convergence in recursive stages</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>number of regions at which convergence factor</entry>
            </row> <row>
              <entry> </entry>
              <entry>checking is initiated</entry>
            </row> <row>
              <entry>fnb_levels</entry>
              <entry>number of recursive levels used in the final stage</entry>
            </row> <row>
              <entry>inb_levels</entry>
              <entry>recursive level of intermediate level</entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>total number of recursive levels</entry>
            </row> <row>
              <entry>ntasks</entry>
              <entry>number of parallel tasks required (equal to inb_tasks)</entry>
            </row> <row>
              <entry>slave_tid</entry>
              <entry>task IDs of all slave tasks</entry>
            </row> <row>
              <entry>tot_nb_secs</entry>
              <entry>number of data sections employed in final stage</entry>
            </row> <row>
              <entry>task_sec</entry>
              <entry>task-section correspondence in final stage</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0152">The master program then initiates the recursive stage of the program by sending task specific parameters to the 0<sup>th </sup>slave task. These task specific parameters are:</p>
  <p num="p-0153">
    <tables id="TABLE-US-00034" num="00034">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>runtype</entry>
              <entry>slave task run type (equal to “1” in this case)</entry>
            </row> <row>
              <entry> </entry>
              <entry>first_sec</entry>
              <entry>first section to be processed by slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(equal to 0 in this case)</entry>
            </row> <row>
              <entry> </entry>
              <entry>last_sec</entry>
              <entry>last section to be processed by slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(equal to nb_secs-1 in this case. If ratio =</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>ncols/isub_ncols, nb_secs = ratio*ratio)</entry>
            </row> <row>
              <entry> </entry>
              <entry>calling_tid</entry>
              <entry>current task ID (master task ID in this case)</entry>
            </row> <row>
              <entry> </entry>
              <entry>level</entry>
              <entry>current level of recursion + 1 (equal to “1” in this</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>case)</entry>
            </row> <row>
              <entry> </entry>
              <entry>ncols</entry>
              <entry>number of columns in current section of data</entry>
            </row> <row>
              <entry> </entry>
              <entry>nrows</entry>
              <entry>number of rows in current section of data</entry>
            </row> <row>
              <entry> </entry>
              <entry>convfact</entry>
              <entry>convergence factor</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0154">The master program then waits for branch task ID requests from tasks at recursive levels <b>1</b> through inb_levels-1. Tasks at these levels make 4 separate recursive calls to 4 separate tasks, for which the master program must provide task IDs.</p>
  <p num="p-0155">After all branch task ID requests are made and satisfied, the master program waits for input data requests from the tasks at recursive level inb_level. When a slave program sends an input data request to the master program, it sends its own task ID (request_tid) and the section number (sec) it is requesting data for. The sections are numbered in a recursive manner as illustrated in Table I.</p>
  <p num="p-0156">The offset locations for each section in the recursive order numbering scheme can be found in the following manner. On the PCs of the HIVE or Netfinity, declare the following structure and union:</p>
  <p num="p-0157">
    <tables id="TABLE-US-00035" num="00035">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="21pt" align="left"> </colspec>
          <colspec colname="1" colwidth="91pt" align="left"> </colspec>
          <colspec colname="2" colwidth="105pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>typedef struct</entry>
              <entry> </entry>
            </row> <row>
              <entry> </entry>
              <entry>{</entry>
              <entry>typedef union</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b00:1;</entry>
              <entry>{</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b01:1;</entry>
              <entry> unsigned short sec;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b02:1;</entry>
              <entry> ushort_bit_field bits;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b03:1;</entry>
              <entry>} gb_union;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b04:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b05:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b06:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b07:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b08:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b09:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b10:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b11:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b12:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b13:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b14:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry> unsigned b15:1;</entry>
            </row> <row>
              <entry> </entry>
              <entry>} ushort_bit_field;</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0158">
    <tables id="TABLE-US-00036" num="00036">
      <tgroup align="left" colsep="0" rowsep="0" cols="1">
          <colspec colname="1" colwidth="217pt" align="center"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="1" rowsep="1">TABLE I</entry>
            </row> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Numbering of sections in recursive order</entry>
            </row> <row>
              <entry>sequence for inb_levels = 4. Each section is of size</entry>
            </row> <row>
              <entry>inb_cols × fbn_rows.</entry>
            </row> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="9">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="14pt" align="char" char="."> </colspec>
          <colspec colname="2" colwidth="35pt" align="char" char="."> </colspec>
          <colspec colname="3" colwidth="21pt" align="char" char="."> </colspec>
          <colspec colname="4" colwidth="35pt" align="char" char="."> </colspec>
          <colspec colname="5" colwidth="21pt" align="center"> </colspec>
          <colspec colname="6" colwidth="28pt" align="center"> </colspec>
          <colspec colname="7" colwidth="21pt" align="center"> </colspec>
          <colspec colname="8" colwidth="28pt" align="center"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>4</entry>
              <entry>5</entry>
              <entry>16</entry>
              <entry>17</entry>
              <entry>20</entry>
              <entry>21</entry>
            </row> <row>
              <entry> </entry>
              <entry>2</entry>
              <entry>3</entry>
              <entry>6</entry>
              <entry>7</entry>
              <entry>18</entry>
              <entry>19</entry>
              <entry>22</entry>
              <entry>23</entry>
            </row> <row>
              <entry> </entry>
              <entry>8</entry>
              <entry>9</entry>
              <entry>12</entry>
              <entry>13</entry>
              <entry>24</entry>
              <entry>25</entry>
              <entry>28</entry>
              <entry>29</entry>
            </row> <row>
              <entry> </entry>
              <entry>10</entry>
              <entry>11</entry>
              <entry>14</entry>
              <entry>15</entry>
              <entry>26</entry>
              <entry>27</entry>
              <entry>30</entry>
              <entry>31</entry>
            </row> <row>
              <entry> </entry>
              <entry>32</entry>
              <entry>33</entry>
              <entry>36</entry>
              <entry>37</entry>
              <entry>48</entry>
              <entry>49</entry>
              <entry>52</entry>
              <entry>53</entry>
            </row> <row>
              <entry> </entry>
              <entry>34</entry>
              <entry>35</entry>
              <entry>38</entry>
              <entry>39</entry>
              <entry>50</entry>
              <entry>51</entry>
              <entry>54</entry>
              <entry>55</entry>
            </row> <row>
              <entry> </entry>
              <entry>40</entry>
              <entry>41</entry>
              <entry>44</entry>
              <entry>45</entry>
              <entry>56</entry>
              <entry>57</entry>
              <entry>60</entry>
              <entry>61</entry>
            </row> <row>
              <entry> </entry>
              <entry>42</entry>
              <entry>43</entry>
              <entry>46</entry>
              <entry>47</entry>
              <entry>58</entry>
              <entry>59</entry>
              <entry>62</entry>
              <entry>63</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="8" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
            
            
            
          </thead>
          <tbody valign="top">
            
          </tbody>
        
        <tbody valign="top">
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0159">On the Cray T3E, the above declarations are made differently as follows:</p>
  <p num="p-0160"> <tables id="TABLE-US-00037" num="00037"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="91pt" align="left"> </colspec> <colspec colname="2" colwidth="105pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>typedef struct</entry> <entry>typedef union</entry> </row> <row> <entry> </entry> <entry>{</entry> <entry>{</entry> </row> <row> <entry> </entry> <entry> unsigned b31:1;</entry> <entry> unsigned short sec;</entry> </row> <row> <entry> </entry> <entry> unsigned b30:1;</entry> <entry> ushort_bit_field bits;</entry> </row> <row> <entry> </entry> <entry> unsigned b29:1;</entry> <entry>} gb_union;</entry> </row> <row> <entry> </entry> <entry> unsigned b28:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b27:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b26:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b25:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b24:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b23:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b22:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b21:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b20:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b19:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b18:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b17:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b16:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b15:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b14:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b13:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b12:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b11:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b10:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b09:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b08:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b07:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b06:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b05:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b04:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b03:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b02:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b01:1;</entry> </row> <row> <entry> </entry> <entry> unsigned b00:1;</entry> </row> <row> <entry> </entry> <entry>} ushort_bit_field;</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                     </tbody>  </table> </tables> <br/>
In the master program the following variable declarations are made:
</p> <ul> <li id="ul0010-0001" num="0000"> <ul> <li id="ul0011-0001" num="0188">int recur_sec, sub_coff, sub_roff, c_sec, r_sec;</li> <li id="ul0011-0002" num="0189">gb_union getbits;
<br/>
The offsets for the recursive order section numbering (recur_sec) are then found as follows:
</li> </ul> </li> </ul>
  <p num="p-0161">
    <tables id="TABLE-US-00038" num="00038">
      <tgroup align="left" colsep="0" rowsep="0" cols="1">
          <colspec colname="1" colwidth="217pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>getbits.sec = recur_sec;</entry>
            </row> <row>
              <entry>c_sec = getbits.bits.b00 + 2*getbits.bits.b02 + 4*getbits.bits.b04 +</entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="203pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry>8*getbits.bits.b06 + 16*getbits.bits.b08 + 32*getbits.bits.b10 +</entry>
            </row> <row>
              <entry> </entry>
              <entry>64*getbits.bits.b12 + 128*getbits.bits.b14;</entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="1">
          <colspec colname="1" colwidth="217pt" align="left"> </colspec>
          </tgroup> <row>
              <entry>r_sec = getbits.bits.b01 + 2*getbits.bits.b03 + 4*getbits.bits.b05 +</entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="203pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry>8*getbits.bits.b07 + 16*getbits.bits.b09 + 32*getbits.bits.b11 +</entry>
            </row> <row>
              <entry> </entry>
              <entry>64*getbits.bits.b13 + 128*getbits.bits.b15;</entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="1">
          <colspec colname="1" colwidth="217pt" align="left"> </colspec>
          </tgroup> <row>
              <entry>sub_coff = c_sec*isub_ncols;</entry>
            </row> <row>
              <entry>sub_roff = r_sec*isub_ncols;</entry>
            </row> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
          </tbody>
        
        <tbody valign="top">
            
            
          </tbody>
        
        <tbody valign="top">
            
          </tbody>
        
        <tbody valign="top">
            
            
          </tbody>
        
        <tbody valign="top">
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0162">If pad_ncols!=ncols or pad_nrows!=nrows, the input data and, if present, the mask data and spatial feature data are padded as necessary with zero (“0”) values just before being sent to the requesting slave task.</p>
  <p num="p-0163">After all the input data requests are received and satisfied for the input image data (and mask data and/or spatial feature data), the master program determines the correspondence between the recursive order number scheme (Table I, using fnb_levels rather than inb_levels) and the raster order numbering scheme (Table II) for use in proper outputting of the region label maps that will be generated.</p>
  <p num="p-0164">In the master program the following variable declarations are made:
</p> <ul> <li id="ul0012-0001" num="0000"> <ul> <li id="ul0013-0001" num="0194">int ratio, tot_nb_secs, sec, c_sec, r_sec, recur_sec, *raster_sec; gb_union getbits;
<br/>
The recursive section numbering order (recur_sec) and the raster section numbering order (raster_sec) are then associated as follows:
</li> </ul> </li> </ul>

  <p num="p-0165"> <tables id="TABLE-US-00039" num="00039"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>ratio = pad_ncols/fsub_ncols;</entry> </row> <row> <entry> </entry> <entry>tot_nb_secs = ratio*ratio;</entry> </row> <row> <entry> </entry> <entry>sec_inv = (int *) malloc((size_t)(tot_nb_secs*sizeof(int)));</entry> </row> <row> <entry> </entry> <entry>for (sec = 0; sec &lt; tot_nb_secs; sec++)</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="1"> <colspec colname="1" colwidth="217pt" align="left"> </colspec> </tgroup> <row> <entry>{</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry> getbits.sec = recur_sec;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry> c_sec = getbits.bits.b00 + 2*getbits.bits.b02 + 4*getbits.bits.b04 +</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>8*getbits.bits.b06 + 16*getbits.bits.b08 + 32*getbits.bits.b10 +</entry> </row> <row> <entry> </entry> <entry>64*getbits.bits.b12 + 128*getbits.bits.b14;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry> r_sec = getbits.bits.b01 + 2*getbits.bits.b03 + 4*getbits.bits.b05 +</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>8*getbits.bits.b07 + 16*getbits.bits.b09 + 32*getbits.bits.b11 +</entry> </row> <row> <entry> </entry> <entry>64*getbits.bits.b13 + 128*getbits.bits.b15;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry> raster_sec = r_sec*ratio + c_sec;</entry> </row> <row> <entry> </entry> <entry> sec_inv[raster_sec] = recur_sec;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="1"> <colspec colname="1" colwidth="217pt" align="left"> </colspec> </tgroup> <row> <entry>}</entry> </row> <row> <entry namest="1" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">     </tbody>  <tbody valign="top">  </tbody>  <tbody valign="top">  </tbody>  <tbody valign="top">  </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">  </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The raster_sec-recur_sec association is stored for later use in the sec_inv array.
</p>
  <p num="p-0166">
    <tables id="TABLE-US-00040" num="00040">
      <tgroup align="left" colsep="0" rowsep="0" cols="1">
          <colspec colname="1" colwidth="217pt" align="center"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="1" rowsep="1">TABLE II</entry>
            </row> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Numbering of sections in raster order</entry>
            </row> <row>
              <entry>sequence for fnb_levels = 4. Each section is of size</entry>
            </row> <row>
              <entry>fnb_cols × fnb_rows.</entry>
            </row> <row>
              <entry namest="1" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="9">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="14pt" align="char" char="."> </colspec>
          <colspec colname="2" colwidth="35pt" align="char" char="."> </colspec>
          <colspec colname="3" colwidth="21pt" align="char" char="."> </colspec>
          <colspec colname="4" colwidth="35pt" align="char" char="."> </colspec>
          <colspec colname="5" colwidth="21pt" align="char" char="."> </colspec>
          <colspec colname="6" colwidth="28pt" align="char" char="."> </colspec>
          <colspec colname="7" colwidth="21pt" align="char" char="."> </colspec>
          <colspec colname="8" colwidth="28pt" align="char" char="."> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry>0</entry>
              <entry>1</entry>
              <entry>2</entry>
              <entry>3</entry>
              <entry>4</entry>
              <entry>5</entry>
              <entry>6</entry>
              <entry>7</entry>
            </row> <row>
              <entry> </entry>
              <entry>8</entry>
              <entry>9</entry>
              <entry>10</entry>
              <entry>11</entry>
              <entry>12</entry>
              <entry>13</entry>
              <entry>14</entry>
              <entry>15</entry>
            </row> <row>
              <entry> </entry>
              <entry>16</entry>
              <entry>17</entry>
              <entry>18</entry>
              <entry>19</entry>
              <entry>20</entry>
              <entry>21</entry>
              <entry>22</entry>
              <entry>23</entry>
            </row> <row>
              <entry> </entry>
              <entry>24</entry>
              <entry>25</entry>
              <entry>26</entry>
              <entry>27</entry>
              <entry>28</entry>
              <entry>29</entry>
              <entry>30</entry>
              <entry>31</entry>
            </row> <row>
              <entry> </entry>
              <entry>32</entry>
              <entry>33</entry>
              <entry>34</entry>
              <entry>35</entry>
              <entry>36</entry>
              <entry>37</entry>
              <entry>38</entry>
              <entry>39</entry>
            </row> <row>
              <entry> </entry>
              <entry>40</entry>
              <entry>41</entry>
              <entry>42</entry>
              <entry>43</entry>
              <entry>44</entry>
              <entry>45</entry>
              <entry>46</entry>
              <entry>47</entry>
            </row> <row>
              <entry> </entry>
              <entry>48</entry>
              <entry>49</entry>
              <entry>50</entry>
              <entry>51</entry>
              <entry>52</entry>
              <entry>53</entry>
              <entry>54</entry>
              <entry>55</entry>
            </row> <row>
              <entry> </entry>
              <entry>56</entry>
              <entry>57</entry>
              <entry>58</entry>
              <entry>59</entry>
              <entry>60</entry>
              <entry>61</entry>
              <entry>62</entry>
              <entry>63</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="8" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
            
            
            
          </thead>
          <tbody valign="top">
            
          </tbody>
        
        <tbody valign="top">
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0167">The master program now waits for the recursive processing to complete, and the final stage processing to initiate on the 0<sup>th </sup>slave task. When the 0<sup>th </sup>slave task finishes the calculation of the initial global criterion value, this value is reported back to the master program, where this value is output to the log file.</p>
  <p num="p-0168">When the 0<sup>th </sup>slave task detects a cvratio&gt;convfact, it sends the cvratio, the number of regions and the region number of pixels, region means and region criterion values to the master program. The master program, prints the cvratio, the number of regions and hierarchical segmentation level, l, to the log file RHSEG0000.log. Then program then performs byte-swapping on the region number of pixels and writes the result to the file RHSEG0000.npix.il, performs byte-swapping on the regions means and writes the result to the files RHSEG0000.mean.sbb.il (b=0 to nbands-1), and performs byte-swapping on the region criterion values and writes the result to the file RHSEG0000.critval.il. It then requests the region label map section by section in raster section order (based on the recursive section—raster section numbering correspondence stored in the sec_inv array) from the tasks at the recursive level fnb_levels (using the task-section correspondence stored in the task_sec array). If regmerges_flag==FALSE or l==0, the region label map data is byte-swapped and written in raster section order to the file RHSEG0000.rlblmap.il. If regmerges_flag ==TRUE and l!=0, the region merges list data is byte-swapped and written to the file RHSEG0000.regmerges.il.</p>
  <p num="p-0169">Description of part (iii) of the RHSEG implementation: As mentioned previously, part (iii) of the RHSEG implementation is a set of identical “slave” programs that request and accept inputs from the part (ii) “master” program, performs the hybrid region and growing and spectral clustering algorithm on a particular section of data, and returns results back to the “master” program. Most of these “slave” programs also send and receive inputs from other “slave” programs.</p>
  <p num="p-0170">On the HIVE, NetFinity and similar parallel computing platforms, the slave program can determine the task ID of the master program through using the “pvm_parent” command. However, this is not the case on the Cray T3E. Instead the master program must broadcast its task ID to all the other tasks. Upon receiving this broadcast, each slave program (or task) sends back to the master program its own task ID.</p>
  <p num="p-0171">Once each slave task has the task ID of the master program task, it waits for the multicast of the common parameters from the master task. These common parameters are listed above in the description of part (ii) of the RHSEG implementation. Upon receiving the common parameters each task determines its own task number by finding the index of the slave_tid array whose task ID number (tid) matches its own process ID. Once the common parameters are received, each slave task then waits for task specific parameters for its particular processing task. Only one slave task (task <b>0</b>) receives its task specific parameters from the master task. All other slave tasks receive their task specific parameters from another slave task. These task specific parameters were listed under the description of part (ii) of the RHSEG implementation.</p>
  <p num="p-0172">Upon receiving its task specific parameters, each slave task determines the maximum number of regions the task must handle at any particular time, max_nregions. In most cases, max_nregions=4*minregions. However, if sub_ncols*sub_nrows&gt;4*minregions, then max_nregions=sub_ncols*sub_nrows.</p>
  <p num="p-0173">Each slave task now allocates data arrays as necessary, depending the recursive level, level, it is running at. For level&gt;=fnb_levels, the following data arrays are allocated to hold the input and output data:</p>
  <p num="p-0174"> <tables id="TABLE-US-00041" num="00041"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="35pt" align="left"> </colspec> <colspec colname="3" colwidth="49pt" align="left"> </colspec> <colspec colname="4" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>unsigned</entry> <entry>ncols*nrows*</entry> <entry>Input image data</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry>nbands</entry> </row> <row> <entry>mask_data</entry> <entry>unsigned</entry> <entry>ncols*nrows</entry> <entry>Input mask data (if any)</entry> </row> <row> <entry> </entry> <entry>char</entry> </row> <row> <entry>spatial_init</entry> <entry>float</entry> <entry>ncols*nrows</entry> <entry>Spatial feature data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(local image variance or</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>standard deviation, if any)</entry> </row> <row> <entry>rlblmap_data</entry> <entry>unsigned</entry> <entry>ncols*nrows</entry> <entry>Input region label map</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>data (if any) and output</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region label map data</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">            </tbody>  </table> </tables> <br/>
Note that ncols and nrows are the number of columns and rows in the section of data being processed by the given task, NOT the total number of columns and rows in the complete data set. The above data arrays are used in runs of runtype=1, 2 and 7. The rlblmap_data data array is also used in runs of runtype=4, 8 and 10.
</p>
  <p num="p-0175">For level=fnb_levels, the following data arrays are allocated:</p>
  <p num="p-0176"> <tables id="TABLE-US-00042" num="00042"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="35pt" align="left"> </colspec> <colspec colname="3" colwidth="56pt" align="left"> </colspec> <colspec colname="4" colwidth="63pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>Data</entry> <entry> </entry> <entry> </entry> </row> <row> <entry>Data Array</entry> <entry>Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>region_sum</entry> <entry>double</entry> <entry>nbands</entry> <entry>Region sum values</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>for a particular</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region</entry> </row> <row> <entry>cmp_region_sum</entry> <entry>double</entry> <entry>nbands</entry> <entry>Region sum values</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>for a the region</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>being compared to</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region with values</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>in region_sum</entry> </row> <row> <entry>rlblmap_prev</entry> <entry>unsigned</entry> <entry>ncols*nrows</entry> <entry>Region label map</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>values from</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>previous iteration</entry> </row> <row> <entry>rlabel_tmp</entry> <entry>unsigned</entry> <entry>max_nregions</entry> <entry>Region label</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>values (temporary)</entry> </row> <row> <entry>npix_tmp</entry> <entry>unsigned</entry> <entry>max_nregions</entry> <entry>Region number of</entry> </row> <row> <entry> </entry> <entry>int</entry> <entry> </entry> <entry>pixels (temporary)</entry> </row> <row> <entry>sum_tmp</entry> <entry>double</entry> <entry>max_nregions*</entry> <entry>Region sum of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>nbands</entry> <entry>normalized input</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data values in each</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>band (temporary)</entry> </row> <row> <entry>spatial_tmp</entry> <entry>double</entry> <entry>max_nregions</entry> <entry>Region spatial data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>value (temporary)</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(only if</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>spatial_wght &gt; 0.0)</entry> </row> <row> <entry>cv_data</entry> <entry>float</entry> <entry>max_nregions</entry> <entry>Convergence</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>criterion values</entry> </row> <row> <entry>cv_tmp</entry> <entry>float</entry> <entry>max_nregions</entry> <entry>Convergence</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>criterion values</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(temporary)</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>     </thead> <tbody valign="top">                              </tbody>  </table> </tables> <br/>
The above data arrays, except for rlblmap_prev, are only required when a task is performing a run of runtype=7. The data array rlblmap_prev is required when a task is performing runs of runtype=6, 8 or 9.
</p>
  <p num="p-0177">For level&lt;=fnb_levels, the following data arrays are allocated:</p>
  <p num="p-0178"> <tables id="TABLE-US-00043" num="00043"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="42pt" align="left"> </colspec> <colspec colname="3" colwidth="35pt" align="left"> </colspec> <colspec colname="4" colwidth="84pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>first_col</entry> <entry>unsigned</entry> <entry>nrows</entry> <entry>First column of region</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>label values</entry> </row> <row> <entry>last_col</entry> <entry>unsigned</entry> <entry>nrows</entry> <entry>Last column of region</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>label values</entry> </row> <row> <entry>first_row</entry> <entry>unsigned</entry> <entry>ncols</entry> <entry>First row of region label</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>values</entry> </row> <row> <entry>last_row</entry> <entry>unsigned</entry> <entry>ncols</entry> <entry>Last row of region label</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>values</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">          </tbody>  </table> </tables> <br/>
The above data arrays are required when a task is performing runs of runtype=1, 2 and 4.
</p>
  <p num="p-0179">The data arrays npix_data and sum_data are allocated for all recursion levels. If spatial_wght&gt;0.0, the data arrays sumsq_data and spatial_data are also allocated for all recursion levels. However, for level&lt;rnb_levels AND level==inb_levels, these data arrays are allocated in a special manner, along with an additional data array, nghbr_sub:</p>
  <p num="p-0180">
    <tables id="TABLE-US-00044" num="00044">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="35pt" align="left"> </colspec>
          <colspec colname="3" colwidth="56pt" align="left"> </colspec>
          <colspec colname="4" colwidth="77pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>npix_data</entry>
              <entry>unsigned</entry>
              <entry>factor*</entry>
              <entry>Region number of pixels</entry>
            </row> <row>
              <entry> </entry>
              <entry>int</entry>
              <entry>max_nregions</entry>
            </row> <row>
              <entry>sum_data</entry>
              <entry>double</entry>
              <entry>factor*</entry>
              <entry>Region sum of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>max_nregions*</entry>
              <entry>normalized</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>nbands</entry>
              <entry>input data values in</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>each spectral band</entry>
            </row> <row>
              <entry>sumsq_data</entry>
              <entry>double</entry>
              <entry>factor*</entry>
              <entry>Region sum of the</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>max_nregions*</entry>
              <entry>square of the</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>nbands</entry>
              <entry>normalized input data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>values in each band</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>(if spatial_wght &gt; 0.0)</entry>
            </row> <row>
              <entry>spatial_data</entry>
              <entry>double</entry>
              <entry>factor*</entry>
              <entry>Region spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>max_nregions</entry>
              <entry>value (if spatial_wght &gt;</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>0.0)</entry>
            </row> <row>
              <entry>nghbr_sub</entry>
              <entry>unsigned</entry>
              <entry>(factor-1)*</entry>
              <entry>Subset of region</entry>
            </row> <row>
              <entry> </entry>
              <entry>char</entry>
              <entry>max_nregions<sup>2</sup> </entry>
              <entry>adjacency mask</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry namest="1" nameend="4" align="left">where factor = (rnb_levels − inb_levels + 1). </entry>
            </row> <row>
              <entry namest="1" nameend="4" align="left">For all other recursive levels, nghbr_sub is not allocated and the other data arrays (npix_data, sum_data, sumsq_data and spatial_data are declared with factor = 1. The nghbr_sub data array is required only for tasks performing runs of runtype = 1 and 2. The other data arrays are required when a task is performing runs of runtype = 1, 2 and 7. </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0181">For level&lt;rnb_levels AND level&gt;=fnb_levels, the following data arrays are allocated:</p>
  <p num="p-0182">
    <tables id="TABLE-US-00045" num="00045">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="49pt" align="left"> </colspec>
          <colspec colname="3" colwidth="63pt" align="left"> </colspec>
          <colspec colname="4" colwidth="49pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_sub</entry>
              <entry>unsigned short</entry>
              <entry>ncols*nrows*</entry>
              <entry>Subset of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>input image</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>nbands/factor</entry>
              <entry>data</entry>
            </row> <row>
              <entry>mask_sub</entry>
              <entry>unsigned char</entry>
              <entry>ncols*nrows/factor</entry>
              <entry>Subset of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>input</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>mask data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>(if any)</entry>
            </row> <row>
              <entry>spatial_init_sub</entry>
              <entry>float</entry>
              <entry>ncols*nrows/factor</entry>
              <entry>Subset of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>spatial</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>feature data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>(if</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>spatial_wght &gt;</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>0.0)</entry>
            </row> <row>
              <entry>rlblmap_sub</entry>
              <entry>unsigned short</entry>
              <entry>ncols*nrows/factor</entry>
              <entry>Subset of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>region</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>label map</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>data</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry namest="1" nameend="4" align="left">where factor = 2 if level == inb_levels and factor = 4 otherwise. These data arrays are required only when a task is performing runs of runtype = 1 and 2. </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0183">The following data arrays are allocated, as follows, for all levels of recursion:</p>
  <p num="p-0184">
    <tables id="TABLE-US-00046" num="00046">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="49pt" align="left"> </colspec>
          <colspec colname="3" colwidth="63pt" align="left"> </colspec>
          <colspec colname="4" colwidth="56pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>rlabel_data</entry>
              <entry>unsigned short</entry>
              <entry>max_nregions</entry>
              <entry>Region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>values</entry>
            </row> <row>
              <entry>relabel_list</entry>
              <entry>unsigned short</entry>
              <entry>2*max_nregions</entry>
              <entry>Region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>relabelings</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>(renumberings)</entry>
            </row> <row>
              <entry>nghbr_mask</entry>
              <entry>unsigned char</entry>
              <entry>max_nregions<sup>2</sup> </entry>
              <entry>Region adjacency</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>mask</entry>
            </row> <row>
              <entry>nghbr_tmp</entry>
              <entry>unsigned char</entry>
              <entry>max_nregions</entry>
              <entry>Temporary region</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>adjacency mask</entry>
            </row> <row>
              <entry>rlblmap_4cols</entry>
              <entry>unsigned short</entry>
              <entry>4*nrows</entry>
              <entry>Selected four</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>columns of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>map data</entry>
            </row> <row>
              <entry>rlblmap_4rows</entry>
              <entry>unsigned short</entry>
              <entry>4*ncols</entry>
              <entry>Selected four</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>rows of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>map data</entry>
            </row> <row>
              <entry>region_store</entry>
              <entry>reg_struct</entry>
              <entry>max_nregions</entry>
              <entry>Structure</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>containing</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>information about</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>each region</entry>
            </row> <row>
              <entry>region_list</entry>
              <entry>reg_list</entry>
              <entry>max_nregions + 1</entry>
              <entry>Structure for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>linking</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>region_store</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>structures</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>together</entry>
            </row> <row>
              <entry>sort_store</entry>
              <entry>reg_list</entry>
              <entry>max_nregions</entry>
              <entry>Structure for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>ordered linking</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>of region_store</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>structures</entry>
            </row> <row>
              <entry>nbsort_store</entry>
              <entry>reg_list</entry>
              <entry>max_nregions</entry>
              <entry>Structure for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>ordered linking</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>of region_store</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>structures</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0185">All of the above data arrays are required when a task is performing runs of runtype=1 and 2. In addition, the relabel_list data array is required when a task is performing runs of runtype=6 and 7, and the rlblmap_<b>4</b>cols and rlblmap_<b>4</b>rows data arrays are required when a task is performing runs of runtype=4.</p>
  <p num="p-0186">The reg_struct (REGION) and reg_list (R_LIST) structures are defined in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.” This related disclosure also details how the region_list structure array is initialized (by pointing to sequential elements of the region_store structure array).</p>
  <p num="p-0187">From this point on, slave tasks running with different values of runtype perform different tasks. Slave tasks of runtype==1 or runtype==2 perform recursive hierarchical image segmentation on the portion of data input to the task, down to minregions number of regions. The main difference between these two runtypes is that runtype==1 also performs the final stage hierarchical image segmentation with convergence checking down to cvnbregs (usually 2 regions). The other difference is the a slave task of runtype==1 returns to the master task (part (ii) of the RHSEG implementation) and a slave task of runtype==2 returns to another slave task.</p>
  <p num="p-0188">Slave tasks of runtype==4 pass back to the calling slave task the first and last rows and columns of the region label map from its section of data. This is needed to update the nghbr_mask for the newly adjoined sections of data when four sections of data are joined together for processing at the next lower level of recursion.</p>
  <p num="p-0189">Slave tasks of runtype=6, 7, 8, 9 and 10 only get activated for tasks running at a recursive level equal to fnb_levels. Slave tasks of runtype==6 update the section of region label map stored by the task, based on a list of merges performed, relabel_list, that is sent from the calling task. Slave tasks of runtype==7 compute the contribution to the convergence criterion from the section of data held by the task, based on updated region information provided by the calling task (always slave task <b>0</b>). Slave tasks of runtype=8 store the current values of the section of the region label map array, rlblmap_data, which is stored by the task, to the “previous” region label map array, rlblmap_prev (always called from slave task <b>0</b>). Slave tasks of runtype=9 copy their section of rlblmap_prev array data to the calling task (always the master task), while slave tasks of runtype=10 copy their section of rlblmap_data array data to the calling task (always the master task).</p>
  <p num="p-0190">The following sections give more a more detailed description of part (iii) of the RHSEG implementation for slave tasks of running with different values of runtype.
</p> <ul> <li id="ul0014-0001" num="0000"> <ul> <li id="ul0015-0001" num="0221">Slave tasks of runtype==1 or runtype==2 continue as follows: If level==inb_levels the task requests the input data (input_data, and if provided, mask data, rlblmap_data and spatial_init) from the master task. This input data is byte swapped as necessary.</li> <li id="ul0015-0002" num="0222">If level==inb_levels==rnb_levels, the function region data_init( ) is called in exactly the same manner as it is called in the description of the HSEG main program in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</li> <li id="ul0015-0003" num="0223">If level==inb_levels&lt;rnb_levels, the function lrhseg( ) is called in exactly the same manner as it is called in the description of the RHSEG main program in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</li> </ul> </li> </ul>

  <p num="p-0191">If level&lt;inb_levels, the slave ask requests four branch slave task IDs from the master task. Once these branch slave task IDs are received, the slave task calls the function call_recur<b>2</b>( ) with the following input variable and array data:</p>
  <p num="p-0192"> <tables id="TABLE-US-00047" num="00047"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns</entry> </row> <row> <entry> </entry> <entry>in the current section of input image data</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows</entry> </row> <row> <entry> </entry> <entry>in the current section of input image data</entry> </row> <row> <entry>level</entry> <entry>An int variable containing the value of the</entry> </row> <row> <entry> </entry> <entry>current level of recursion</entry> </row> <row> <entry>my_tid</entry> <entry>An int variable containing the ID of the</entry> </row> <row> <entry> </entry> <entry>current slave task.</entry> </row> <row> <entry>branch_tid</entry> <entry>An int array containing the IDs of the four</entry> </row> <row> <entry> </entry> <entry>slave tasks that the current slave task will</entry> </row> <row> <entry> </entry> <entry>initiate in the function call_recur2( ).</entry> </row> <row> <entry>slave_tid</entry> <entry>An int array containing the IDs of all of</entry> </row> <row> <entry> </entry> <entry>the slave tasks.</entry> </row> <row> <entry>old_first_sec</entry> <entry>An int variable containing the section number</entry> </row> <row> <entry> </entry> <entry>of the first section to be processed by the</entry> </row> <row> <entry> </entry> <entry>current slave task</entry> </row> <row> <entry>old_last_sec</entry> <entry>An int variable containing the section number</entry> </row> <row> <entry> </entry> <entry>of the last section to be processed by the</entry> </row> <row> <entry> </entry> <entry>current slave task</entry> </row> <row> <entry>task_sec</entry> <entry>An int array containing the task IDs of the</entry> </row> <row> <entry> </entry> <entry>slave tasks processing each section of data</entry> </row> <row> <entry> </entry> <entry>in the final stage of RHSEG</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                        </tbody>  </table> </tables> <br/>
The global variables nbands, spatial_wght, inb_levels and fnb_levels are also used as inputs by call_recur<b>2</b>( ). Certain variables and arrays are output by call_recur<b>2</b>( ). They are as follows:
</p>
  <p num="p-0193"> <tables id="TABLE-US-00048" num="00048"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry>regions in the segmentation of the section of</entry> </row> <row> <entry> </entry> <entry>data processed.</entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the current</entry> </row> <row> <entry> </entry> <entry>section of input image data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the current</entry> </row> <row> <entry> </entry> <entry>section of mask data (if any)</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the output</entry> </row> <row> <entry> </entry> <entry>region label map for the current section of</entry> </row> <row> <entry> </entry> <entry>data. This region label map specifies the</entry> </row> <row> <entry> </entry> <entry>spatial distribution of the regions.</entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the current section</entry> </row> <row> <entry> </entry> <entry>of input spatial feature data (local image</entry> </row> <row> <entry> </entry> <entry>variance or standard deviation - if any)</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the current</entry> </row> <row> <entry> </entry> <entry>region number of pixels list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>The j<sup>th</sup> element of the vector is the number of</entry> </row> <row> <entry> </entry> <entry>pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the current sum of</entry> </row> <row> <entry> </entry> <entry>the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the current sum of the</entry> </row> <row> <entry> </entry> <entry>square of the normalized input data values over</entry> </row> <row> <entry> </entry> <entry>all pixels in each region. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) Element</entry> </row> <row> <entry> </entry> <entry>j + nregions*b is the sum square value for</entry> </row> <row> <entry> </entry> <entry>region j + 1 and band b (first band is band</entry> </row> <row> <entry> </entry> <entry>number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the current region</entry> </row> <row> <entry> </entry> <entry>spatial feature value list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>(Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) The j<sup>th</sup> element of the vector is the</entry> </row> <row> <entry> </entry> <entry>spatial feature value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating,</entry> </row> <row> <entry> </entry> <entry>for the current section of data, whether or</entry> </row> <row> <entry> </entry> <entry>not a pair of regions are spatially adjacent</entry> </row> <row> <entry> </entry> <entry>(i.e., neighbors). The value of the mask at</entry> </row> <row> <entry> </entry> <entry>array element j + max_nregions*k is TRUE</entry> </row> <row> <entry> </entry> <entry>if and only if regions j + 1 and k + 1</entry> </row> <row> <entry> </entry> <entry>are spatially adjacent.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                            </tbody>  </table> </tables> <br/>
Other data arrays are passed into call_recur<b>2</b>( ) for use as work space. These are input_sub, mask_sub, rlblmap_sub, spatial_init_sub, rlabel_data, and group_tid.
</p>
  <p num="p-0194">The purpose of the call_recur<b>2</b>( ) function is to initiate slave tasks for each quadrant. The results from each slave task are assembled together by call_recur<b>2</b>( ) and returned to the calling function. The internal operations of the function call_recur<b>2</b>( ) are described in a later section.</p>
  <p num="p-0195">If level&lt;rnb_levels, the neighbor mask, nghbr_mask, must be updated to account for neighbors across the seams of the data sections processed either by the branch slave tasks or the recursive calls in the function lrhseg( ). If level&gt;=fnb_levels, the region labels at the pair of rows and columns adjacent to the seams of the quarters of the image processed by the branch slave task are read directly from the rlblmap_data array, which is present in the current slave task&#39;s memory. If level&lt;fnb_levels, the required region labels must be propagated up from level=fnb_levels , where the region label map data is stored. This is done through a call to the function call_recur<b>4</b>( ), with the following input variables and array data:</p>
  <p num="p-0196">
    <tables id="TABLE-US-00049" num="00049">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the current section of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>level</entry>
              <entry>An int variable containing the value of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>level of recursion</entry>
            </row> <row>
              <entry> </entry>
              <entry>my_tid</entry>
              <entry>An int variable containing the ID of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task.</entry>
            </row> <row>
              <entry> </entry>
              <entry>branch_tid</entry>
              <entry>An int array containing the IDs of the four slave</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>tasks that the current slave task will initiate</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>in the function call_recur4( ).</entry>
            </row> <row>
              <entry> </entry>
              <entry>first_sec</entry>
              <entry>An int variable containing the section number of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the first section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry>last_sec</entry>
              <entry>An int variable containing the section number of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the last section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0197">Other data arrays are passed into call_recur<b>4</b>( ) for use as work space. These are first_col, last_col, first_row, and last_row. Prior to the call to call_recur<b>4</b>( ), the values of first_sec and last_sec must be adjusted so that they are based on fnb_levels rather than inb_levels . This is done in “C” code as follows:</p>
  <p num="p-0198"> <tables id="TABLE-US-00050" num="00050"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>cur_nb_secs = last_sec − first_sec + 1;</entry> </row> <row> <entry> </entry> <entry>for (index = fnb_levels; index &lt; inb_levels; index++)</entry> </row> <row> <entry> </entry> <entry>{</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="42pt" align="left"> </colspec> <colspec colname="1" colwidth="175pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>cur_nb_secs /= 4;</entry> </row> <row> <entry> </entry> <entry>first sec /= 4;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>}</entry> </row> <row> <entry> </entry> <entry>last_sec = first_sec + cur_nb_secs − 1;</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">    </tbody>  </table> </tables> <br/>
If level&gt;=fnb_levels (where call_recur<b>4</b>( ) is not called), the values of first_sec and last_sec must also be adjusted. In this case this adjustment is based on the current recursive level, level, rather that inb_levels or fnb_levels. This is done in “C” code as follows:
</p>
  <p num="p-0199"> <tables id="TABLE-US-00051" num="00051"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="35pt" align="left"> </colspec> <colspec colname="1" colwidth="182pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>cur_nb_secs = last_sec − first_sec + 1;</entry> </row> <row> <entry> </entry> <entry>for (index = level; index &lt; inb_levels; index++)</entry> </row> <row> <entry> </entry> <entry>{</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="49pt" align="left"> </colspec> <colspec colname="1" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>cur_nb_secs /= 4;</entry> </row> <row> <entry> </entry> <entry>first_sec /= 4;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="35pt" align="left"> </colspec> <colspec colname="1" colwidth="182pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>}</entry> </row> <row> <entry> </entry> <entry>last_sec = first_sec + cur_nb_secs − 1;</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">    </tbody>  </table> </tables> <br/>
Back to the level&lt;fnb_levels case, the following data arrays are output by call_recur<b>4</b>( ):
</p>
  <p num="p-0200"> <tables id="TABLE-US-00052" num="00052"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>rlblmap_4cols</entry> <entry>An unsigned short array containing the first,</entry> </row> <row> <entry> </entry> <entry>last and middle two columns of region label map</entry> </row> <row> <entry> </entry> <entry>data for the current section of data.</entry> </row> <row> <entry>rlblmap_4rows</entry> <entry>An unsigned short array containing the first,</entry> </row> <row> <entry> </entry> <entry>last and middle two rows of region label map data</entry> </row> <row> <entry> </entry> <entry>for the current section of data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">        </tbody>  </table> </tables> <br/>
The functional description of call_recur<b>4</b>( ) is given in a later section.
</p>
  <p num="p-0201">In all cases for level&lt;rnb_levels, the array rlblmap_<b>4</b>cols contains the first, middle two and last columns from rlblmap_data, and the array rlblmap_<b>4</b>rows contains the first, middle two and last rows from rlblmap_data. The function update_nghbr_mask( ) is now called in exactly the same manner as it is called in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.” In this call to update_nghbr_mask( ), the middle two rows and columns in rlblmap_<b>4</b>cols and rlblmap_<b>4</b>rows is used to modify the neighbor mask, ngbr_mask, to reflect the neighborhood relationships across the seams of the four sections of data assembled together to form the current of data being processed. The functional description of update_nghbr_mask( ) is given in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</p>
  <p num="p-0202">The function region_list_init( ) is now called to initialize the region_list structure. This call is made in the same manner as it is called in the description of the RHSEG main program in section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.” The functional description of region_list_init( ) is also given in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</p>
  <p num="p-0203">After the call to region_list_init( ) is completed, the following parameters are set: init_flg=TRUE and onregions=nregions. If runtype==1, cvnbregs is set to chkregions and if runtype==2, cvnbregs is set to minregions (note that chkregions and minregions are user set parameters). The program now proceeds in the same manner as in the description of the HSEG main program in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER” with calls to the functions lhseg( ) and read_region_list( ). If nregions&lt;=chkregions, the calls to the functions lhseg( ) and read_region_list( ) are skipped and, if nregions&gt;2 and runtype==1, the program proceeds to call the function phseg( ). The function lhseg( ) performs iterations of region growing and spectral clustering without convergence checking while the function phseg( ) performs iterations of region growing and spectral clustering with convergence checking. The functional description of lhseg( ) is given in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER,” while the functional description of phseg( ) is given in a later section of the current document. Note that the variable init_flag is set to FALSE after the function lhseg( ) is called, if it is called.</p>
  <p num="p-0204">If lhseg( ) and read region_list are called, the region label map, rlblmap_data must be updated to reflect the merges that occurred in lhseg( ) . Note that the rlblmap_data array is NOT updated as the merges occur in the lhseg( ) function. Instead, a list of region label merge pairs is maintained from which the rlblmap_data is updated after the lhseg( ) function exits. If level&gt;=fnb_levels , the rlblmap_data array is updated directly through a call to the function update_rlblmap( ) in the same manner as in the description of the HSEG main program in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.” If level&lt;fnb_levels, this region label merge pairs list is sent to the underlying tasks at level=fnb_levels, through a runtype=6 call, and the rlblmap_data array is updated at that level. This is done with a call to the function call_runtype<b>6</b>( ) with the following input parameters and data arrays:</p>
  <p num="p-0205">
    <tables id="TABLE-US-00053" num="00053">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>first_sec</entry>
              <entry>An int variable containing the section number of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the first section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry>last_sec</entry>
              <entry>An int variable containing the section number of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the last section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry>task_sec</entry>
              <entry>An int array containing the task IDs of the slave</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>tasks processing each section of data in the final</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>stage of RHSEG</entry>
            </row> <row>
              <entry> </entry>
              <entry>my_tid</entry>
              <entry>An int variable containing the ID of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task.</entry>
            </row> <row>
              <entry> </entry>
              <entry>slave_tid</entry>
              <entry>An int array containing the IDs of all of the</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave tasks.</entry>
            </row> <row>
              <entry> </entry>
              <entry>nelements</entry>
              <entry>An int variable containing the number of elements</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>in the relabel_list array</entry>
            </row> <row>
              <entry> </entry>
              <entry>relabel_list</entry>
              <entry>An unsigned short array containing the list of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>pairs of region labels that were merged in the</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>previous call to lhseg( ).</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0206">The group_tid data array is passed into call_runtype<b>6</b>( ) for use as work space. There are no outputs from call_runtype<b>6</b>( ). The functional description of call_runtype<b>6</b>( ) is given in a later section.</p>
  <p num="p-0207">The preceding has described the process followed by the slave tasks for runtype==1 or runtype==2. At this point the processing for these two runtypes diverges. For runtype==1, the following parameters are set: cvnbregs=2 and onregions=nregions. The slave task does not exit, but instead waits for additional processing requests. Then the function phseg( ) is called with the following parameters and array data:</p>
  <p num="p-0208">
    <tables id="TABLE-US-00054" num="00054">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="168pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>init_flag</entry>
              <entry>An int variable which is TRUE if the region_list</entry>
            </row> <row>
              <entry> </entry>
              <entry>has just been initialized and FALSE otherwise.</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in</entry>
            </row> <row>
              <entry> </entry>
              <entry>the input image data</entry>
            </row> <row>
              <entry>onregions</entry>
              <entry>An int variable containing the number of regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>existing when lhseg( ) is initially called.</entry>
            </row> <row>
              <entry>cvnbregs</entry>
              <entry>An int variable indicating the number of regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>at which that this call to fhseg( ) will converge</entry>
            </row> <row>
              <entry> </entry>
              <entry>(exit).</entry>
            </row> <row>
              <entry>my_tid</entry>
              <entry>An int variable containing the ID of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>slave task.</entry>
            </row> <row>
              <entry>calling_tid</entry>
              <entry>An int variable containing the ID of the task that</entry>
            </row> <row>
              <entry> </entry>
              <entry>called the current slave task</entry>
            </row> <row>
              <entry>tot_nb_secs</entry>
              <entry>An int variable containing the total number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>sections the data is processed in at the recursive</entry>
            </row> <row>
              <entry> </entry>
              <entry>level fnb_levels.</entry>
            </row> <row>
              <entry>slave_tid</entry>
              <entry>An int array containing the IDs of all of the slave</entry>
            </row> <row>
              <entry> </entry>
              <entry>tasks.</entry>
            </row> <row>
              <entry>task_sec</entry>
              <entry>An int array containing the task IDs of the slave</entry>
            </row> <row>
              <entry> </entry>
              <entry>tasks processing each section of data in the final</entry>
            </row> <row>
              <entry> </entry>
              <entry>stage of RHSEG</entry>
            </row> <row>
              <entry>rlabel_data</entry>
              <entry>An unsigned short array containing the region label</entry>
            </row> <row>
              <entry> </entry>
              <entry>corresponding to the region for index j. This is</entry>
            </row> <row>
              <entry> </entry>
              <entry>initialized to be rlabel_data[j] = j + 1;</entry>
            </row> <row>
              <entry>npix_data</entry>
              <entry>An unsigned int array containing the region number</entry>
            </row> <row>
              <entry> </entry>
              <entry>of pixels list stored as a vector. The j<sup>th</sup> element</entry>
            </row> <row>
              <entry> </entry>
              <entry>of the vector is the number of pixels in region</entry>
            </row> <row>
              <entry> </entry>
              <entry>j + 1.</entry>
            </row> <row>
              <entry>sum_data</entry>
              <entry>A double array containing the sum of the normalized</entry>
            </row> <row>
              <entry> </entry>
              <entry>input data values over all pixels in each region.</entry>
            </row> <row>
              <entry> </entry>
              <entry>Element j + nregions*b is the sum value for region</entry>
            </row> <row>
              <entry> </entry>
              <entry>j + 1 and band b (first band is band number 0).</entry>
            </row> <row>
              <entry>sumsq_data</entry>
              <entry>A double array containing the sum of the square of</entry>
            </row> <row>
              <entry> </entry>
              <entry>the normalized input data values over all pixels</entry>
            </row> <row>
              <entry> </entry>
              <entry>in each region. (Actually contains values only if</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatial_wght &gt; 0.0.) Element j + nregions*b is</entry>
            </row> <row>
              <entry> </entry>
              <entry>the sum square value for region j + 1 and band b</entry>
            </row> <row>
              <entry> </entry>
              <entry>(first band is band number 0).</entry>
            </row> <row>
              <entry>spatial_data</entry>
              <entry>A double array containing the region spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry>value list stored as a vector. (Actually contains</entry>
            </row> <row>
              <entry> </entry>
              <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th </sup>element</entry>
            </row> <row>
              <entry> </entry>
              <entry>of the vector is the spatial feature value for</entry>
            </row> <row>
              <entry> </entry>
              <entry>region j + 1.</entry>
            </row> <row>
              <entry>nghbr_mask</entry>
              <entry>An unsigned char array of numbers designating whether</entry>
            </row> <row>
              <entry> </entry>
              <entry>or not a pair of regions are spatially adjacent</entry>
            </row> <row>
              <entry> </entry>
              <entry>(i.e., neighbors). The value of the mask at array</entry>
            </row> <row>
              <entry> </entry>
              <entry>element j + max_nregions*k is TRUE if and only</entry>
            </row> <row>
              <entry> </entry>
              <entry>if regions j + 1 and k + 1 are spatially adjacent.</entry>
            </row> <row>
              <entry>region_list</entry>
              <entry>A reg_list (R_LIST) structure array pointing to a</entry>
            </row> <row>
              <entry> </entry>
              <entry>sequence of reg_struct (REGION) structure elements</entry>
            </row> <row>
              <entry> </entry>
              <entry>containing label and comparative information about</entry>
            </row> <row>
              <entry> </entry>
              <entry>each region.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0209">The global variables regmerges_flag, nbands, scale, offset, spclust_flag, spatial_wght, convfact, and max_nregions are also used as inputs to phseg( ). The arrays group_tid, relabel_list, sort_store, and nbsort_store as also passed to the phseg( ) functions for use as work space. The purpose of the phseg( ) function is to perform multiple iterations of region growing intermixed with spectral clustering (if requested) until the number of regions becomes less than or equal to cvnbregs (in this case, 2), and output segmentation results when natural convergence points are detected. See a later section for a functional description of the phseg( ) function.</p>
  <p num="p-0210">For runtype==2, and different process is followed. Here, the current values of nregions, npix_data, sum_data, and nghbr_mask are sent back to the calling slave task. If spatial_wght&gt;0.0, the current values of spatial_data and sumsq_data are also sent. In addition, if level&gt;fnb_levels, the current values of input_data, and rlblmap_data are also sent. Further, if level&gt;fnb_levels and mask_flag==TRUE, the current values for mask_data are sent and if level&gt;fnb_levels and spatial_wght&gt;0.0, the current values for spatial_init are sent. The slave task does not exit, but instead waits for additional processing requests.</p>
  <p num="p-0211">This concludes the description of the slave task processing for runtype==1 or runtype==2. The initial processing request for all slave tasks is of runtype==1 or 2. All slave tasks at recursion level&lt;=fnb_levels receive additional processing requests with other values for runtype. (Slave tasks at level&gt;fnb_levels could exit after the initial processing request, but this is not done in the current version.)</p>
  <p num="p-0212">Slave tasks running at 1&lt;level&lt;=fnb_levels will get called with runtype==4. A runtype==4 slave task determines the region label map data in the first and last columns and the first and last rows of the section of data processed by the task (first_col, last_col, first_row, and last_row) and sends this information back to the calling task. If level==fnb_levels, first_col, last_col, first_row, and last_row are determined directly from the rlblmap_data array, which is contained in memory at this level. If level&lt;fnb_levels, first_col, last_col, first_row, and last_row are determined from rlblmap_<b>4</b>cols, and rlblmap_<b>4</b>rows obtained through a call to call_recur<b>4</b>( ) with the following input variables and data arrays:</p>
  <p num="p-0213">
    <tables id="TABLE-US-00055" num="00055">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the current section of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>level</entry>
              <entry>An int variable containing the value of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>level of recursion</entry>
            </row> <row>
              <entry> </entry>
              <entry>my_tid</entry>
              <entry>An int variable containing the ID of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task.</entry>
            </row> <row>
              <entry> </entry>
              <entry>branch_tid</entry>
              <entry>An int array containing the IDs of the four slave</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>tasks that the current slave task will initiate</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>in the function call_recur4( ).</entry>
            </row> <row>
              <entry> </entry>
              <entry>first_sec</entry>
              <entry>An int variable containing the section number</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>of the first section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry>last_sec</entry>
              <entry>An int variable containing the section number of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>the last section to be processed by the current</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>slave task</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0214">Other data arrays are passed into call_recur<b>4</b>( ) for use as work space. These are first_col, last_col, first_row, and last_row. The following data arrays are output by call_recur<b>4</b>( ):</p>
  <p num="p-0215">
    <tables id="TABLE-US-00056" num="00056">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="147pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>rlblmap_4cols</entry>
              <entry>An unsigned short array containing the first,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>last and middle two columns of region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>map data for the current section of data.</entry>
            </row> <row>
              <entry> </entry>
              <entry>rlblmap_4rows</entry>
              <entry>An unsigned short array containing the first,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>last and middle two rows of region label map</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>data for the current section of data.</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0216">The functional description of call_recur<b>4</b>( ) is given in a later section.</p>
  <p num="p-0217">Slave tasks running at level==fnb_levels will get called with runtype==6. A runtype==6 updates the region label map data for the section of data processed by this task. After receiving the update information from the calling task (nelements and relabel_list) the region label map is updated through a call to the function update_rlblmap( ). A description of the calling of update_rlblmap( ) and a functional description of this function is given in the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”</p>
  <p num="p-0218">Slave tasks running at level==fnb_levels will also get called with runtype==7. A runtype==7 computes the contribution to the global convergence criterion from the section of data processed by the task. The first runtype==7 call to each task must provide a full update of the npix_data, sum_data and if spatial_wght&gt;0.0, the spatial_data arrays. Subsequent calls need only update these arrays with any data that changed from the previous call, and also update the rlblmap_data array in a manner similar to that used under runtype==6. Once the data arrays are initialized or updated, the slave task scans through each data point in the section of data processed by the task, accumulating into the cv_data array the value of the global convergence criterion for the processed section of data. If this is the initial run of runtype==7, the cv_data array is computed for all regions and sent back to the calling task. If this is a subsequent run of runtype==7, the cv_data array is computed only for those regions that changed since the previous runtype==7 call, and only those elements of the cv_data array are sent back to the calling task.</p>
  <p num="p-0219">Slave tasks running at level==fnb_levels will also get called with runtype==8, 9 and 10. These tasks are very simple. For runtype==8, the rlblmap_prev array is update to equal the current value of the rlblmap_data array. For runtype==9, the rlblmap_prev array is sent to the calling task (always the master task), and for runtype ==10, the rlblmap_data array is sent to the calling task (always the master task).</p>
  <p num="p-0220">Functional description of the function call_recur<b>2</b>( ): The function call_recur<b>2</b>( ) first determines task specific parameters it will send to each slave branch task, namely:</p>
  <p num="p-0221"> <tables id="TABLE-US-00057" num="00057"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="133pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>runtype</entry> <entry>branch slave task run type</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(equal to “2” in this case)</entry> </row> <row> <entry> </entry> <entry>first_sec</entry> <entry>first section to be processed</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>by branch slave task</entry> </row> <row> <entry> </entry> <entry>last_sec</entry> <entry>last section to be processed</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>by branch slave task</entry> </row> <row> <entry> </entry> <entry>calling_tid</entry> <entry>current task ID</entry> </row> <row> <entry> </entry> <entry>level</entry> <entry>current level of recursion + 1</entry> </row> <row> <entry> </entry> <entry>ncols</entry> <entry>number of columns in section of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>data processed by branch slave</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>task (equal to ½ of the number</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>of columns processed by the current</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>task)</entry> </row> <row> <entry> </entry> <entry>nrows</entry> <entry>number of rows in section of data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>processed by branch slave task</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(equal to ½ of the number of rows</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>processed by the current task)</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                   </tbody>  </table> </tables> <br/>
The first and last sections to be processed by each branch slave task are determined as illustrated by the following “C” extracts:
</p> <ul> <li id="ul0016-0001" num="0000"> <ul> <li id="ul0017-0001" num="0255">/* Initiate processing of first subsection (of 4) */</li> <li id="ul0017-0002" num="0256">nb_secs=old_last_sec−old_first_sec+1;</li> <li id="ul0017-0003" num="0257">nb_secs=nb_secs/4;</li> <li id="ul0017-0004" num="0258">first sec=old_first_sec;</li> <li id="ul0017-0005" num="0259">last_sec=old_first_sec+nb_secs-1;</li> <li id="ul0017-0006" num="0260">. . .</li> <li id="ul0017-0007" num="0261">/* Initiate processing of second subsection (of 4) */</li> <li id="ul0017-0008" num="0262">first_sec=old_first_sec+nb_secs;</li> <li id="ul0017-0009" num="0263">last_sec=old_first_sec+2*nb_secs-1;</li> <li id="ul0017-0010" num="0264">. . .</li> <li id="ul0017-0011" num="0265">/* Initiate processing of third subsection (of 4) */</li> <li id="ul0017-0012" num="0266">first_sec=old_first_sec+2*nb_secs;</li> <li id="ul0017-0013" num="0267">last_sec=old_first_sec+3*nb_secs−1;</li> <li id="ul0017-0014" num="0268">/* Initiate processing of fourth subsection (of 4) */</li> <li id="ul0017-0015" num="0269">first_sec=old_first_sec+3*nb_secs;</li> <li id="ul0017-0016" num="0270">last_sec=old_first_sec+4*nb_secs−1;
<br/>
where “old_first_sec ” and “old_last_sec” are the current (“old”) first section and last sections, respectively. After all four branch slave tasks are initiated through the sending of the task specific parameters to each branch slave task, the slave task waits for the first branch slave task to complete.
</li> </ul> </li> </ul>
  <p num="p-0222">Certain region parameters, arrays and vectors are produced by each of the slave tasks by combining the results produced by the four branch slave tasks. They are as follows:</p>
  <p num="p-0223">
    <tables id="TABLE-US-00058" num="00058">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>nregions</entry>
              <entry>the number of regions in the section</entry>
            </row> <row>
              <entry> </entry>
              <entry>of data processed.</entry>
            </row> <row>
              <entry>rlblmap_data</entry>
              <entry>an array of numbers specifying the</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatial distribution of the regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>(data type unsigned short).</entry>
            </row> <row>
              <entry>npix_data</entry>
              <entry>the region number of pixels list stored</entry>
            </row> <row>
              <entry> </entry>
              <entry>as a vector. The j<sup>th</sup> element of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>vector is the number of pixels in region</entry>
            </row> <row>
              <entry> </entry>
              <entry>j + 1 (data type unsigned int).</entry>
            </row> <row>
              <entry>sum_data</entry>
              <entry>a vector containing the sum of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>normalized input data values over all</entry>
            </row> <row>
              <entry> </entry>
              <entry>pixels in each region. Element j + nregions*b</entry>
            </row> <row>
              <entry> </entry>
              <entry>is the sum value for region j + 1 and band b</entry>
            </row> <row>
              <entry> </entry>
              <entry>(first band is band number 0) (data type double).</entry>
            </row> <row>
              <entry>nghbr_mask</entry>
              <entry>an array of numbers designating whether or</entry>
            </row> <row>
              <entry> </entry>
              <entry>not a pair of regions are spatially adjacent</entry>
            </row> <row>
              <entry> </entry>
              <entry>(i.e., neighbors). The value of the mask at</entry>
            </row> <row>
              <entry> </entry>
              <entry>array element j + max_nregions*k is TRUE if and</entry>
            </row> <row>
              <entry> </entry>
              <entry>only if regions j + 1 and k + 1 are spatially adjacent</entry>
            </row> <row>
              <entry> </entry>
              <entry>(data type unsigned char).</entry>
            </row> <row>
              <entry>spatial_data</entry>
              <entry>the region spatial feature value list stored</entry>
            </row> <row>
              <entry> </entry>
              <entry>as a vector. The j<sup>th</sup> element of the vector is the spatial</entry>
            </row> <row>
              <entry> </entry>
              <entry>feature value for region j + 1 (data type double).</entry>
            </row> <row>
              <entry>sumsq_data</entry>
              <entry>a vector containing the sum of the square of</entry>
            </row> <row>
              <entry> </entry>
              <entry>the normalized input data values over al pixels</entry>
            </row> <row>
              <entry> </entry>
              <entry>in each region. Element j + nregions*b is the sum</entry>
            </row> <row>
              <entry> </entry>
              <entry>square value for region j + 1 and band b</entry>
            </row> <row>
              <entry> </entry>
              <entry>(first band is band number 0) (data type double).</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0224">The slave task now waits for each branch slave task to complete in turn (branch slave tasks t=0 through t=3 in numerical order.) When the t<sup>th </sup>branch slave task completes, the slave task receives the number of regions (sub_nregions[t]) resulting from processing the t<sup>th </sup>branch slave task&#39;s data sections with the RHSEG algorithm. If sub_nregions[t]&gt;0, the slave task receives the region parameters npix_sub, sum_sub and nghbr_sub (and if spatial_wght&gt;0, also spatial_sub and sumsq_sub) for the subsection of data processed. If sub_nregions[t]&gt;0 and level&gt;=fnb_levels, the slave task also receives the input data, input_sub (and also the input mask data, mask_sub, if mask_flag==TRUE, and the input spatial feature data, spatial_init_sub, if spatial_wght&gt;0.0), and the region label map result, rlblmap_sub for the subsection of data processed.</p>
  <p num="p-0225">The data output from each branch slave task must be combined appropriately to form the input data for the calling slave task&#39;s eventual running of the HSEG algorithm. If level&gt;=fnb_levels, the calling slave task array rlblmap_data is formed from the rlblmap_sub arrays by using the array offsets sub_coff=0 and sub_roff=0 for t=0, sub_coff=ncols and sub_roff=0 for t=1, sub_coff=0 and sub_roff=nrows for t=2, and sub_coff=ncols and sub_roff=nrows for t=3, where ncols and nrows are the number of columns and rows, respectively, processed by each branch slave task. For branch slave tasks t=1 through t=3, the rlblmap_data values are also offset by the value from the values in rlblmap_sub by the value sum_nregions[t−1], where 
<maths id="MATH-US-00018" num="00018"> <math overflow="scroll"> <mrow> <mrow> <mi>sum_</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>r</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>g</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>o</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>ns</mi> <mo>[</mo> <mi>t</mi> <mo>]</mo> </mrow> </mrow> <mo>=</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>τ</mi> <mo>=</mo> <mn>0</mn> </mrow> <mi>t</mi> </munderover> <mo>⁢</mo> <mrow> <mi>sum_</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>r</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>g</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>o</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mrow> <mi>ns</mi> <mo>[</mo> <mi>τ</mi> <mo>]</mo> </mrow> <mo>.</mo> </mrow> </mrow> </mrow> </mrow> </math> </maths>
<br/>
This region label offset is applied to differentiate region j from branch slave task t from region j in branch slave task t′, where t≠t′. If the branch slave task data outputs input_sub, mask_sub and spatial_init_sub are received, these data are placed with the same spatial offsets into the calling slave task data arrays input_data, mask_data and spatial_init, but with no offset in data value.
</p>
  <p num="p-0226">If level&lt;=fnb_levels and branch slave task t&gt;0, calls of runtype=6 are made to the tasks at level=fnb_levels, that are under the calling slave task in the recursive tree, that causes the rlblmap_data data values stored by those slave tasks to be offset by the value sum_nregions[t−1]. These calls of runtype==6 are made through the function call_runtype<b>6</b>( ). However, before these calls can be made, the values of “old_first_sec”, “old_last_sec” and “nb_secs” must be adjusted to be based on fnb_levels rather than inb_levels. This is done through the following “C” code extract:</p>
  <p num="p-0227"> <tables id="TABLE-US-00059" num="00059"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="196pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>if (level &lt;= fnb_levels)</entry> </row> <row> <entry> </entry> <entry>{</entry> </row> <row> <entry> </entry> <entry>/* Adjust old_first_sec, old_last_sec and nb_secs */</entry> </row> <row> <entry> </entry> <entry> nb_secs = old_last_sec − old_first_sec + 1;</entry> </row> <row> <entry> </entry> <entry> for (index = fnb_levels; index &lt; inb_levels; index ++)</entry> </row> <row> <entry> </entry> <entry> {</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="35pt" align="left"> </colspec> <colspec colname="1" colwidth="182pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>nb_secs /= 4;</entry> </row> <row> <entry> </entry> <entry>old_first_sec /= 4;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="21pt" align="left"> </colspec> <colspec colname="1" colwidth="196pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry> }</entry> </row> <row> <entry> </entry> <entry> old_last_sec = old_first_sec + nb_secs − 1;</entry> </row> <row> <entry> </entry> <entry> nb_secs /= 4;</entry> </row> <row> <entry> </entry> <entry>}</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">       </tbody>  <tbody valign="top">   </tbody>  <tbody valign="top">      </tbody>  </table> </tables> <br/>
Then calls to call_runtype<b>6</b>( ) are made with the following parameters:
</p>
  <p num="p-0228"> <tables id="TABLE-US-00060" num="00060"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>first_sec</entry> <entry>An int variable containing the section number</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>of the first section to be processed</entry> </row> <row> <entry> </entry> <entry>last_sec</entry> <entry>An int variable containing the section number</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>of the last section to be processed</entry> </row> <row> <entry> </entry> <entry>task_sec</entry> <entry>An int array containing the task IDs of the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>slave tasks processing each section of data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>in the final stage of RHSEG</entry> </row> <row> <entry> </entry> <entry>my_tid</entry> <entry>An int variable containing the ID of the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>current slave task.</entry> </row> <row> <entry> </entry> <entry>slave_tid</entry> <entry>An int array containing the IDs of all of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>the slave tasks.</entry> </row> <row> <entry> </entry> <entry>nelements</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>elements in the relabel_list array. Equal to</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>“1” in this case.</entry> </row> <row> <entry> </entry> <entry>relabel_list</entry> <entry>An unsigned short array containing one element</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>equal to the offset to be added to the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>rlblmap_data array.</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                   </tbody>  </table> </tables> <br/>
In the above calls to call_runtype<b>6</b>( ), first_sec and last_sec must be specified differently for each value of t. For t=0, a call to call_runtype<b>6</b>( ) is not required. For t=1, first_sec=old_first_sec+nb_secs and last_sec=old_first_sec+2*nb_secs−1. For t=2, first_sec=old_first_sec+2*nb_secs and last_sec=old_first_sec+3*nb_secs−1. For t=3, first_sec=old_first_sec+3*nb_secs and last_sec=old_first_sec+4*nb_secs−1. The group_tid data array is passed into call_runtype<b>6</b>( ) for use as work space. There are no outputs from call runtype<b>6</b>( ). The functional description of call_runtype<b>6</b>( ) is given in a later section.
</p>
  <p num="p-0229">For the first branch slave task (t=0), the data from npix_sub, and sum_sub (along with spatial_sub and sumsq_sub if spatial_wght&gt;0) are simply placed in the storage locations for npix_data and sum_data (and for spatial_data and sumsq_data if spatial_wght&gt;0). For branch slave task t=1 through 3, the data from npix_sub, and sum_sub (along with spatial_sub and sumsq_sub if spatial_wght&gt;0) are placed in the storage locations npix_data[sum_nregions[t−1]] and sum_data[sum_nregions[t−1]*nbands] (and at spatial_data[sum_nregions[t−1]] and sumsq_data[sum_nregions[t−1]*nbands] if spatial_wght&gt;0). Thus, for these output data from the branch slave tasks the data is simply concatenated together to form the input data for the calling slave task.</p>
  <p num="p-0230">The calling slave task input data nghbr_mask is also formed by concatenation of the branch slave task output data nghbr_sub, but in a manner that takes into account the region label data value offset that was applied.
<br/>
The calling slave task&#39;s initial number regions is 
<maths id="MATH-US-00019" num="00019"> <math overflow="scroll"> <mrow> <mrow> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>r</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>e</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>g</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>i</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>o</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>n</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>s</mi> </mrow> <mo>=</mo> <mrow> <munderover> <mo>∑</mo> <mrow> <mi>τ</mi> <mo>=</mo> <mn>0</mn> </mrow> <mn>3</mn> </munderover> <mo>⁢</mo> <mrow> <mrow> <mi>sub_nregions</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mi>τ</mi> <mo>]</mo> </mrow> </mrow> <mo>.</mo> </mrow> </mrow> </mrow> </math> </maths>
</p>
  <p num="p-0231">Functional description of the function call_recur<b>4</b>( ): The recursive call of runtype=4 is initiated in a manner similar to that used for runtype=1 or runtype=2. The task specific parameters for each branch slave task are the same, except that runtype=4. After the recursive runtype=4 are made to the four branch slave tasks, the slave task waits for each branch slave task to complete in turn (branch slave tasks t=0 through t=3 in numerical order). When the t<sup>th </sup>branch slave task completes, the slave task receives the region label data from the first and last columns and rows of the branch slave task. This data is loaded into arrays that, when the data from all branch slave tasks is received, will contain the region label data from the first, last and middle two columns and rows of the region label data for the section of the image covered by the slave task.</p>
  <p num="p-0232">Functional description of the function call_runtype<b>6</b>( ): The function call_runtype<b>6</b>( ) is constructed differently than the functions call_recur<b>2</b>( ) or call_recur<b>4</b>( ). While call_recur<b>2</b>( ) and call_recur<b>4</b>( ) initiate recursive calls to 4 branch slave tasks, call_runtype<b>6</b>( ) initiates a non-recursive call directly to all slave tasks at level=fnb_levels under the current task in the recursive tree used by call_recur<b>2</b>( ) and call_recur<b>4</b>( ). Included in the inputs to call_runtype<b>6</b>( ) are the task_sec array, which contains the correspondence between sections and tasks, and slave_tid array, which contains the correspondence between tasks and process task IDs. Using information from these two arrays, calls of runtype==6 are made to the slave tasks that hold the data corresponding to the appropriate sections. The group_tid array is constructed to contain the process task IDs of these slave tasks, and the nelements parameter and the relabel_list array is broadcast to each of these slave tasks. Finally, call_runtype<b>6</b>( ) returns to the calling function after waiting for each task to report back that it has finished the task of updating the rlblmap_data array for its section of data.</p>
  <p num="p-0233">Functional description of the function phseg( ): Finally, we now describe the phseg( ) subroutine that implements the HSEG algorithm for the case when the global convergence criterion values IS calculated. The phseg( ) subroutine is identical to the lhseg( ) function except for the added code we discuss below (for a description of the lhseg( ) function see the section of this document entitled, “IMPLEMENTING A RECURSIVE HIERARCHICAL SEGMENTATION ALGORITHM ON A COMPUTER.”) Also, phseg( ) terminates when the number of region (nregions) is less than or equal to cvnbregs (normally equal to 2). Note also that phseg( ) is not called until the number of regions is less than or equal to chkregions.</p>
  <p num="p-0234">In Section I, part B the basic HSEG algorithm was described. In step 7, it was noted that at certain iterations, the region information from the previous iteration must be saved. Accordingly, phseg( ) allocates and initializes and updates data arrays to store this information. The data array rlblmap_prev is initialized and updated through runtype=8 calls to the tasks at level=fnb_levels, as that is where the rlblmap_data array is maintained. Also, prevcritval is initialized to 0.0, and the current value of the global criterion value, critval, is calculated through a runtype=7 call to the tasks at level=fnb_levels. This initial global criterion value is sent to the master program. (The runtype==7 and runtype==8 calls are performed through functions calls to the functions call_runtype<b>7</b>( ) and call_runtype<b>8</b>( ), respectively, in a similar manner as done for call_runtype<b>6</b>( ).)</p>
  <p num="p-0235">In lhseg( ) the rlblmap_data is not updated. However, in phseg( ) the rlblmap_data is updated after each group of region growing and spectral clustering merges (steps 2 through 5 of the basic HSEG algorithm description in Section I, part B). In addition, the region number of pixels and region sum vectors are updated. If spatial_wght&gt;0.0, the region sum square vectors and region spatial feature values are updated. This is all accomplished through a runtype=7 call to the tasks at level=fnb_levels. Returned from this call are the changes in the global criterion value for each changed region. This information is used to update the global criterion value, critval.</p>
  <p num="p-0236">The value of cvratio=critval/prevcritval is now calculated. If cvratio&gt;convfact, then the region information for the previous iteration (prior to the current group of region growing and spectral clustering merges) is sent to the master program. This information includes the number of regions, the region number of pixels list, the region mean vector list and the region criterion value list. (Upon receipt of this information, the master program requests the previous iteration region label map, rlblmap_prev, directly from the slave tasks at level=fnb_levels.)</p>
  <p num="p-0237">At this point, phseg( ) finds the value of minbcomp in the same manner as lhseg( ) and initiates another iteration of region growing and spectral clustering.</p>
  <p num="p-0238">After the number of regions reaches cvnbregs, after a set of spectral clustering merges, phseg( ) sends the region information for the current iteration to the master program. This information includes the number of regions, the region number of pixels list, the region mean vector list and the region criterion value list. Upon receipt of this information, the master program requests the current iteration region label map, rlblmap_data, directly from the slave tasks at level=fnb_levels.</p>
  <p num="p-0239">Part (i) of the RHSEG program is written in the “C” programming language, compiled under the gcc version 2.8.1 compiler(since upgraded to version 2.95.2), under the Solaris 7 operating system (since upgraded to Solaris 8) on a SUN Workstation. However, this software should both compile and run using other “C” compilers under other UNIX-type operating systems, possibly with minor modifications.</p>
  <p num="p-0240">Parts (ii) and (iii) of the RHSEG program are written in the “C” programming language, with additional function calls to routines available from the “PVM” software package. On the HIVE the program is compiled under the gcc version egcs-2.91.66 compiler, with PVM version 3.4.2, under RedHat LINUX operating system version 6.1 (since upgrade to version 6.2). On the Cray T3E the program is compiled under Cray Standard C Version 6.2.0.0, with PVM version 3.3.10 (Cray PVM for UNICOS Version 3.2.0.0), under the UNICOS version 10 operating system. However, this software should both compile and run using other “C” compilers under other UNIX-type operating systems, possibly with minor modifications. The most efficient running of parts (ii) and (iii) of the RHSEG program requires an appropriate number of processors depending on the size of the image being processed.</p>
  <p num="p-0241">Although a few preferred embodiments of the present invention have been shown and described, it would be appreciated by those skilled in the art that changes may be made in these embodiments without departing from the principles and spirit of the invention, the scope of which is defined in the claims and their equivalents.</p>
  <heading>Implementing a Recursive Hierarchical Segmentation Algorityhm on a Computer</heading>
  <p num="p-0242">This section is provided to help enable a reader to implement a recursive algorithm on a computer. The description below does not discuss the parallel implementation, and is one example of a typical serial implementation of a recursive hierarchical segmentation algorithm.</p>
  <p num="p-0243">The high-level description of the HSEG and RHSEG was provided earlier. The following full-description of the sequential version of the algorithm should be sufficient for duplication of the algorithm by individuals with adequate background in image processing and “C” language programming.</p>
  <p num="p-0244">Both HSEG and RHSEG require the specification of the name of an input parameter file as a UNIX command line argument (fully qualified with path, if not in the local directory). This input parameter file must specify of a number of file names and several parameters. A user&#39;s guide-like description of these file names and parameters is given below. The detailed description of a parameter is omitted wherever it is identical to that given previously for the parallel implementation.</p>
  <p num="p-0245">
    <tables id="TABLE-US-00061" num="00061">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="1" colwidth="42pt" align="left"> </colspec>
          <colspec colname="2" colwidth="70pt" align="left"> </colspec>
          <colspec colname="3" colwidth="105pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input</entry>
              <entry>(required</entry>
              <entry>Input image data file</entry>
            </row> <row>
              <entry> </entry>
              <entry>input file)</entry>
            </row> <row>
              <entry>mask</entry>
              <entry>(optional</entry>
              <entry>Input data mask (default =</entry>
            </row> <row>
              <entry> </entry>
              <entry>input file)</entry>
              <entry>{none})</entry>
            </row> <row>
              <entry>rlblmap_in</entry>
              <entry>(optional</entry>
              <entry>Input region label map</entry>
            </row> <row>
              <entry> </entry>
              <entry>input file)</entry>
              <entry>(default = {none})</entry>
            </row> <row>
              <entry>rlblmap</entry>
              <entry>(required</entry>
              <entry>Output region label map data</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
            </row> <row>
              <entry>rnpixlist</entry>
              <entry>(required</entry>
              <entry>Output region number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
              <entry>pixels list</entry>
            </row> <row>
              <entry>regmerges</entry>
              <entry>(optional</entry>
              <entry>Output region merges list</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
              <entry>(default = {none})</entry>
            </row> <row>
              <entry>rmeanlist</entry>
              <entry>(optional</entry>
              <entry>Output region mean list</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
              <entry>(default = {none})</entry>
            </row> <row>
              <entry>rcvlist</entry>
              <entry>(optional</entry>
              <entry>Output region criterion</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
              <entry>value list (default = {none})</entry>
            </row> <row>
              <entry>oparam</entry>
              <entry>(required</entry>
              <entry>Output parameter file</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
            </row> <row>
              <entry>log_file</entry>
              <entry>(required</entry>
              <entry>Output log file</entry>
            </row> <row>
              <entry> </entry>
              <entry>output file)</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>(required integer)</entry>
              <entry>Number of columns in input</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>(required integer)</entry>
              <entry>Number of rows in input image</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>data</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>(required integer)</entry>
              <entry>Number of spectral bands in</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>input image data</entry>
            </row> <row>
              <entry>dtype</entry>
              <entry>(required integer)</entry>
              <entry>Data type of input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>dtype = 4 designates “unsigned</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>char”</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>dtype = 16 designates “unsigned</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>short”</entry>
            </row> <row>
              <entry>normind</entry>
              <entry>(optional list</entry>
            </row> <row>
              <entry> </entry>
              <entry>selection)</entry>
            </row> <row>
              <entry> </entry>
              <entry>1 “No Normalization”,</entry>
            </row> <row>
              <entry> </entry>
              <entry>2 “Normalize</entry>
            </row> <row>
              <entry> </entry>
              <entry>3 “Normalize</entry>
              <entry>[default: 2 “Normalize Across</entry>
            </row> <row>
              <entry> </entry>
              <entry>Bands Separately”</entry>
              <entry>Bands”]</entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>(optional integer)</entry>
              <entry>Value equals number of nearest</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>neighbors (Permissible values:</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>4, 8, 12 or 20; default = 8)</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>(optional list</entry>
              <entry>Dissimilarity criterion</entry>
            </row> <row>
              <entry> </entry>
              <entry>selection)</entry>
            </row> <row>
              <entry> </entry>
              <entry>1 “1-Norm”,</entry>
            </row> <row>
              <entry> </entry>
              <entry>2 “2-Norm”,</entry>
            </row> <row>
              <entry> </entry>
              <entry>3 “Infinity Norm”,</entry>
              <entry>[default: 1 “1-Norm”]</entry>
            </row> <row>
              <entry>extmean</entry>
              <entry>(optional Boolean)</entry>
              <entry>Flag for extracting mean</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(default = TRUE)</entry>
            </row> <row>
              <entry>spclust</entry>
              <entry>(optional Boolean)</entry>
              <entry>Spectral clustering flag</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(default = TRUE)</entry>
            </row> <row>
              <entry>spatial_wght</entry>
              <entry>(optional float)</entry>
              <entry>Weight for spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(spatial_wght &gt;= 0.0,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 0.0)</entry>
            </row> <row>
              <entry>spatial_type</entry>
              <entry>(optional list</entry>
              <entry>Spatial feature type</entry>
            </row> <row>
              <entry> </entry>
              <entry>selection)</entry>
            </row> <row>
              <entry> </entry>
              <entry>1 “Variance”,</entry>
            </row> <row>
              <entry> </entry>
              <entry>2 “Standard</entry>
              <entry>[default: 2 “Standard Deviation”]</entry>
            </row> <row>
              <entry> </entry>
              <entry>Deviation”</entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>(optional integer)</entry>
              <entry>Total number of recursive levels</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(only for RHSEG)</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(1 &lt;= rnb_levels &lt;= 9,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 4)</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>(optional integer)</entry>
              <entry>Number of regions for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>convergence in recursive</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>stages (only for RHSEG)</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(2 &lt;= minregions &lt;= 4096,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 384)</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>(optional integer)</entry>
              <entry>Number of regions at which</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>convergence factor checking is</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>initiated</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(2 &lt;= chkregions &lt;= 4096,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 512)</entry>
            </row> <row>
              <entry>convfact</entry>
              <entry>(optional float)</entry>
              <entry>Convergence factor</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(1 &lt;= convfact &lt;= 100,</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>default = 1.01)</entry>
            </row> <row>
              <entry>tmpdir</entry>
              <entry>(optional string)</entry>
              <entry>Path name to directory in which</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>temporary files are to be stored</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(default = $TMPDIR)</entry>
            </row> <row>
              <entry>tempfile</entry>
              <entry>(optional string)</entry>
              <entry>Prefix for temporary file names</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>(default = HSEG########## for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>HSEG and RHSEG######### for</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>RHSEG, where the # are random</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry>characters)</entry>
            </row> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0246">Previous disclosures also did not reveal the variations on the dissimilarity criterion discussed above under the extmean, spatial_type and spatial_wght optional parameters. These dissimilarity criterion variations facilitate a more effective separation of regions of interest in certain Earth science applications.</p>
  <p num="p-0247">An optional graphical user interface (GUI) program, implemented under the Khoros Pro 2000 Software Developer&#39;s Kit is available. This GUI program runs on any workstation running Unix or many of its variants. It creates the parameter file and the headerless binary input data files required by the HSEG and RHSEG programs. This GUI program is totally optional, as the parameter file and the headerless binary input data files required by HSEG and RHSEG can be created manually. The optional user interface and data reformatting program outputs the results in the form of Khoros data objects. These Khoros data objects can be input to separate programs for further analysis. This optional GUI program is not a part of this “Disclosure of Invention and New Technology.”</p>
  <p num="h-0008">Functional operation</p>
  <p num="p-0248">The HSEG and RHSEG programs were implemented in “C” under the gcc version 2.8.1 compiler. They were developed under the Solaris 7 operating system on a SUN Workstation, but they should both compile and run with other “C” compilers and under other UNIX-type operating systems, possibly with minor modification.</p>
  <p num="p-0249">In the this section, the HSEG and RHSEG programs main programs are described, followed by description of functions called by the HSEG and RHSEG main programs. RHSEG calls all the functions called by HSEG, but not vice versa.</p>
  <p num="p-0250">Functional Description of the HSEG Main Program: The HSEG main program initially determines the name of the parameter file from the command line input, and reads in the parameters from the file using the function read_param( ). If a prefix for the temporary filenames in not provided in the parameter file, the program generates a character string to used at a prefix for file names for temporary files required by the program. The “C” library function tempnam( ) is used for this purpose. For the discussion below, this prefix is assumed to be “HSEG0000 .”</p>
  <p num="p-0251">At this point the HSEG main program opens the log file and outputs to it the program parameters using the function print_param( ). The following parameters are declared as external variables, and can be utilized in the main program and any “C” functions called subsequently.</p>
  <p num="p-0252">
    <tables id="TABLE-US-00062" num="00062">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>inputf</entry>
              <entry>A char array containing the name of the input</entry>
            </row> <row>
              <entry> </entry>
              <entry>image data file</entry>
            </row> <row>
              <entry>maskf</entry>
              <entry>A char array containing the name of the mask</entry>
            </row> <row>
              <entry> </entry>
              <entry>data file, if it exists. If no mask data file</entry>
            </row> <row>
              <entry> </entry>
              <entry>exists, maskf has the value “NULL.”</entry>
            </row> <row>
              <entry>rlblmap_inf</entry>
              <entry>A char array containing the name of the input</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data file, if it exists. If no</entry>
            </row> <row>
              <entry> </entry>
              <entry>mask data file exists, rlblmap_inf has the value</entry>
            </row> <row>
              <entry> </entry>
              <entry>“NULL.”</entry>
            </row> <row>
              <entry>rlblmapf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data file.</entry>
            </row> <row>
              <entry>rnpixlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region number of pixels list data file.</entry>
            </row> <row>
              <entry>regmergesf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region merges list data file, if requested. If</entry>
            </row> <row>
              <entry> </entry>
              <entry>the output region merges list data file is not</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested, regmergesf has the value “NULL.”</entry>
            </row> <row>
              <entry>rmeanlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region mean list data file, if requested. If</entry>
            </row> <row>
              <entry> </entry>
              <entry>the output region mean list data file is not</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested, rmeanlistf has the value “NULL.”</entry>
            </row> <row>
              <entry>rcvlistf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>region criterion value list data file, if</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested. If the output region criterion value</entry>
            </row> <row>
              <entry> </entry>
              <entry>list data file is not requested, rcvlistf has</entry>
            </row> <row>
              <entry> </entry>
              <entry>the value “NULL.”</entry>
            </row> <row>
              <entry>oparamf</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>parameter file.</entry>
            </row> <row>
              <entry>log_file</entry>
              <entry>A char array containing the name of the output</entry>
            </row> <row>
              <entry> </entry>
              <entry>log file.</entry>
            </row> <row>
              <entry>tmpdir</entry>
              <entry>A char array containing the path name to the</entry>
            </row> <row>
              <entry> </entry>
              <entry>directory where temporary files are to be</entry>
            </row> <row>
              <entry> </entry>
              <entry>stored.</entry>
            </row> <row>
              <entry>tempfile</entry>
              <entry>A char array containing the prefix for temporary</entry>
            </row> <row>
              <entry> </entry>
              <entry>file names.</entry>
            </row> <row>
              <entry>mask_flag</entry>
              <entry>An int variable which has value TRUE if mask</entry>
            </row> <row>
              <entry> </entry>
              <entry>data exist (FALSE otherwise).</entry>
            </row> <row>
              <entry>rlblmap_in_flag</entry>
              <entry>An int variable which has value TRUE if input</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data is given (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>regmerges_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region merges list is requested (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>rmeanlist_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region mean list is requested (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>rcvlist_flag</entry>
              <entry>An int variable which has value TRUE if the</entry>
            </row> <row>
              <entry> </entry>
              <entry>output region criterion value list is</entry>
            </row> <row>
              <entry> </entry>
              <entry>requested (FALSE otherwise).</entry>
            </row> <row>
              <entry>spclust_flag</entry>
              <entry>An int variable that is TRUE if spectral</entry>
            </row> <row>
              <entry> </entry>
              <entry>clustering is to be performed (FALSE</entry>
            </row> <row>
              <entry> </entry>
              <entry>otherwise).</entry>
            </row> <row>
              <entry>nbands</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>spectral bands in the input image data.</entry>
            </row> <row>
              <entry>dtype</entry>
              <entry>An int variable containing an indicator of</entry>
            </row> <row>
              <entry> </entry>
              <entry>the data type of the input image data. (dtype ==</entry>
            </row> <row>
              <entry> </entry>
              <entry>4 designates unsigned char and dtype == 16</entry>
            </row> <row>
              <entry> </entry>
              <entry>designates unsigned short).</entry>
            </row> <row>
              <entry>maxmdir</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>nearest neighbors considered.</entry>
            </row> <row>
              <entry>normind</entry>
              <entry>An int variable containing an indicator of</entry>
            </row> <row>
              <entry> </entry>
              <entry>the type of normalization requested.</entry>
            </row> <row>
              <entry> </entry>
              <entry>(normind == 1 designates “No Normalization,”</entry>
            </row> <row>
              <entry> </entry>
              <entry>normind == 2 designates “Normalization Across</entry>
            </row> <row>
              <entry> </entry>
              <entry>Bands,” and normind == 3 designates “Normalize</entry>
            </row> <row>
              <entry> </entry>
              <entry>Bands Separately”).</entry>
            </row> <row>
              <entry>simcrit</entry>
              <entry>An int variable indicating the dissimilarity</entry>
            </row> <row>
              <entry> </entry>
              <entry>criterion to be used.</entry>
            </row> <row>
              <entry>extmean</entry>
              <entry>An int variable that is TRUE if the vector</entry>
            </row> <row>
              <entry> </entry>
              <entry>mean is subtracted from the spectral vectors</entry>
            </row> <row>
              <entry> </entry>
              <entry>before the dissimilarity criterion is</entry>
            </row> <row>
              <entry> </entry>
              <entry>calculated, FALSE otherwise.</entry>
            </row> <row>
              <entry>spatial_type</entry>
              <entry>An int variable indicating the spatial</entry>
            </row> <row>
              <entry> </entry>
              <entry>feature type employed (1 =&gt; “Variance”,</entry>
            </row> <row>
              <entry> </entry>
              <entry>and 2 =&gt; “Standard Deviation”).</entry>
            </row> <row>
              <entry>chkregions</entry>
              <entry>An int variable containing the number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>regions at which convergence factor checking</entry>
            </row> <row>
              <entry> </entry>
              <entry>is initiated.</entry>
            </row> <row>
              <entry>max_nregions</entry>
              <entry>An int variable containing the maximum</entry>
            </row> <row>
              <entry> </entry>
              <entry>number of regions that will be encountered</entry>
            </row> <row>
              <entry> </entry>
              <entry>in processing the data.</entry>
            </row> <row>
              <entry>spatial_wght</entry>
              <entry>A float variable which contains the value</entry>
            </row> <row>
              <entry> </entry>
              <entry>of the weight for the spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry>(a value of 0.0 indicates the spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry>is not employed).</entry>
            </row> <row>
              <entry>convfact</entry>
              <entry>A float variable containing the value of</entry>
            </row> <row>
              <entry> </entry>
              <entry>the convergence factor for detecting natural</entry>
            </row> <row>
              <entry> </entry>
              <entry>convergence points.</entry>
            </row> <row>
              <entry>scale</entry>
              <entry>A float array containing the multispectral</entry>
            </row> <row>
              <entry> </entry>
              <entry>scale factor(s) for normalization.</entry>
            </row> <row>
              <entry>offset</entry>
              <entry>A float array containing multispectral</entry>
            </row> <row>
              <entry> </entry>
              <entry>offset factor(s) for normalization.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0253">The HSEG main program now allocates memory for the input_data array and, if necessary, for the mask_data and rlblmap_data arrays. These data arrays are declared and allocated as follows:</p>
  <p num="p-0254">
    <tables id="TABLE-US-00063" num="00063">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="35pt" align="left"> </colspec>
          <colspec colname="3" colwidth="63pt" align="left"> </colspec>
          <colspec colname="4" colwidth="70pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_data</entry>
              <entry>unsigned</entry>
              <entry>ncols*nrows*nbands</entry>
              <entry>Input image data</entry>
            </row> <row>
              <entry> </entry>
              <entry>short</entry>
            </row> <row>
              <entry>mask_data</entry>
              <entry>unsigned</entry>
              <entry>ncols*nrows</entry>
              <entry>Input mask data (if</entry>
            </row> <row>
              <entry> </entry>
              <entry>char</entry>
              <entry> </entry>
              <entry>any)</entry>
            </row> <row>
              <entry>rlblmap_data</entry>
              <entry>unsigned</entry>
              <entry>ncols*nrows</entry>
              <entry>Input region label</entry>
            </row> <row>
              <entry> </entry>
              <entry>short</entry>
              <entry> </entry>
              <entry>map data (if any) and</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>output region label</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>map data</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0255">The HSEG main program then calls the read_data( ) function with the following input variables:</p>
  <p num="p-0256"> <tables id="TABLE-US-00064" num="00064"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>proc_nsecs</entry> <entry>An int variable containing the number of sections in</entry> </row> <row> <entry> </entry> <entry>which the input data is to be processed in memory.</entry> </row> <row> <entry> </entry> <entry>Since HSEG will always be used with relatively small</entry> </row> <row> <entry> </entry> <entry>data sets, this variable is set to “1”.</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in</entry> </row> <row> <entry> </entry> <entry>the input image data.</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows in</entry> </row> <row> <entry> </entry> <entry>the input image data.</entry> </row> <row> <entry>pad_ncols</entry> <entry>An int variable containing the number of columns in</entry> </row> <row> <entry> </entry> <entry>the padded input image data. Since padding is not</entry> </row> <row> <entry> </entry> <entry>required for HSEG, pad_ncols = ncols.</entry> </row> <row> <entry>pad_nrows</entry> <entry>An int variable containing the number of rows in</entry> </row> <row> <entry> </entry> <entry>the padded input image data. Since padding is not</entry> </row> <row> <entry> </entry> <entry>required for HSEG, pad_nrows = nrows.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                </tbody>  </table> </tables> <br/>
The global variables inputf, mask_flag, rlblmap_in_flag, nbands, dtype and spatial_wght are also used as inputs by read_data( ). The following arrays are output by read_data( ):
</p>
  <p num="p-0257"> <tables id="TABLE-US-00065" num="00065"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the input image</entry> </row> <row> <entry> </entry> <entry>data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the mask data</entry> </row> <row> <entry> </entry> <entry>(if any)</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the input</entry> </row> <row> <entry> </entry> <entry>region label map data (if any).</entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the input spatial feature</entry> </row> <row> <entry> </entry> <entry>data (local image variance or standard deviation -</entry> </row> <row> <entry> </entry> <entry>if any). Since no spatial feature data has been</entry> </row> <row> <entry> </entry> <entry>generated at this point in the program, this is</entry> </row> <row> <entry> </entry> <entry>just a NULL array here.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">             </tbody>  </table> </tables> <br/>
The purpose of the read_data( ) function is to read the input data into the allocated data arrays.
</p>
  <p num="p-0258">The HSEG main program next computes image statistics. If image normalization is requested, the image sum, sum of squares and minimum values in each band are computed, along with the number of image pixels. If image normalization is not requested, only the number of image pixels is found. If image normalization is requested, the sum_stat, sumsq_stat and min_stat arrays are declared and allocated as follows:</p>
  <p num="p-0259"> <tables id="TABLE-US-00066" num="00066"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="35pt" align="left"> </colspec> <colspec colname="3" colwidth="28pt" align="left"> </colspec> <colspec colname="4" colwidth="112pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>sum_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>Sum of the input image data in each</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>band</entry> </row> <row> <entry>sumsq_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>Sum of the squares of input image</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data in each band</entry> </row> <row> <entry>min_stat</entry> <entry>double</entry> <entry>nbands</entry> <entry>The minimum input image data value</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>in each band</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">        </tbody>  </table> </tables> <br/>
If required, the sum_stat and sumsq_stat arrays are initialized to “0”, and the min_stat array is initialized to “MAXFLOAT” (the maximum floating point value on the system). Then the find_stats( ) function is called with the following parameters and array variables:
</p>
  <p num="p-0260"> <tables id="TABLE-US-00067" num="00067"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the input image</entry> </row> <row> <entry> </entry> <entry>data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the mask data (if</entry> </row> <row> <entry> </entry> <entry>any)</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in</entry> </row> <row> <entry> </entry> <entry>the input image data.</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows in the</entry> </row> <row> <entry> </entry> <entry>input image data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">          </tbody>  </table> </tables> <br/>
The global variables mask_flag, nbands and normind are also used as inputs by find_stats( ). The following arrays are output by find_stats( ):
</p>
  <p num="p-0261"> <tables id="TABLE-US-00068" num="00068"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>sum_stat</entry> <entry>A double array containing the sum of the</entry> </row> <row> <entry> </entry> <entry>(possibly masked) input image data in each</entry> </row> <row> <entry> </entry> <entry>band.</entry> </row> <row> <entry>sumsq_stat</entry> <entry>A double array containing the sum of square</entry> </row> <row> <entry> </entry> <entry>of the (possibly masked) input image data in</entry> </row> <row> <entry> </entry> <entry>each band.</entry> </row> <row> <entry>min_stat</entry> <entry>A double array containing the minimum value</entry> </row> <row> <entry> </entry> <entry>of the (possibly masked) input image data in</entry> </row> <row> <entry> </entry> <entry>each band.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">           </tbody>  </table> </tables> <br/>
The number of input pixels, npixels, is returned as the value of the function find_stats( ). If image normalization is not requested, and no mask data is provided, the find_stats( ) function simply calculates the image number of pixels as ncols*nrows and returns. If image normalization is not requested, and mask data is provided, the find_stats( ) function finds the image number of pixels by counting the number of non-zero entries in mask_data and returns. If image normalization is requested, the function find_stats( ) scans through the input image data, taking the image masking in account if provided, and finds the sum, sum of squares and minimum data values for each band, along with the image number of pixels, and then returns.
</p>
  <p num="p-0262">The HSEG main program now allocates memory for the scale and offset arrays as follows:</p>
  <p num="p-0263">
    <tables id="TABLE-US-00069" num="00069">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="42pt" align="left"> </colspec>
          <colspec colname="3" colwidth="35pt" align="left"> </colspec>
          <colspec colname="4" colwidth="91pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>scale</entry>
              <entry>float</entry>
              <entry>nbands</entry>
              <entry>Scale factors for the</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>input image data in each</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>band</entry>
            </row> <row>
              <entry>offset</entry>
              <entry>float</entry>
              <entry>nbands</entry>
              <entry>Offset values for the input</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>image data in each band</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0264">If image normalization is not requested each element of the scale array is set to “1” and each element of the offset array is set to “0. ” If image normalization is requested, the find_scale_offset( ) function is called with the following parameter and array variables:</p>
  <p num="p-0265"> <tables id="TABLE-US-00070" num="00070"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>npixels</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry>pixels in the input image data (after masking,</entry> </row> <row> <entry> </entry> <entry>if provided).</entry> </row> <row> <entry>sum_stat</entry> <entry>A double array containing the sum of the</entry> </row> <row> <entry> </entry> <entry>(possibly masked) input image data in each</entry> </row> <row> <entry> </entry> <entry>band.</entry> </row> <row> <entry>sumsq_stat</entry> <entry>A double array containing the sum of the</entry> </row> <row> <entry> </entry> <entry>squares of the (possibly masked) input image</entry> </row> <row> <entry> </entry> <entry>data in each band.</entry> </row> <row> <entry>min_stat</entry> <entry>A double array containing the minimum value</entry> </row> <row> <entry> </entry> <entry>of the (possibly masked) input image data in</entry> </row> <row> <entry> </entry> <entry>each band.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">              </tbody>  </table> </tables> <br/>
The global parameters nbands and normind are also used as inputs to find_scale_offset( ). The find_scale_offset( ) function first computes the image variance, var_stat (σ<sup>2</sup>), for each image band through the formula: 
<maths id="MATH-US-00020" num="00020"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <msup> <mi>σ</mi> <mn>2</mn> </msup> <mo>=</mo> <mrow> <mrow> <mo>(</mo> <mrow> <mrow> <mi>s</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mi>s</mi> </mrow> <mo>-</mo> <mfrac> <msup> <mi>s</mi> <mn>2</mn> </msup> <mi>N</mi> </mfrac> </mrow> <mo>)</mo> </mrow> <mo>/</mo> <mrow> <mo>(</mo> <mrow> <mi>N</mi> <mo>-</mo> <mn>1</mn> </mrow> <mo>)</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>12</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths> <br/>
where ss is sum of the squares of the data (sumsq_stat), s is the sum of the data (sum_stat) and N is the number of pixels in the data (npixels).
</p>
  <p num="p-0266">If normind==2 (“Normalize Across Bands”) is chosen, the minimum of the band minimum value (min_stat) is set as the minimum for each band, and the maximum of the band variance value (var_stat) is set as the variance value for each band. Then the values for the scale and offset arrays are calculated such that the normalized image data will have unitary variance and minimum value of “2. ” (Minimum value of “2” is used rather than “0” because certain dissimilarity criterion require the computation of logarithms, which encounter computational difficulties for arguments near the value “1”.) This is done for each band through the equations:
<br/>
scale[band]=((float) (1.0/sqrt(var_stat[band])));   (13a)
<br/>
offset[band]=((float) (2.0−(min_stat[band]/sqrt(var_stat[band]))));   (13b)
<br/>
(The normalized input image data is not calculated at this time.) The main outputs of the find_scale_offset( ) function are the scale and offset global array parameters, which are the factors required to normalize the input data as designated by the normind global parameter.
</p>
  <p num="p-0267">Next, the input variable spatial_wght is multiplied by nbands so that the spatial feature will have the same weighting and the spectral features when the initial input value of spatial_wght is 1.0. If spatial_wght&gt;0.0, the spatial_init array and the following temporary arrays are allocated:</p>
  <p num="p-0268">
    <tables id="TABLE-US-00071" num="00071">
      <tgroup align="left" colsep="0" rowsep="0" cols="4">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="35pt" align="left"> </colspec>
          <colspec colname="3" colwidth="56pt" align="left"> </colspec>
          <colspec colname="4" colwidth="63pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>Data Array</entry>
              <entry>Data Type</entry>
              <entry>Size</entry>
              <entry>To Contain:</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>spatial_init</entry>
              <entry>float</entry>
              <entry>ncols*nrows</entry>
              <entry>Spatial feature</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>data (local image</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>variance or standard</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>deviation, if any)</entry>
            </row> <row>
              <entry>input_sub</entry>
              <entry>unsigned</entry>
              <entry>3*ncols*nbands</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry>short</entry>
              <entry> </entry>
              <entry>buffer 3 lines of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>input data</entry>
            </row> <row>
              <entry>mask_sub</entry>
              <entry>unsigned</entry>
              <entry>3*ncols</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry>char</entry>
              <entry> </entry>
              <entry>buffer 3 lines of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>mask data</entry>
            </row> <row>
              <entry>spatial_init_sub</entry>
              <entry>float</entry>
              <entry>3*ncols</entry>
              <entry>Temporary array to</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>buffer 3 lines of</entry>
            </row> <row>
              <entry> </entry>
              <entry> </entry>
              <entry> </entry>
              <entry>spatial feature data</entry>
            </row> <row>
              <entry namest="1" nameend="4" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
            
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0269">If spatial_wght&gt;0.0, the maximum over spectral bands of the local spatial feature values over 3×3 pixel areas is now calculated by calling the function compute_spatial( ) with the following input arrays and parameters:</p>
  <p num="p-0270"> <tables id="TABLE-US-00072" num="00072"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the input</entry> </row> <row> <entry> </entry> <entry>image data.</entry> </row> <row> <entry>input_sub</entry> <entry>An unsigned short array to buffer 3 lines of</entry> </row> <row> <entry> </entry> <entry>input image data.</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the mask</entry> </row> <row> <entry> </entry> <entry>data (if any).</entry> </row> <row> <entry>mask_sub</entry> <entry>An unsigned char array to buffer 3 lines of mask</entry> </row> <row> <entry> </entry> <entry>data (if any).</entry> </row> <row> <entry>init_flg</entry> <entry>An int variable that is TRUE if this is the</entry> </row> <row> <entry> </entry> <entry>first section of data processed, and FALSE</entry> </row> <row> <entry> </entry> <entry>otherwise. TRUE in this case.</entry> </row> <row> <entry>last_flg</entry> <entry>An int variable that is TRUE if this is the</entry> </row> <row> <entry> </entry> <entry>last section of data processed, and FALSE</entry> </row> <row> <entry> </entry> <entry>otherwise. TRUE in this case.</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns</entry> </row> <row> <entry> </entry> <entry>in the input image data.</entry> </row> <row> <entry>maxrow</entry> <entry>An int variable containing the number of rows</entry> </row> <row> <entry> </entry> <entry>processed in this section of the input image</entry> </row> <row> <entry> </entry> <entry>data. Equal to nrows in this case.</entry> </row> <row> <entry>num_points</entry> <entry>An int variable containing the size of data</entry> </row> <row> <entry> </entry> <entry>element offset between bands of input image data.</entry> </row> <row> <entry> </entry> <entry>Equal to ncols*nrows in this case.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                        </tbody>  </table> </tables> <br/>
The global parameters mask_flag, nbands, scale, and offset are also used as inputs to compute_spatial( ). (The compute_spatial( ) function is designed to process the data in sections as required for large input data sets. Since practical processing times for HSEG and can only be obtained with small and moderately sized data sets, we assume the entire data is processed in one section in this case.) The following data array is output by compute_spatial( ):
</p>
  <p num="p-0271"> <tables id="TABLE-US-00073" num="00073"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>spatial_init</entry> <entry>A float array containing the maximum over</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>spectral bands of the spatial feature</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>calculated over a 3 × 3 window</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">     </tbody>  </table> </tables> <br/>
Note that when mask_data is provided, the value of spatial_init is set equal to MAXFLOAT (the maximum floating point value) whenever ANY data point in the 3×3 window is masked out. Also, spatial_init is set equal to MAXFLOAT for the first and last data rows and columns.
</p>
  <p num="p-0272">If spatial_wght&gt;0.0, the minimum over 3×3 pixel areas of maximum over spectral bands of the local spatial feature values over 3×3 pixel areas is found by calling the function find_min( ) with the following input arrays and parameters:</p>
  <p num="p-0273"> <tables id="TABLE-US-00074" num="00074"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="77pt" align="left"> </colspec> <colspec colname="2" colwidth="140pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the maximum over</entry> </row> <row> <entry> </entry> <entry>spectral bands of the spatial feature</entry> </row> <row> <entry> </entry> <entry>calculated over a 3 × 3 window.</entry> </row> <row> <entry>spatial_init_sub</entry> <entry>An float array to buffer 3 lines of spatial</entry> </row> <row> <entry> </entry> <entry>feature data.</entry> </row> <row> <entry>init_flg</entry> <entry>An int variable that is TRUE if this is</entry> </row> <row> <entry> </entry> <entry>the first section of data processed, and</entry> </row> <row> <entry> </entry> <entry>FALSE otherwise. TRUE in this case.</entry> </row> <row> <entry>last_flg</entry> <entry>An int variable that is TRUE if this is</entry> </row> <row> <entry> </entry> <entry>the last section of data processed, and</entry> </row> <row> <entry> </entry> <entry>FALSE otherwise. TRUE in this case.</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry>columns in the input image data.</entry> </row> <row> <entry>maxrow</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry>rows processed in this section of the input</entry> </row> <row> <entry> </entry> <entry>image data. Equal to nrows in this case.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                  </tbody>  </table> </tables> <br/>
(The find_min( ) function is designed to process the data in sections as required for large input data sets. Since practical processing times for HSEG and can only be obtained with small and moderately sized data sets, we assume the entire data is processed in one section in this case.) The following data array is output by find_min( ):
</p>
  <p num="p-0274">
    <tables id="TABLE-US-00075" num="00075">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>spatial_init</entry>
              <entry>A float array containing the minimum over a 3 × 3</entry>
            </row> <row>
              <entry> </entry>
              <entry>window of the maximum over spectral bands of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatial feature calculated over a 3 × 3 window.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0275">The maximum number of regions, max_nregions, that will be encountered in processing any subsection of data is now computed as equal to ncols*nrows.</p>
  <p num="p-0276">The HSEG main program continues by allocating various additional data arrays as listed below:</p>
  <p num="p-0277"> <tables id="TABLE-US-00076" num="00076"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="35pt" align="left"> </colspec> <colspec colname="3" colwidth="70pt" align="left"> </colspec> <colspec colname="4" colwidth="63pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>Data Array</entry> <entry>Data Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>rlabel_data</entry> <entry>unsigned</entry> <entry>max_nregions</entry> <entry>Region label</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>values</entry> </row> <row> <entry>npix_data</entry> <entry>unsigned</entry> <entry>max_nregions</entry> <entry>Region number</entry> </row> <row> <entry> </entry> <entry>int</entry> <entry> </entry> <entry>of pixels</entry> </row> <row> <entry>sum_data</entry> <entry>double</entry> <entry>max_nregions*nbands</entry> <entry>Region sum of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>normalized input</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data values in</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>each spectral</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>band</entry> </row> <row> <entry>sumsq_data</entry> <entry>double</entry> <entry>max_nregions*nbands</entry> <entry>Region sum of the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>square of the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>normalized input</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data values in</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>each band (if</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>0.0)</entry> </row> <row> <entry>spatial_data</entry> <entry>double</entry> <entry>max_nregions</entry> <entry>Region spatial</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>feature</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>value (if</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>0.0)</entry> </row> <row> <entry>nghbr_mask</entry> <entry>unsigned</entry> <entry>max_nregions<sup>2</sup> </entry> <entry>Region adjacency</entry> </row> <row> <entry> </entry> <entry>char</entry> <entry> </entry> <entry>mask</entry> </row> <row> <entry>nghbr_tmp</entry> <entry>unsigned</entry> <entry>max_nregions</entry> <entry>Temporary region</entry> </row> <row> <entry> </entry> <entry>char</entry> <entry> </entry> <entry>adjacency mask</entry> </row> <row> <entry>relabel_list</entry> <entry>unsigned</entry> <entry>2*max_nregions</entry> <entry>Region label</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>relabelings</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(renumberings)</entry> </row> <row> <entry>region_store</entry> <entry>reg_struct</entry> <entry>max_nregions</entry> <entry>Structure con-</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>taining</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>information about</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>each region</entry> </row> <row> <entry>region_list</entry> <entry>reg_list</entry> <entry>max_nregions + 1</entry> <entry>Structure for</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>linking</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region_store</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>structures together</entry> </row> <row> <entry>sort_store</entry> <entry>reg_list</entry> <entry>max_nregions</entry> <entry>Structure for</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>ordered linking of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region_store</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>structures</entry> </row> <row> <entry>nbsort_store</entry> <entry>reg_list</entry> <entry>max_nregions</entry> <entry>Structure for</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>ordered</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>linking of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region_store</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>structures</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>    </thead> <tbody valign="top">                                               </tbody>  </table> </tables> <br/>
The reg_struct (REGION) and reg_list (R_LIST) structures listed above have the following declarations:
</p>
  <p num="p-0278"> <tables id="TABLE-US-00077" num="00077"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>typedef struct REGION</entry> </row> <row> <entry> </entry> <entry>{</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="42pt" align="left"> </colspec> <colspec colname="1" colwidth="98pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>unsigned short</entry> <entry> label;</entry> </row> <row> <entry> </entry> <entry>struct REGION</entry> <entry>*bnghbr;</entry> </row> <row> <entry> </entry> <entry>float</entry> <entry> bncomp;</entry> </row> <row> <entry> </entry> <entry>struct REGION</entry> <entry>*bregion;</entry> </row> <row> <entry> </entry> <entry>float</entry> <entry> brcomp;</entry> </row> <row> <entry> </entry> <entry>struct REGION</entry> <entry>*mgreg;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>} reg_struct;</entry> </row> <row> <entry> </entry> <entry>typedef struct R_LIST</entry> </row> <row> <entry> </entry> <entry>{</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="42pt" align="left"> </colspec> <colspec colname="1" colwidth="98pt" align="left"> </colspec> <colspec colname="2" colwidth="77pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>struct REGION</entry> <entry>*link;</entry> </row> <row> <entry> </entry> <entry>struct R_LIST</entry> <entry>*next;</entry> </row> <row> <entry> </entry> <entry>unsigned char</entry> <entry> active flag;</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>} reg_list;</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">   </tbody>  <tbody valign="top">       </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The members of the reg_struct (REGION) structure are:
</p>
  <p num="p-0279"> <tables id="TABLE-US-00078" num="00078"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>label</entry> <entry>region label</entry> </row> <row> <entry>bnghbr</entry> <entry>pointer to structure containing information</entry> </row> <row> <entry> </entry> <entry>for the most similar neighboring region</entry> </row> <row> <entry>bncomp</entry> <entry>dissimilarity value between the region and</entry> </row> <row> <entry> </entry> <entry>the most similar neighboring region</entry> </row> <row> <entry>bregion</entry> <entry>pointer to structure containing information</entry> </row> <row> <entry> </entry> <entry>for the most similar non-neighboring region</entry> </row> <row> <entry>brcomp</entry> <entry>dissimilarity value between the region and</entry> </row> <row> <entry> </entry> <entry>the most similar non-neighboring region</entry> </row> <row> <entry>mgreg</entry> <entry>if the region was merged into another region,</entry> </row> <row> <entry> </entry> <entry>this is a pointer to the structure containing</entry> </row> <row> <entry> </entry> <entry>information for the region this region was merge with</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">              </tbody>  </table> </tables> <br/>
The members of the reg_list (R_LIST) structure are:
</p>
  <p num="p-0280"> <tables id="TABLE-US-00079" num="00079"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>link</entry> <entry>pointer to REGION structure containing</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>information for a particular region</entry> </row> <row> <entry> </entry> <entry>next</entry> <entry>pointer to R_LIST structure for next region</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>in the list</entry> </row> <row> <entry> </entry> <entry>active_flag</entry> <entry>TRUE only if the R_LIST element is valid.</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">       </tbody>  </table> </tables> <br/>
Upon declaration, the link members of the region_list structure variable are initialized to point one after the other to the elements of the region_store structure (i.e., region_list[j].link=&amp;region_store[j]), and the next members of the region_list structure variable are initialized to point to the next member of the region_list structure (i.e., region_list[j].next=&amp;region_list[j+1]). The elements region_list[max_nregions].link and region_list[max_nregions].next are set to “NULL” initially. All of the active_flag members of region_list are set initially to “FALSE.”
</p>
  <p num="p-0281">The function region_data_init( ) is now called with the following input variable and array data:</p>
  <p num="p-0282"> <tables id="TABLE-US-00080" num="00080"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="140pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>input_data</entry> <entry>An unsigned short array containing the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>input image data</entry> </row> <row> <entry> </entry> <entry>mask_data</entry> <entry>An unsigned char array containing the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>mask data (if any)</entry> </row> <row> <entry> </entry> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>input region label map data (if any).</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>(Will be overwritten by the output region</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>label map data.)</entry> </row> <row> <entry> </entry> <entry>spatial_init</entry> <entry>A float array containing the input spatial</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>feature data (local image variance or</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>standard deviation - if any)</entry> </row> <row> <entry> </entry> <entry>ncols</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>columns in the input image data</entry> </row> <row> <entry> </entry> <entry>nrows</entry> <entry>An int variable containing the number of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>rows in the input image data</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                 </tbody>  </table> </tables> <br/>
The global variables mask_flag, rlblmap_in_flag, nbands, max_nregions, scale, offset, maxmdir, spatial_wght and spatial_type are also used as inputs by region_data_init( ). The following variables and arrays are output by region_data_init( ):
</p>
  <p num="p-0283"> <tables id="TABLE-US-00081" num="00081"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the initial number</entry> </row> <row> <entry> </entry> <entry>of regions in the section of data processed.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the initial</entry> </row> <row> <entry> </entry> <entry>output region label map. This region label map</entry> </row> <row> <entry> </entry> <entry>specifies the initial spatial distribution of</entry> </row> <row> <entry> </entry> <entry>the regions.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region</entry> </row> <row> <entry> </entry> <entry>number of pixels list stored as a vector. The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the number of</entry> </row> <row> <entry> </entry> <entry>pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels</entry> </row> <row> <entry> </entry> <entry>in each region. Element j + nregions*b is the</entry> </row> <row> <entry> </entry> <entry>sum value for region j + 1 and band b (first band</entry> </row> <row> <entry> </entry> <entry>is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>(Actually contains values only if spatial_wght &gt; 0.0.)</entry> </row> <row> <entry> </entry> <entry>The j<sup>th</sup> element of the vector is the spatial feature</entry> </row> <row> <entry> </entry> <entry>value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if and</entry> </row> <row> <entry> </entry> <entry>only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                      </tbody>  </table> </tables> <br/>
The array rlabel_data is also passed to the function region_data_init( ) for use as work space. See a later section for a functional description of the region_data_init( ) function. The purpose of the region_data_init( ) function is to initialize the variables and arrays output by the region_data_init( ) function based on the input variable and array data.
</p>
  <p num="p-0284">After the call to region_data_init( ) is completed, the following parameters are set: init_flg=TRUE, onregions=nregions (as output from region_data_init( )) and cvnbregs=chkregions (note that chkregions is a user set parameter). If nregions&lt;=chkregions, the calls below to the functions lhseg( ) and read_region_list( ) are skipped and, if nregions&gt;2, the program proceeds to call the function lhseg( ) (see below). Otherwise, call the function lhseg( ) with the following input variable and array data:</p>
  <p num="p-0285"> <tables id="TABLE-US-00082" num="00082"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>init_flag</entry> <entry>An int variable which indicates whether or not</entry> </row> <row> <entry> </entry> <entry>the region_list has just been initialized (in</entry> </row> <row> <entry> </entry> <entry>this case init_flag = TRUE).</entry> </row> <row> <entry>onregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>existing when lhseg( ) is initially called.</entry> </row> <row> <entry>cvnbregs</entry> <entry>An int variable indicating the number of regions</entry> </row> <row> <entry> </entry> <entry>at which that this call to lhseg( ) will converge</entry> </row> <row> <entry> </entry> <entry>(exit).</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number</entry> </row> <row> <entry> </entry> <entry>of pixels list stored as a vector. The j<sup>th</sup> element</entry> </row> <row> <entry> </entry> <entry>of the vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.) The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the spatial feature</entry> </row> <row> <entry> </entry> <entry>value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if</entry> </row> <row> <entry> </entry> <entry>and only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                      </tbody>  </table> </tables> <br/>
The global variables nbands, max_nregions, simcrit, extmean, spclust, spatial_wght, and spatial_type are also used as inputs to lhseg( ). The following variables and arrays are modified and output by lhseg( ):
</p>
  <p num="p-0286"> <tables id="TABLE-US-00083" num="00083"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>in the section of data processed.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region</entry> </row> <row> <entry> </entry> <entry>number of pixels list stored as a vector. The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the number of pixels</entry> </row> <row> <entry> </entry> <entry>in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.) The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the spatial feature</entry> </row> <row> <entry> </entry> <entry>value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if</entry> </row> <row> <entry> </entry> <entry>and only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to</entry> </row> <row> <entry> </entry> <entry>a sequence of reg_struct (REGION) structure</entry> </row> <row> <entry> </entry> <entry>elements containing label and comparative</entry> </row> <row> <entry> </entry> <entry>information about each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                 </tbody>  </table> </tables> <br/>
The arrays sort_store, and nbsort_store are also passed to the lhseg( ) function to use as work space. See a later section for a functional description of the lhseg( ) function. The purpose of the lhseg( ) function is to perform multiple iterations of region growing intermixed with spectral clustering (if requested) until the number of regions becomes less than or equal to cvnbregs (in this case, chkregions).
</p>
  <p num="p-0287">After the lhseg( ) function exits, the parameter init_flg is set to FALSE, and the function read_region_list( ) is called with the following input variable and array data:</p>
  <p num="p-0288"> <tables id="TABLE-US-00084" num="00084"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>in the section of data processed.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number</entry> </row> <row> <entry> </entry> <entry>of pixels list stored as a vector. The j<sup>th</sup> element</entry> </row> <row> <entry> </entry> <entry>of the vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.) The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the spatial feature</entry> </row> <row> <entry> </entry> <entry>value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if</entry> </row> <row> <entry> </entry> <entry>and only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to</entry> </row> <row> <entry> </entry> <entry>a sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                </tbody>  </table> </tables> <br/>
The global variables nbands, max_regions and spatial_wght are also used as input by read_region_list( ). The following variables and arrays are modified and/or output by read_region_list( ):
</p>
  <p num="p-0289"> <tables id="TABLE-US-00085" num="00085"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number</entry> </row> <row> <entry> </entry> <entry>of pixels list stored as a vector. The j<sup>th</sup> element</entry> </row> <row> <entry> </entry> <entry>of the vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial feature</entry> </row> <row> <entry> </entry> <entry>value list stored as a vector. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th</sup> element</entry> </row> <row> <entry> </entry> <entry>of the vector is the spatial feature value for</entry> </row> <row> <entry> </entry> <entry>region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if</entry> </row> <row> <entry> </entry> <entry>and only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to</entry> </row> <row> <entry> </entry> <entry>a sequence of reg_struct (REGION) structure</entry> </row> <row> <entry> </entry> <entry>elements containing label and comparative</entry> </row> <row> <entry> </entry> <entry>information about each region.</entry> </row> <row> <entry>relabel_list</entry> <entry>An unsigned short array consisting of pairs of</entry> </row> <row> <entry> </entry> <entry>region labelings representing a renumbering of</entry> </row> <row> <entry> </entry> <entry>the region map labeling.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                 </tbody>  </table> </tables> <br/>
The array nghbr_tmp is also passed to the read_region_list( ) function for use as work space. The read_region_list( ) function finds a renumbering (relabel_list) of the current region map labeling into the smallest possible range of labels starting at label “1, ” and adjusts the various data arrays and structures accordingly (npix_data, sum_data, nghbr_mask, region_list, and, if necessary, sumsq_data and spatial_data).
</p>
  <p num="p-0290">After the read_region_list( ) function exits, the variable nelements is found as the number of non-zero elements in the relabel_list array output by read_region_list( ), and the function update_rlblmap( ) is called with the following input variable and array data:</p>
  <p num="p-0291"> <tables id="TABLE-US-00086" num="00086"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns</entry> </row> <row> <entry> </entry> <entry>in the input image data</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows</entry> </row> <row> <entry> </entry> <entry>in the input image data</entry> </row> <row> <entry>nelements</entry> <entry>An int variable containing the number of non-zero</entry> </row> <row> <entry> </entry> <entry>elements in the relabel_list array</entry> </row> <row> <entry>relabel_list</entry> <entry>An unsigned short array consisting of pairs of</entry> </row> <row> <entry> </entry> <entry>region labelings representing a renumbering of</entry> </row> <row> <entry> </entry> <entry>the region map labeling.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the region</entry> </row> <row> <entry> </entry> <entry>label map data as it existed prior to the call</entry> </row> <row> <entry> </entry> <entry>to lhseg( ).</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">              </tbody>  </table> </tables> <br/>
The following data array is modified by update_rlblmap( ):
</p>
  <p num="p-0292"> <tables id="TABLE-US-00087" num="00087"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="70pt" align="left"> </colspec> <colspec colname="2" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the region</entry> </row> <row> <entry> </entry> <entry>label map data renumbered according to</entry> </row> <row> <entry> </entry> <entry>relabel_list.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">     </tbody>  </table> </tables> <br/>
The update_rlblmap( ) function renumbers the rlblmap_data array according to the input relabel_list array. This updates the rlblmap_data to reflect the merges performed by the call to lhseg( ) and the compacting of the region labeling representation performed by the function read_region_list( ).
</p>
  <p num="p-0293">After update_rlblmap( ) exits, the variable cvnbregs is set equal to 2. Then if cvnbregs&gt;nregions, the function fhseg( ) is called with the following input variable and array data:</p>
  <p num="p-0294"> <tables id="TABLE-US-00088" num="00088"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>init_flag</entry> <entry>An int variable which is TRUE if the region_list</entry> </row> <row> <entry> </entry> <entry>has just been initialized and FALSE otherwise.</entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the input</entry> </row> <row> <entry> </entry> <entry>image data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the mask data</entry> </row> <row> <entry> </entry> <entry>(if any)</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the region</entry> </row> <row> <entry> </entry> <entry>label map. This region label map specifies the</entry> </row> <row> <entry> </entry> <entry>initial spatial distribution of the regions.</entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the input spatial</entry> </row> <row> <entry> </entry> <entry>feature data (local image variance or standard</entry> </row> <row> <entry> </entry> <entry>deviation - if any)</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns</entry> </row> <row> <entry> </entry> <entry>in the input image data</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows in</entry> </row> <row> <entry> </entry> <entry>the input image data</entry> </row> <row> <entry>onregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>existing when lhseg( ) is initially called.</entry> </row> <row> <entry>cvnbregs</entry> <entry>An int variable indicating the number of regions</entry> </row> <row> <entry> </entry> <entry>at which that this call to fhseg( ) will converge</entry> </row> <row> <entry> </entry> <entry>(exit).</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number</entry> </row> <row> <entry> </entry> <entry>of pixels list stored as a vector. The j<sup>th </sup>element</entry> </row> <row> <entry> </entry> <entry>of the vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square</entry> </row> <row> <entry> </entry> <entry>of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values</entry> </row> <row> <entry> </entry> <entry>only if spatial_wght &gt; 0.0.) Element j + nregions*b</entry> </row> <row> <entry> </entry> <entry>is the sum square value for region j + 1 and band b</entry> </row> <row> <entry> </entry> <entry>(first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.) The</entry> </row> <row> <entry> </entry> <entry>j<sup>th</sup> element of the vector is the spatial feature</entry> </row> <row> <entry> </entry> <entry>value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating</entry> </row> <row> <entry> </entry> <entry>whether or not a pair of regions are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent (i.e., neighbors). The value of the mask</entry> </row> <row> <entry> </entry> <entry>at array element j + max_nregions*k is TRUE if</entry> </row> <row> <entry> </entry> <entry>and only if regions j + 1 and k + 1 are spatially</entry> </row> <row> <entry> </entry> <entry>adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                                   </tbody>  </table> </tables> <br/>
The global variables mask_flag, regmerges_flag, nbands, scale, offset, simcrit, extmean, spclust, spatial_wght, spatial_type, convfact, max_regions, tmpdir and tempfile are also used as inputs to fhseg( ). The following variable is returned by fhseg( ):
</p>
  <p num="p-0295"> <tables id="TABLE-US-00089" num="00089"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nslevels</entry> <entry>An int variable containing the number of hierarchical</entry> </row> <row> <entry> </entry> <entry>segmentation levels found by the fhseg( ) function.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The arrays rlabel_data, sort_store, and nbsort_store as also passed to the fhseg( ) functions for use as work space. The fhseg( ) function also outputs data to a number of files. These data output are the region number of pixels list (npix_data), the region means list, the region criterion value list, and, if requested, the region merges list for the iterations corresponding to the detected natural convergence points. If the region merges list is requested, the region label map data (rlblmap_data) is output only for the first detected natural convergence point. Otherwise the region label map data is output for all the detected natural convergence points.
</p>
  <p num="p-0296">See a later section for a functional description of the fhseg( ) function. The purpose of the fhseg( ) function is to perform multiple iterations of region growing intermixed with spectral clustering (if requested) until the number of regions becomes less than or equal to cvnbregs (in this case, 2), and output segmentation results when natural convergence points are detected.</p>
  <p num="p-0297">The HSEG main program is now nearly finished. After the fhseg( ) function exits, the program writes into a output parameter file, HSEG0000.oparam, the number of hierarchical segmentation levels, nslevels, and the number of regions that existed prior to the call to the fhseg( ) function. These are the values that define the dimensions of the output files. Finally, the output files rlblmap, rnpixlist, regmerges (if requested), rmeanlist (if requested), and rcvlist (if requested) are created by concatenating together the corresponding output files from fhseg( ) for all the hierarchical segmentation levels. The output log_file is now closed and the program exits.</p>
  <p num="p-0298">Functional Description of the RHSEG Main Program: The RHSEG main program initially determines the name of the parameter file from the command line input, and reads in the parameters from the file using the function read_param( ). If a prefix for the temporary filenames in not provided in the parameter file, the program generates a character string to used at a prefix for file names for temporary files required by the program. The “C” library function “tempnam” is used for this purpose. For the discussion below, this prefix is assumed to be “RHSEG0000.”</p>
  <p num="p-0299">At this point the RHSEG main program opens the log file and outputs to it the program parameters using the function print_param( ). In addition to the parameters declared as external variables for the HSEG program, the following parameters as declared as external variables for the RHSEG program:</p>
  <p num="p-0300">
    <tables id="TABLE-US-00090" num="00090">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>rnb_levels</entry>
              <entry>An int variable containing the total number of</entry>
            </row> <row>
              <entry> </entry>
              <entry>recursive levels to be utilized</entry>
            </row> <row>
              <entry>minregions</entry>
              <entry>An int variable containing the number of regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>for convergence in the recursive stages</entry>
            </row> <row>
              <entry>sub_ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry>of input data to be processed at the highest level</entry>
            </row> <row>
              <entry> </entry>
              <entry>of recursion</entry>
            </row> <row>
              <entry>sub_nrows</entry>
              <entry>An int variable containing the number of rows of</entry>
            </row> <row>
              <entry> </entry>
              <entry>input data to be processed at the highest level</entry>
            </row> <row>
              <entry> </entry>
              <entry>of recursion</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0301">The program next sets the number of columns (sub_ncols) and number of rows (sub_nrows) of the image data sections to be processed at the highest level of recursion, based on the value of rnb_levels. If the full image size (ncols by nrows) is not an integer multiple of sub_ncols by sub_nrows, the values of pad_ncols (&gt;ncols) and pad_nrows (&gt;nrows) are set to be the number of columns and rows the full image would have to have in order to be an integer multiple size of the subimage size at the highest level of recursion. If the image size is already an integer multiple size of the subimage size at the highest level or recursion, pad_ncols and pad_nrows are set to ncols and nrows, respectively. If sub_ncols=pad_ncols, this particular run of RHSEG degenerates to a run of HSEG (see above).</p>
  <p num="p-0302">The RHSEG main program now continues in the same manner as the HSEG main program by reading in the input data. If an input data mask is not provided and ncols!=pad_ncols, the mask_data array is initialized to all “1&#39;s” (TRUE) for upper left ncols*nrows section of the array, and mask_flag is set to TRUE. If ncols!=pad_ncols, the mask_data array and all other input arrays are padded with “0” values for columns greater than ncols and rows greater than nrows.</p>
  <p num="p-0303">The RHSEG main program continues on as in the HSEG main program by finding npixels and values for the scale and offset arrays with calls to the find_stats( ) and find_scale_offset( ) functions. If spatial_wght&gt;0.0, calls are also made to the compute_spatial( ) and find_min( ) functions.</p>
  <p num="p-0304">The maximum number of regions, max_nregions, that will be encountered in processing any subsection of data is now computed. This is the maximum of 4*minregions and sub_ncols*sub_nrows.</p>
  <p num="p-0305">The various data arrays are now allocated as for the HSEG main program, except that pad_ncols and pad_nrows replaces ncols and nrows in the allocations. Also, the arrays npix_data, sum_data, sumsq_data, and spatial_data are allocated with size rnb_levels*max_nregions rather than just max_nregions. In the RHSEG main program, the following additional data arrays are allocated:</p>
  <p num="p-0306"> <tables id="TABLE-US-00091" num="00091"> <tgroup align="left" colsep="0" rowsep="0" cols="4"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="42pt" align="left"> </colspec> <colspec colname="3" colwidth="63pt" align="left"> </colspec> <colspec colname="4" colwidth="49pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>Data</entry> <entry> </entry> <entry> </entry> </row> <row> <entry>Data Array</entry> <entry>Type</entry> <entry>Size</entry> <entry>To Contain:</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <row> <entry>input_sub</entry> <entry>unsigned</entry> <entry>(pad_ncols*pad<sub>—</sub> </entry> <entry>Subset of</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry>nrows*nbands)/2</entry> <entry>input image</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data</entry> </row> <row> <entry>mask_sub</entry> <entry>unsigned</entry> <entry>(pad_ncols*pad<sub>—</sub> </entry> <entry>Subset of</entry> </row> <row> <entry> </entry> <entry>char</entry> <entry>nrows)/2</entry> <entry>input mask</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data (if any)</entry> </row> <row> <entry>rlblmap_sub</entry> <entry>unsigned</entry> <entry>(pad_ncols*pad<sub>—</sub> </entry> <entry>Subset of</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry>nrows)/2</entry> <entry>input region</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>label map</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>data (if any)</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>and output</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region label</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>map data</entry> </row> <row> <entry>spatial_init_sub</entry> <entry>float</entry> <entry>(pad_ncols*pad<sub>—</sub> </entry> <entry>Subset of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry>nrows)/2</entry> <entry>input spatial</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>feature data</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>(local image</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>variance or</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>standard</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>deviation, if</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>any)</entry> </row> <row> <entry>nghbr_sub</entry> <entry>unsigned</entry> <entry>(rnb_levels − 1)*</entry> <entry>Region</entry> </row> <row> <entry> </entry> <entry>char</entry> <entry>max_nregions<sup>2</sup> </entry> <entry>adjacency</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>mask at other</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>levels of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>recursion</entry> </row> <row> <entry>rlblmap_4cols</entry> <entry>unsigned</entry> <entry>4*pad_nrows</entry> <entry>Selected four</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>columns of</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>region label</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>map data</entry> </row> <row> <entry>rlblmap_4rows</entry> <entry>unsigned</entry> <entry>4*pad_ncols</entry> <entry>Selected four</entry> </row> <row> <entry> </entry> <entry>short</entry> <entry> </entry> <entry>rows of region</entry> </row> <row> <entry> </entry> <entry> </entry> <entry> </entry> <entry>label map data</entry> </row> <row> <entry namest="1" nameend="4" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>     </thead> <tbody valign="top">                                   </tbody>  </table> </tables> <br/>
The function lrhseg( ) is now called with the following input variable and array data:
</p>
  <p num="p-0307">
    <tables id="TABLE-US-00092" num="00092">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="63pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_data</entry>
              <entry>An unsigned short array containing the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>section of input image data</entry>
            </row> <row>
              <entry>mask_data</entry>
              <entry>An unsigned char array containing the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>section of mask data (if any)</entry>
            </row> <row>
              <entry>rlblmap_data</entry>
              <entry>An unsigned short array containing the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>section of input region label map data (if any).</entry>
            </row> <row>
              <entry> </entry>
              <entry>(Will be overwritten by the output region label</entry>
            </row> <row>
              <entry> </entry>
              <entry>map data.)</entry>
            </row> <row>
              <entry>spatial_init</entry>
              <entry>A float array containing the current section of</entry>
            </row> <row>
              <entry> </entry>
              <entry>input spatial feature data (local image variance</entry>
            </row> <row>
              <entry> </entry>
              <entry>or standard deviation - if any)</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the current section of input image data (initially</entry>
            </row> <row>
              <entry> </entry>
              <entry>pad_ncols)</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in</entry>
            </row> <row>
              <entry> </entry>
              <entry>the current section of input image data (initially</entry>
            </row> <row>
              <entry> </entry>
              <entry>pad_nrows)</entry>
            </row> <row>
              <entry>level</entry>
              <entry>An int variable containing the value of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>level of recursion (initially equal to 1)</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0308">The global variables mask_flag, rlblmap_in_flag, nbands, sub_ncols, sub_nrows, max_nregions, scale, offset, maxmdir, simcrit, extmean, spclust, spatial_wght, spatial_type, rnb_levels and minregions are also used as inputs by lrhseg( ). Certain variables and arrays are output by lrhseg( ). They are as follows:</p>
  <p num="p-0309"> <tables id="TABLE-US-00093" num="00093"> <tgroup align="left" colsep="0" rowsep="0" cols="3"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="147pt" align="left"> </colspec> <colspec colname="3" colwidth="14pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="3" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions</entry> <entry> </entry> </row> <row> <entry> </entry> <entry>in the segmentation of the section of data</entry> </row> <row> <entry> </entry> <entry>processed.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the output</entry> </row> <row> <entry> </entry> <entry>region label map for the current section of data.</entry> </row> <row> <entry> </entry> <entry>This region label map specifies the spatial</entry> </row> <row> <entry> </entry> <entry>distribution of the regions.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the current</entry> </row> <row> <entry> </entry> <entry>region number of pixels list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>The j<sup>th</sup> element of the vector is the number of</entry> </row> <row> <entry> </entry> <entry>pixels in region j + 1.</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry>sum_data</entry> <entry>A double array containing the current sum of</entry> </row> <row> <entry> </entry> <entry>the normalized input data values over all pixels</entry> </row> <row> <entry> </entry> <entry>in each region. Element j + nregions*b is the sum</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band is</entry> </row> <row> <entry> </entry> <entry>band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the current sum of the</entry> </row> <row> <entry> </entry> <entry>square of the normalized input data values over</entry> </row> <row> <entry> </entry> <entry>all pixels in each region. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) Element</entry> </row> <row> <entry> </entry> <entry>j + nregions*b is the sum square value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the current region</entry> </row> <row> <entry> </entry> <entry>spatial feature value list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>(Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) The j<sup>th</sup> element of the vector is the</entry> </row> <row> <entry> </entry> <entry>spatial feature value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating,</entry> </row> <row> <entry> </entry> <entry>for the current section of data, whether or not</entry> </row> <row> <entry> </entry> <entry>a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array</entry> </row> <row> <entry> </entry> <entry>element j + max_nregions*k is TRUE if and only</entry> </row> <row> <entry> </entry> <entry>if regions j + 1 and k + 1 are spatially adjacent.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">            </tbody>  <tbody valign="top">                        </tbody>  </table> </tables> <br/>
Other data arrays are passed into lrhseg( ) for use as work space. These are input_sub, mask_sub, rlblmap_sub, spatial_init_sub, rlabel_data, region_list, relabel_list, nghbr_sub, nghbr_tmp, rlblmap _<b>4</b>cols, rlblmap_<b>4</b> rows, sort_store and nbsort_store.
</p>
  <p num="p-0310">The purpose of the lrhseg( ) function is to divide up the input data into four equal quadrants and to call the function recur_hseg( ) for each quadrant. The results from recur_hseg( ) are assembled together by lrhseg( ) and returned to the calling function. The internal operations of the function lrhseg( ) are described in a later section.</p>
  <p num="p-0311">The arrays rlblmap_<b>4</b>cols and rlblmap_<b>4</b>rows are now loaded with values from rlblmap_data . The array rlblmap_<b>4</b>cols contains the first, middle two and last columns from rlblmap_data, and the array rlblmap_<b>4</b>rows contains the first, middle two and last rows from rlblmap_data. The function update_nghbr_mask( ) is now called with the following input variables and data:</p>
  <p num="p-0312">
    <tables id="TABLE-US-00094" num="00094">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry>nregions</entry>
              <entry>An int variable containing the current value</entry>
            </row> <row>
              <entry> </entry>
              <entry>of the number of regions is the current section</entry>
            </row> <row>
              <entry> </entry>
              <entry>of segmented data</entry>
            </row> <row>
              <entry>rlblmap_4cols</entry>
              <entry>An unsigned short array containing the first,</entry>
            </row> <row>
              <entry> </entry>
              <entry>middle two and last columns of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>region label map data.</entry>
            </row> <row>
              <entry>rlblmap_4rows</entry>
              <entry>An unsigned short array containing the first,</entry>
            </row> <row>
              <entry> </entry>
              <entry>middle two and last rows of the current region</entry>
            </row> <row>
              <entry> </entry>
              <entry>label map data.</entry>
            </row> <row>
              <entry>nghbr_mask</entry>
              <entry>An unsigned char array of numbers designating,</entry>
            </row> <row>
              <entry> </entry>
              <entry>for the current section of data, whether or not</entry>
            </row> <row>
              <entry> </entry>
              <entry>a pair of regions are spatially adjacent (i.e.,</entry>
            </row> <row>
              <entry> </entry>
              <entry>neighbors). The value of the mask at array element</entry>
            </row> <row>
              <entry> </entry>
              <entry>j + max_nregions*k is TRUE if and only if regions</entry>
            </row> <row>
              <entry> </entry>
              <entry>j + 1 and k + 1 are spatially adjacent.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0313">The function update_nghbr_mask( ) modifies the input nghbr_mask array so that it includes the neighbor relationship across the middle two columns and rows of the current region label map. The nghbr_mask array had been previously lacking this information. See a later section for a functional description of update_nghbr_mask( ).</p>
  <p num="p-0314">The function region_list_init( ) is now called with the following input variable:</p>
  <p num="p-0315"> <tables id="TABLE-US-00095" num="00095"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>in the current section of segmented data</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The following data array is output by region_list_init( ):
</p>
  <p num="p-0316"> <tables id="TABLE-US-00096" num="00096"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">      </tbody>  </table> </tables> <br/>
See a later section for a functional description of the region_list_init( ) function. The purpose of the region_list_init( ) function is to initialize the region_list structure.
</p>
  <p num="p-0317">After the call to region_list_list( ) is completed, the following parameters are set: init_flg=TRUE, onregions=nregions and cvnbregs=chkregions (note that chkregions is a user set parameter). As in the HSEG program, if nregions&lt;=chkregions, the calls to the functions lhseg( ) and read_region_list( ) are skipped and, if nregions&gt;2, the program proceeds to call the function fhseg( ). Otherwise, call the function lhseg( ) is called in exactly same manner it was called in the HSEG program. From this point the RHSEG program proceeds in exactly the same manner as the HSEG program.</p>
  <p num="p-0318">Functional description of the region_data_init( ) function: The first operation performed by this function is to initialize the region label map, rlblmap_data . If input region label map data is provided, the maximum label, max_reglbl, in the input region label map data is found, and the elements of rlblmap_data with input value “0, ” that are at non-masked out locations (according to mask_data), are sequentially given unique labels higher than max_reglbl. The region label map is then renumbered so that the regions have unique labels running from 1 to nregions (the number of regions in this section of data). If input region label map data is not provided, each non-masked out location in rlblmap_data is given a unique label, running from 1 to nregions.</p>
  <p num="p-0319">Next the first nregions elements of region_list, and the reg_struct structures linked to these elements of region_list, are initialized such that the active_flag is set to “TRUE,” the label&#39;s run sequentially from 1 to nregions, the pointers bnghbr, bregion and mgreg are set to “NULL,” and the values bncomp and brcomp are set to “MAXFLOAT” (the maximum floating point value). In addition, the first nregions elements of the npix_data (and spatial_data, if spatial_wght&gt;0.0) array(s) are initialized to 0.0 and the first nregions of the nbands sum_data (and sumsq_data, if spatial_wght&gt;0.0) array(s) are initialized to 0.0.</p>
  <p num="p-0320">Next the npix_data, sum_data, spatial_data (if spatial_wght&gt;0.0), and sumsq_data (if spatial_wght&gt;0.0) are calculated by scanning through rlblmap_data, input_data, spatial_init (if spatial_wght&gt;0.0) and mask_data (if provided). The value of npix_data[j] is the number of pixels in region j+1 and the value of sum data[b+j*nbands] is the sum of the normalized input data for band b and region j+1. If (spatial_wght&gt;0.0), the value of spatial_data[j] is the sum of the input spatial_init values for region j+1 and the value of sumsq_data[b+j*nbands] is the sum of the squares of the normalized input data for band b and region j+1.</p>
  <p num="p-0321">In the above initialization, if spatial_wght&gt;0.0, spatial_data is set to be the sum of the input spatial_init values in each region. However, this is not the correct final value for spatial_data. If npix_data[j]≧9, spatial_data[j] should be the maximum over the spectral bands of the variance or standard deviation of region j+1, depending on the user specified value of the spatial_type flag. If npix_data[j]&lt;9, spatial_data[j] should be a weighted average of the maximum over the spectral bands of the variance or standard deviation of region j+1 with the average spatial_init values for the pixels in the region.</p>
  <p num="p-0322">For spatial_wght&gt;0.0, npix_data[j]≧9, and spatial_type==1 (“Variance”), spatial_data[j] for region j+1 is calculated as follows (see also Equations (9) and (10) above): 
<maths id="MATH-US-00021" num="00021"> <math overflow="scroll"> <mtable> <mtr> <mtd> <mrow> <mrow> <mi>var_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mi>j</mi> <mo>]</mo> </mrow> </mrow> <mo>=</mo> <mrow> <munder> <mi>max</mi> <mi>b</mi> </munder> <mo>⁢</mo> <mrow> <mo>{</mo> <mfrac> <mrow> <mo>(</mo> <mrow> <mrow> <mi>sumsq</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mrow> <mi>b</mi> <mo>+</mo> <mi>jB</mi> </mrow> <mo>]</mo> </mrow> </mrow> </mrow> <mo>-</mo> <mfrac> <mtable> <mtr> <mtd> <mrow> <mrow> <mi>sum_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mrow> <mi>b</mi> <mo>+</mo> <mi>jB</mi> </mrow> <mo>]</mo> </mrow> </mrow> <mo>*</mo> </mrow> </mtd> </mtr> <mtr> <mtd> <mrow> <mi>sum_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mrow> <mi>b</mi> <mo>+</mo> <mi>jB</mi> </mrow> <mo>]</mo> </mrow> </mrow> </mtd> </mtr> </mtable> <mrow> <mi>npix</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mi>j</mi> <mo>]</mo> </mrow> </mrow> </mrow> </mfrac> </mrow> </mrow> <mrow> <mrow> <mi>npix</mi> <mo>⁢</mo> <mstyle> <mtext> </mtext> </mstyle> <mo>⁢</mo> <mrow> <mi>_data</mi> <mo>⁡</mo> <mrow> <mo>[</mo> <mi>j</mi> <mo>]</mo> </mrow> </mrow> </mrow> <mo>-</mo> <mn>1</mn> </mrow> </mfrac> <mo>}</mo> </mrow> </mrow> </mrow> </mtd> <mtd> <mrow> <mo>(</mo> <mn>14</mn> <mo>)</mo> </mrow> </mtd> </mtr> </mtable> </math> </maths>
<br/>
where B is the number of spectral bands. If spatial_type==2 (“Standard Deviation”), the square root is taken before the band maximum is found. Note that Equation (14) is mathematically equivalent to the combination of Equations (9) and (10). For npix_data[j]==1, spatial_data[j] is set equal to the input spatial_init value for the pixel in question. For npix_data[j]&gt;1 and npix_data[j]&lt;9, spatial_data[j] is set equal to a weighted sum of the spatial_data[j] value calculated from Equation (14) and the average spatial_init values for the pixels in region j+1 as per Equation (11).
</p>
  <p num="p-0323">Finally, the ngbr_mask is initialized by scanning rlblmap_data. nghbr_mask [j+k*max_nregions] is set to the value TRUE (or 1) if and only if region j is a neighbor of region k. Whether of not a pixel is considered to be a neighbor of another pixel is determined by the value of maxmdir. If a pixel is one of the maxmdir nearest neighbors of another pixel, then it is a neighbor of that pixel.</p>
  <p num="p-0324">Functional description of the lhseg( ) function: If init_flg TRUE upon entering the lhseg( ) function, the dissimilarity function values for all neighboring regions of each region are calculated, and bnghbr and bncomp are updated for each region. Then a sorted structure of type R_LIST, pointed to by the pointer head_nbsorted_list, is created such that is ordered by the value of bncomp. If there is more than one region with the same value of bncomp, the regions are secondarily ordered by region label value (lower to higher). The value of the variable minbcomp is set equal to the value of bncomp of the first element of this sorted list. If init_flg=FALSE upon entering the lhseg( ) function, the dissimilarity function values for all neighboring regions need not be calculated (they had been previously calculated), and sorted lists of type R_LIST, pointed to by the pointers head_nbsorted_list and head_sorted_list, are sorted by the value of bncomp and brcomp, respectively. When ties occur in the values of bncomp and brcomp, the regions are secondarily ordered by region label value (lower to higher).</p>
  <p num="p-0325">Next the region pointed to by the head_nbsorted_list, and its most similar neighboring region, are merged. The merged region is given the label of the region with the lower valued label. The values for the new region in the npix_data, sum_data, and the nghbr_mask arrays are updated, as are the sumsq_data and spatial_data arrays, if necessary. The value of mgreg is updated for the region with the higher region label value. The list pointed to by the pointer head_nbsorted_list is resorted as necessary. If the region pointed to by the resorted head_nbsorted_list has bncomp&lt;=minbcomp, the indicated regions are also merged. This continues until the region pointed to by the resorted head_nbsorted_list has bncomp&gt;minbcomp. This constitutes an iteration of region growing.</p>
  <p num="p-0326">If init_flg==TRUE, the dissimilarity function values for all non-neighboring regions of each region are now calculated, and bregion and breomp are updated for each region. Then a sorted structure of type R_LIST, pointed to by the pointer head_sorted_list, is created such that is ordered by the value of brcomp. If there is more than one region with the same value of brcomp, the regions are secondarily ordered by region label value (lower to higher). The value of init_flg is now set to FALSE. If init_flg was previously equal to FALSE, these dissimilarity function values were previously calculated and sorted.</p>
  <p num="p-0327">If the region pointed to by the head_sorted_list, and its most similar neighboring region, are merged if its value of brcomp&lt;minbcomp (minbcomp was obtained from the merges of neighboring regions). The merged region is given the label of the region with the lower valued label. The values for the new region in the npix_data, sum_data, and the nghbr_mask arrays are updated, as are the sumsq_data and spatial_data arrays, if necessary. The value of mgreg is updated for the region with the higher region label value. The lists pointed to by the pointer head_sorted_list and head_nbsorted_list are resorted as necessary. If the region pointed to by the resorted head_sorted_list has brcomp&lt;=minbcomp, the indicated regions are also merged. This continues until the region pointed to by the resorted head_nbsorted_list has brcomp&gt;minbcomp. This constitutes an iteration of spectral clustering.</p>
  <p num="p-0328">If the current number of region (nregions) is less than cvnbregs, the lhseg( ) function exits. Otherwise, additional alternate iterations of region growing (based on bncomp and bnghbr) and spectral clustering (based on brcomp and bregion) are performed until nregions&lt;=minregions. In these additional iterations, the exhaustive calculation of dissimilarity function values for neighboring and non-neighboring regions is not required, as these values are updated at each merge. Note that lhseg( ) does not exit if nregions&lt;cvnbregs after a region growing iteration. The function can only exit after a spectral clustering iteration.</p>
  <p num="p-0329">Functional description of the fhseg( ) function: The fhseg( ) function is identical to the lhseg( ) function except for additional code for detecting the natural convergence points and code to output the segmentation results at the natural convergence points.</p>
  <p num="p-0330">The basic HSEG algorithm was described earlier in the description of the parallel implementation. In step 7, it was noted that at certain iterations, the region information from the previous iteration must be saved. Accordingly, fhseg( ) allocates and initializes and updates data arrays to store this information. The data array prev_rlblmap is initialized to equal the current value of rlblmap_data, and prevcritval is initialized to 0.0, and the current value of the global criterion value, critval, is calculated through a call to the function compute_cv( ).</p>
  <p num="p-0331">In lhseg( ) the rlblmap_data is not updated. However, in f hseg( ) the rlblmap_data is updated after each group of region growing and spectral clustering merges (steps 2 through 5 of the basic HSEG algorithm description). In addition, the region number of pixels and region sum vectors are updated. If spatial_wght&gt;0.0, the region sum square vectors and region spatial feature values are also updated.</p>
  <p num="p-0332">After each region growing and spectral clustering (if requested) iteration, the value of cvratio=critval/prevcritval is calculated. If cvratio&gt;convfact, then the region information for the previous iteration (prior to the current group of region growing and spectral clustering merges) is sent to files. This information includes the number of regions, the region number of pixels list, the region mean vector list and the region criterion value list, and, if requested, the region merges list. If the region merges list is not requested, the region label map is output each time. If the region merges list is requested, the region label map is output only the first time region information is output.</p>
  <p num="p-0333">If after an iteration of spectral clustering merges, the number of regions is less than cvnbregs, the fhseg( ) function outputs the current region segmentation information to files and then exits.</p>
  <p num="p-0334">Functional description of the lrhseg( ) function: Upon entering the lrhseg( ) function, the ncols and nrows variables are divided by 2 and the level variable is incremented by one. (This sets these variables to the proper values for the next set of recursive calls to recur_hseg( ), described below.) Then the nghbr_mask array is initialized to all FALSE values, and the npix_sub, sum_sub, sumsq_sub, and spatial_sub arrays are initialized to npix_data, sum_data, sumsq_data, and spatial_data, respectively. Next, the data array starting points for the next level of recursion are saved into “_sub_sub” arrays as follows:</p>
  <p num="p-0335">
    <tables id="TABLE-US-00097" num="00097">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="14pt" align="left"> </colspec>
          <colspec colname="1" colwidth="203pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>input_sub_sub = input_sub + ncols*nrows*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry> if (mask_flag)</entry>
            </row> <row>
              <entry> </entry>
              <entry>  mask_sub_sub = mask_sub + ncols*nrows;</entry>
            </row> <row>
              <entry> </entry>
              <entry> if(spatial_wght &gt; 0.0)</entry>
            </row> <row>
              <entry> </entry>
              <entry>  spatial_init_sub_sub = spatial_init_sub + ncols*nrows;</entry>
            </row> <row>
              <entry> </entry>
              <entry> rlblmap_sub_sub = rlblmap_sub + ncols*nrows;</entry>
            </row> <row>
              <entry> </entry>
              <entry> nghbr_sub_sub = nghbr_sub + max_nregions*max_nregions;</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0336">Processing is now initiated for the first subsection of data (out of four). The data arrays input_sub, mask_sub (if provided), spatial_init_sub (if provided), and rlblmap_sub (if provided) and loaded with data from the upper left quadrant of the input data arrays input_data, mask_data, spatial_init, and rlblmap_data, respectively.</p>
  <p num="p-0337">The function recur_hseg( ) is now called with the following input variable and array data:</p>
  <p num="p-0338">
    <tables id="TABLE-US-00098" num="00098">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="154pt" align="left"> </colspec>
          <colspec colname="3" colwidth="7pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_sub</entry>
              <entry>An unsigned short array containing the current</entry>
              <entry> </entry>
            </row> <row>
              <entry> </entry>
              <entry>section of input image data. Is renamed input_data</entry>
            </row> <row>
              <entry> </entry>
              <entry>internal to recur_hseg( ).</entry>
            </row> <row>
              <entry>mask_sub</entry>
              <entry>An unsigned char array containing the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>section of mask data (if any). Is renamed mask_data</entry>
            </row> <row>
              <entry> </entry>
              <entry>internal to recur_hseg( ).</entry>
            </row> <row>
              <entry>rlblmap_sub</entry>
              <entry>An unsigned short array containing the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>section of input region label map data (if any).</entry>
            </row> <row>
              <entry> </entry>
              <entry>(Will be overwritten by the output region label</entry>
            </row> <row>
              <entry> </entry>
              <entry>map data.) Is renamed rlblmap_data internal to</entry>
            </row> <row>
              <entry> </entry>
              <entry>recur_hseg( ).</entry>
            </row> <row>
              <entry>spatial_init_sub</entry>
              <entry>A float array containing the current section of</entry>
            </row> <row>
              <entry> </entry>
              <entry>input spatial feature data (local image variance</entry>
            </row> <row>
              <entry> </entry>
              <entry>or standard deviation - if any). Is renamed</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatial_init internal to recur_hseg( ).</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows</entry>
            </row> <row>
              <entry> </entry>
              <entry>in the current section of input image data</entry>
            </row> <row>
              <entry>level</entry>
              <entry>An int variable containing the value of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>current level of recursion</entry>
            </row> <row>
              <entry>roffset</entry>
              <entry>An int variable containing the offset value</entry>
            </row> <row>
              <entry> </entry>
              <entry>required for the region labels to keep them</entry>
            </row> <row>
              <entry> </entry>
              <entry>distinct from the region labels in the previous</entry>
            </row> <row>
              <entry> </entry>
              <entry>quarter(s) of data (for the first quarter,</entry>
            </row> <row>
              <entry> </entry>
              <entry>roffset = 0)</entry>
            </row> <row>
              <entry namest="1" nameend="3" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0339">The global variables mask_flag, rlblmap_in_flag, nbands, sub_ncols, sub_nrows, max_nregions, scale, offset, maxmdir, simcrit, extmean, spclust, spatial_wght, spatial_type, rnb_levels and minregions are also used as inputs by recur_hseg( ). Certain variables and arrays are output by recur_hseg( ). They are as follows:</p>
  <p num="p-0340"> <tables id="TABLE-US-00099" num="00099"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="63pt" align="left"> </colspec> <colspec colname="2" colwidth="154pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>sub_nregions[q]</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>in the segmentation of the section of data</entry> </row> <row> <entry> </entry> <entry>processed. (For the first quarter of data,</entry> </row> <row> <entry> </entry> <entry>q = 0.)</entry> </row> <row> <entry>rlblmap_sub</entry> <entry>An unsigned short array containing the output</entry> </row> <row> <entry> </entry> <entry>region label map for the current section of</entry> </row> <row> <entry> </entry> <entry>data. This region label map specifies the</entry> </row> <row> <entry> </entry> <entry>spatial distribution of the regions.</entry> </row> <row> <entry>npix_sub</entry> <entry>An unsigned int array containing the current</entry> </row> <row> <entry> </entry> <entry>region number of pixels list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>The j<sup>th</sup> element of the vector is the number of</entry> </row> <row> <entry> </entry> <entry>pixels in region j + 1.</entry> </row> <row> <entry>sum_sub</entry> <entry>A double array containing the current sum of</entry> </row> <row> <entry> </entry> <entry>the normalized input data values over all pixels</entry> </row> <row> <entry> </entry> <entry>in each region. Element j + sub_nregions[q]*b is</entry> </row> <row> <entry> </entry> <entry>the sum value for region j + 1 and band b (first</entry> </row> <row> <entry> </entry> <entry>band is band number 0).</entry> </row> <row> <entry>sumsq_sub</entry> <entry>A double array containing the current sum of</entry> </row> <row> <entry> </entry> <entry>the square of the normalized input data values</entry> </row> <row> <entry> </entry> <entry>over all pixels in each region. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.)</entry> </row> <row> <entry> </entry> <entry>Element j + sub_nregions[q]*b is the sum square</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band</entry> </row> <row> <entry> </entry> <entry>is band number 0).</entry> </row> <row> <entry>spatial_sub</entry> <entry>A double array containing the current region</entry> </row> <row> <entry> </entry> <entry>spatial feature value list stored as a vector.</entry> </row> <row> <entry> </entry> <entry>(Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) The j<sup>th</sup> element of the vector is the spatial</entry> </row> <row> <entry> </entry> <entry>feature value for region j + 1.</entry> </row> <row> <entry>nghbr_sub</entry> <entry>An unsigned char array of numbers designating,</entry> </row> <row> <entry> </entry> <entry>for the current section of data, whether or not</entry> </row> <row> <entry> </entry> <entry>a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array element</entry> </row> <row> <entry> </entry> <entry>j + max_nregions*k is TRUE if and only if regions</entry> </row> <row> <entry> </entry> <entry>j + 1 and k + 1 are spatially adjacent.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                     </tbody>  </table> </tables> <br/>
Other data arrays are passed into recur_hseg( ) for use as work space. These are input_sub_sub, mask_sub_sub, rlblmap<sub>—sub</sub>_sub, spatial_init_sub_sub, rlabel_data, region_list, relabel_list, nghbr_sub_sub, nghbr_tmp, rlblmap_<b>4</b>cols, rlblmap_<b>4</b>rows, sort_store and nbsort_store. The arrays input_sub_sub, mask_sub_sub, rlblmap_sub_sub, spatial_init_sub_sub, and nghbr_sub_sub, are renamed to input_sub, mask_sub, rlblmap_sub, spatial_init_sub, and nghbr_sub internal to recur_hseg( ).
</p>
  <p num="p-0341">If level==rnb_levels, the function recur_hseg( ) performs hierarchical segmentation on the specified section of data. Otherwise, it makes a further recursive call to lrhseg( ), and then performs hierarchical segmentation on the resulting data. The internal operations of the function recur_hseg( ) are described in a later section.</p>
  <p num="p-0342">The outputs from recur_hseg( are now translated into the data arrays for the current reassembled section of data. The nghbr_mask is updated as follows (for the first quarter of data, q=0 and roffset=0):</p>
  <p num="p-0343"> <tables id="TABLE-US-00100" num="00100"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>for (index = 0; index &lt; sub_nregions[q]; index++)</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>for (subindex = 0; subindex &lt; sub_nregions[q]; subindex++)</entry> </row> <row> <entry> </entry> <entry> nghbr_mask[(index+roffset)*max_nregions + (subindex+</entry> </row> <row> <entry> </entry> <entry> roffset)] =</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="70pt" align="left"> </colspec> <colspec colname="1" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>nghbr_sub[index*max_nregions + subindex];</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">  </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The rlblmap_sub data is also loaded into the upper left quarter of the rlblmap_data array. The npix_data, sum_data, sumsq_data and spatial_data, arrays are updated automatically by the way the npix_sub, sum_sub, sumsq_sub and spatial_sub arrays are specified.
</p>
  <p num="p-0344">Processing is now initiated for the second subsection of data (out of four). The data arrays input_sub, mask_sub (if provided), spatial_init sub (if provided), and rlblmap_sub (if provided) and loaded with data from the upper right quadrant of the input data arrays input_data, mask_data, spatial_init, and rlblmap_data, respectively, and the npix_sub, sum_sub, sumsq_sub, and spatial_sub arrays are incremented as follows (here q=0):</p>
  <p num="p-0345">
    <tables id="TABLE-US-00101" num="00101">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="42pt" align="left"> </colspec>
          <colspec colname="1" colwidth="175pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>npix_sub += sub_nregions[q];</entry>
            </row> <row>
              <entry> </entry>
              <entry> sum_sub += sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry>if (spatial_wght &gt; 0.0)</entry>
            </row> <row>
              <entry> </entry>
              <entry>{</entry>
            </row> <row>
              <entry> </entry>
              <entry>sumsq_sub += sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry> spatial_sub += sub_nregions[q];</entry>
            </row> <row>
              <entry> </entry>
              <entry>}</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0346">The function recur_hseg( ) is now called in the same manner as for the first quarter of data except that q=1 and roffset=sub_nregions[0].</p>
  <p num="p-0347">The outputs from recur_hseg( ) are now translated into the data arrays for the current reassembled section of data. The nghbr_mask is updated as follows (for the second quarter of data, q=1 and roffset=sub_nregions[0]):</p>
  <p num="p-0348"> <tables id="TABLE-US-00102" num="00102"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>for (index = 0; index &lt; sub_nregions[q]; index++)</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>for (subindex = 0; subindex &lt; sub_nregions[q]; subindex++)</entry> </row> <row> <entry> </entry> <entry> nghbr_mask[(index+roffset)*max_nregions + (subindex+</entry> </row> <row> <entry> </entry> <entry> roffset)] =</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="70pt" align="left"> </colspec> <colspec colname="1" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>nghbr_sub[index*max_nregions + subindex];</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">  </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The rlblmap_sub data is also loaded into the upper right quarter of the rlblmap_data array. The npix_data, sum_data, sumsq_data and spatial_data, arrays are updated automatically by the way the npix_sub, sum_sub, sumsq_sub and spatial_sub arrays are specified.
</p>
  <p num="p-0349">Processing is now initiated for the third subsection of data (out of four). The data arrays input_sub, mask_sub (if provided), spatial_init_sub (if provided), and rlblmap_sub (if provided) and loaded with data from the lower left quadrant of the input data arrays input_data, mask_data, spatial_init, and rlblmap_data, respectively, and the npix_sub, sum_sub, sumsq_sub, and spatial_sub arrays are incremented as follows (here q=1):</p>
  <p num="p-0350">
    <tables id="TABLE-US-00103" num="00103">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="42pt" align="left"> </colspec>
          <colspec colname="1" colwidth="175pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>npix_sub += sub_nregions[q];</entry>
            </row> <row>
              <entry> </entry>
              <entry>sum_sub += sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry>if (spatial_wght &gt; 0.0)</entry>
            </row> <row>
              <entry> </entry>
              <entry>{</entry>
            </row> <row>
              <entry> </entry>
              <entry> sumsq_sub += sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry> spatial_sub += sub_nregions[q];</entry>
            </row> <row>
              <entry> </entry>
              <entry>}</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0351">The function recur_hseg( ) is now called in the same manner as for the first quarter of data except that q=2 and roffset=sub_nregions[0]+sub_nregions[1].</p>
  <p num="p-0352">The outputs from recur_hseg( ) are now translated into the data arrays for the current reassembled section of data. The nghbr_mask is updated as follows (for the third quarter of data, q=2 and roffset=sub_nregions[0]+sub_nregions[1]):</p>
  <p num="p-0353"> <tables id="TABLE-US-00104" num="00104"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>for (index = 0; index &lt; sub_nregions[q]; index++)</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>for (subindex = 0; subindex &lt; sub_nregions[q]; subindex++)</entry> </row> <row> <entry> </entry> <entry> nghbr_mask[(index+roffset)*max_nregions + (subindex+</entry> </row> <row> <entry> </entry> <entry> roffset)] =</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="70pt" align="left"> </colspec> <colspec colname="1" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>nghbr_sub[index*max_nregions + subindex];</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">  </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The rlblmap_sub data is also loaded into the lower left quarter of the rlblmap_data array. The npix_data, sum_data, sumsq_data and spatial_data, arrays are updated automatically by the way the npix_sub, sum_sub, sumsq_sub and spatial_sub arrays are specified.
</p>
  <p num="p-0354">Processing is now initiated for the fourth subsection of data (out of four). The data arrays input_sub, mask_sub (if provided), spatial_init_sub (if provided), and rlblmap_sub (if provided) and loaded with data from the lower right quadrant of the input data arrays input_data, mask_data, spatial_init, and rlblmap_data, respectively, and the npix_sub, sum_sub, sumsq_sub, and spatial_sub arrays are incremented as follows (here q=2):</p>
  <p num="p-0355">
    <tables id="TABLE-US-00105" num="00105">
      <tgroup align="left" colsep="0" rowsep="0" cols="3">
          <colspec colname="offset" colwidth="35pt" align="left"> </colspec>
          <colspec colname="1" colwidth="112pt" align="left"> </colspec>
          <colspec colname="2" colwidth="70pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry namest="offset" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry> </entry>
              <entry>npix_sub += sub_nregions[q];</entry>
              <entry>sum_sub +=</entry>
            </row> <row>
              <entry> </entry>
              <entry>sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry>if (spatial_wght &gt; 0.0)</entry>
            </row> <row>
              <entry> </entry>
              <entry>{</entry>
            </row> <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="offset" colwidth="35pt" align="left"> </colspec>
          <colspec colname="1" colwidth="182pt" align="left"> </colspec>
          </tgroup> <row>
              <entry> </entry>
              <entry> sumsq_sub += sub_nregions[q]*nbands;</entry>
            </row> <row>
              <entry> </entry>
              <entry> spatial_sub += sub_nregions[q];</entry>
            </row> <row>
              <entry> </entry>
              <entry>}</entry>
            </row> <row>
              <entry> </entry>
              <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
          </tbody>
        
        <tbody valign="top">
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0356">The function recur_hseg( ) is now called in the same manner as for the first quarter of data except that q=3 and roffset=sub_nregions[0]+sub_nregions[1]+sub_nregion[2].</p>
  <p num="p-0357">The outputs from recur_hseg( ) are now translated into the data arrays for the current reassembled section of data. The nghbr_mask is updated as follows (for the fourth quarter of data, q=3 and roffset=sub_nregions[0]+sub_nregions[1]+sub_nregion[2]):</p>
  <p num="p-0358"> <tables id="TABLE-US-00106" num="00106"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="14pt" align="left"> </colspec> <colspec colname="1" colwidth="203pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <row> <entry> </entry> <entry>for (index = 0; index &lt; sub_nregions[q]; index++)</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="28pt" align="left"> </colspec> <colspec colname="1" colwidth="189pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>for (subindex = 0; subindex &lt; sub_nregions[q]; subindex++)</entry> </row> <row> <entry> </entry> <entry> nghbr_mask[(index+roffset)*max_nregions + (subindex+</entry> </row> <row> <entry> </entry> <entry> roffset)] =</entry> </row> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="offset" colwidth="70pt" align="left"> </colspec> <colspec colname="1" colwidth="147pt" align="left"> </colspec> </tgroup> <row> <entry> </entry> <entry>nghbr_sub[index*max_nregions + subindex];</entry> </row> <row> <entry> </entry> <entry namest="offset" nameend="1" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">  </tbody>  <tbody valign="top">    </tbody>  <tbody valign="top">   </tbody>  </table> </tables> <br/>
The rlblmap_sub data is also loaded into the lower right quarter of the rlblmap_data array. The npix_data, sum_data, sumsq_data and spatial_data, arrays are updated automatically by the way the npix_sub, sum_sub, sumsq_sub and spatial_sub arrays are specified.
</p>
  <p num="p-0359">Finally, the function lrhseg( ) sets nregions=sub_nregions[0]+sub_nregions[1]+sub_nregions[2]+sub_nregions[3] and returns to the calling function.</p>
  <p num="p-0360">Functional description of the recur_hseg( ) function: If level==rnb_levels, the function recur_hseg( ) calls the region_data_init( ) function with the following input variable and array data:</p>
  <p num="p-0361"> <tables id="TABLE-US-00107" num="00107"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>input_data</entry> <entry>An unsigned short array containing the current section</entry> </row> <row> <entry> </entry> <entry>of input image data</entry> </row> <row> <entry>mask_data</entry> <entry>An unsigned char array containing the current section</entry> </row> <row> <entry> </entry> <entry>mask data (if any)</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the current section</entry> </row> <row> <entry> </entry> <entry>of input region label map data (if any). (Will be</entry> </row> <row> <entry> </entry> <entry>overwritten by the output region label map data.)</entry> </row> <row> <entry>spatial_init</entry> <entry>A float array containing the current section of input</entry> </row> <row> <entry> </entry> <entry>spatial feature data (local image variance or standard</entry> </row> <row> <entry> </entry> <entry>deviation - if any)</entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in</entry> </row> <row> <entry> </entry> <entry>the current section of input image data</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows in the</entry> </row> <row> <entry> </entry> <entry>current section of input image data</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                </tbody>  </table> </tables> <br/>
The global variables mask_flag, rlblmap_in_flag, nbands, max_nregions, scale, offset, maxmdir, spatial_wght and spatial_type are also used as inputs by region_data_init( ). The following variables and arrays are output by region_data_init( ):
</p>
  <p num="p-0362"> <tables id="TABLE-US-00108" num="00108"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the initial number of</entry> </row> <row> <entry> </entry> <entry>regions in the current section of data.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the initial output</entry> </row> <row> <entry> </entry> <entry>region label map for the current section of data.</entry> </row> <row> <entry> </entry> <entry>This region label map specifies the initial spatial</entry> </row> <row> <entry> </entry> <entry>distribution of the regions.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the initial region</entry> </row> <row> <entry> </entry> <entry>number of pixels list stored as a vector for the</entry> </row> <row> <entry> </entry> <entry>current section of data. The j<sup>th</sup> element of the vector</entry> </row> <row> <entry> </entry> <entry>is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the initial sum of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region for the current section of data. Element j +</entry> </row> <row> <entry> </entry> <entry>nregions*b is the sum value for region j + 1 and band</entry> </row> <row> <entry> </entry> <entry>b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the initial sum of the</entry> </row> <row> <entry> </entry> <entry>square of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region for the current section of</entry> </row> <row> <entry> </entry> <entry>data. (Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) Element j + nregions*b is the sum square</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band is band</entry> </row> <row> <entry> </entry> <entry>number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the initial region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector for the current</entry> </row> <row> <entry> </entry> <entry>section of data. (Actually contains values only if</entry> </row> <row> <entry> </entry> <entry>spatial_wght &gt; 0.0.) The j<sup>th </sup>element of the vector is</entry> </row> <row> <entry> </entry> <entry>the spatial feature value for region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating whether</entry> </row> <row> <entry> </entry> <entry>or not a pair of regions are spatially adjacent</entry> </row> <row> <entry> </entry> <entry>(i.e., neighbors) for the current section of data.</entry> </row> <row> <entry> </entry> <entry>The value of the mask at array element j +</entry> </row> <row> <entry> </entry> <entry>max_nregions*k is TRUE if and only if regions j + 1</entry> </row> <row> <entry> </entry> <entry>and k + 1 are spatially adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region for the current section of data.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                       </tbody>  </table> </tables> <br/>
The array rlabel_data is also passed to the function region_data_init( ) for use as work space. See above for a functional description of the region_data_init( ) function. The purpose of the region_data_init( ) function is to initialize the variables and arrays output by the region_data_init( ) function based on the input variable and array data.
</p>
  <p num="p-0363">The function lrhseg( ) is now called with the following input variable and array data:</p>
  <p num="p-0364">
    <tables id="TABLE-US-00109" num="00109">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="56pt" align="left"> </colspec>
          <colspec colname="2" colwidth="161pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>input_data</entry>
              <entry>An unsigned short array containing the current section</entry>
            </row> <row>
              <entry> </entry>
              <entry>of input image data</entry>
            </row> <row>
              <entry>mask_data</entry>
              <entry>An unsigned char array containing the current section</entry>
            </row> <row>
              <entry> </entry>
              <entry>of mask data (if any)</entry>
            </row> <row>
              <entry>rlblmap_data</entry>
              <entry>An unsigned short array containing the current section</entry>
            </row> <row>
              <entry> </entry>
              <entry>of input region label map data (if any). (Will be</entry>
            </row> <row>
              <entry> </entry>
              <entry>overwritten by the output region label map data.)</entry>
            </row> <row>
              <entry>spatial_init</entry>
              <entry>A float array containing the current section of input</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatial feature data (local image variance or standard</entry>
            </row> <row>
              <entry> </entry>
              <entry>deviation - if any)</entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns in</entry>
            </row> <row>
              <entry> </entry>
              <entry>the current section of input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in the</entry>
            </row> <row>
              <entry> </entry>
              <entry>current section of input image data</entry>
            </row> <row>
              <entry>level</entry>
              <entry>An int variable containing the value of the current</entry>
            </row> <row>
              <entry> </entry>
              <entry>level of recursion</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0365">The global variables mask_flag, rlblmap_in_flag, nbands, sub_ncols, sub_nrows, max_nregions, scale, offset, maxmdir, simcrit, extmean, spclust, spatial_wght, spatial_type, rnb_levels and minregions are also used as inputs by lrhseg( ). Certain variables and arrays are output by lrhseg( ). They are as follows:</p>
  <p num="p-0366"> <tables id="TABLE-US-00110" num="00110"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions in</entry> </row> <row> <entry> </entry> <entry>the segmentation of the section of data processed.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the output region</entry> </row> <row> <entry> </entry> <entry>label map for the current section of data. This region</entry> </row> <row> <entry> </entry> <entry>label map specifies the spatial distribution of the</entry> </row> <row> <entry> </entry> <entry>regions.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the current region</entry> </row> <row> <entry> </entry> <entry>number of pixels list stored as a vector. The j<sup>th</sup> </entry> </row> <row> <entry> </entry> <entry>element of the vector is the number of pixels in</entry> </row> <row> <entry> </entry> <entry>region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the current sum of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region. Element j + nregions*b is the sum value for</entry> </row> <row> <entry> </entry> <entry>region j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the current sum of the</entry> </row> <row> <entry> </entry> <entry>square of the normalized input data values over all</entry> </row> <row> <entry> </entry> <entry>pixels in each region. (Actually contains values only</entry> </row> <row> <entry> </entry> <entry>if spatial_wght &gt; 0.0.) Element j + nregions*b is the</entry> </row> <row> <entry> </entry> <entry>sum square value for region j + 1 and band b (first</entry> </row> <row> <entry> </entry> <entry>band is band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the current region spatial</entry> </row> <row> <entry> </entry> <entry>feature value list stored as a vector. (Actually</entry> </row> <row> <entry> </entry> <entry>contains values only if spatial_wght &gt; 0.0.) The j<sup>th</sup> </entry> </row> <row> <entry> </entry> <entry>element of the vector is the spatial feature value for</entry> </row> <row> <entry> </entry> <entry>region j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating, for the</entry> </row> <row> <entry> </entry> <entry>current section of data, whether or not a pair of</entry> </row> <row> <entry> </entry> <entry>regions are spatially adjacent (i.e., neighbors). The</entry> </row> <row> <entry> </entry> <entry>value of the mask at array element j + max_nregions*k</entry> </row> <row> <entry> </entry> <entry>is TRUE if and only if regions j + 1 and k + 1 are</entry> </row> <row> <entry> </entry> <entry>spatially adjacent.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                 </tbody>  </table> </tables> <br/>
Other data arrays are passed into lrhseg( ) for use as work space. These are input_sub, mask_sub, rlblmap_sub, spatial_init_sub, rlabel_data, region_list, relabel_list, nghbr_sub, nghbr_tmp, rlblmap_<b>4</b>cols, rlblmap_<b>4</b>rows, sort_store and nbsort_store.
</p>
  <p num="p-0367">The purpose of the lrhseg( ) function is to divide up the input data into four equal quadrants and to call the function recur_hseg( ) for each quadrant. The results from recur_hseg( ) are assembled together by lrhseg( ) and returned to the calling function. The internal operations of the function lrhseg( ) are described in a previous section.</p>
  <p num="p-0368">The arrays rlblmap_<b>4</b>cols and rlblmap_<b>4</b>rows are now loaded with values from rlblmap_data. The array rlblmap_<b>4</b>cols contains the first, middle two and last columns from rlblmap_data, and the array rlblmap_<b>4</b>rows contains the first, middle two and last rows from rlblmap_data. The function update_nghbr_mask( ) is now called with the following input variables and data:</p>
  <p num="p-0369">
    <tables id="TABLE-US-00111" num="00111">
      <tgroup align="left" colsep="0" rowsep="0" cols="2">
          <colspec colname="1" colwidth="49pt" align="left"> </colspec>
          <colspec colname="2" colwidth="168pt" align="left"> </colspec>
          </tgroup> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <row>
              <entry>ncols</entry>
              <entry>An int variable containing the number of columns in</entry>
            </row> <row>
              <entry> </entry>
              <entry>the current section of input image data</entry>
            </row> <row>
              <entry>nrows</entry>
              <entry>An int variable containing the number of rows in the</entry>
            </row> <row>
              <entry> </entry>
              <entry>current section of input image data</entry>
            </row> <row>
              <entry>nregions</entry>
              <entry>An int variable containing the current value of the</entry>
            </row> <row>
              <entry> </entry>
              <entry>number of regions is the current section of segmented</entry>
            </row> <row>
              <entry> </entry>
              <entry>data</entry>
            </row> <row>
              <entry>rlblmap_4cols</entry>
              <entry>An unsigned short array containing the first, middle</entry>
            </row> <row>
              <entry> </entry>
              <entry>two and last columns of the current region label map</entry>
            </row> <row>
              <entry> </entry>
              <entry>data.</entry>
            </row> <row>
              <entry>rlblmap_4rows</entry>
              <entry>An unsigned short array containing the first, middle</entry>
            </row> <row>
              <entry> </entry>
              <entry>two and last rows of the current region label map</entry>
            </row> <row>
              <entry> </entry>
              <entry>data.</entry>
            </row> <row>
              <entry>nghbr_mask</entry>
              <entry>An unsigned char array of numbers designating, for the</entry>
            </row> <row>
              <entry> </entry>
              <entry>current section of data, whether or not a pair of</entry>
            </row> <row>
              <entry> </entry>
              <entry>regions are spatially adjacent (i.e., neighbors). The</entry>
            </row> <row>
              <entry> </entry>
              <entry>value of the mask at array element j + max_nregions*k</entry>
            </row> <row>
              <entry> </entry>
              <entry>is TRUE if and only if regions j + 1 and k + 1 are</entry>
            </row> <row>
              <entry> </entry>
              <entry>spatially adjacent.</entry>
            </row> <row>
              <entry namest="1" nameend="2" align="center" rowsep="1"> </entry>
            </row> <table frame="none" colsep="0" rowsep="0" class="description-table">
        <thead>
            
          </thead>
          <tbody valign="top">
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            
          </tbody>
        
      </table>
    </tables>
  </p>
  <p num="p-0370">The function update_nghbr_mask( ) modifies the input nghbr_mask array so that it includes the neighbor relationship across the middle two columns and rows of the current region label map. The nghbr_mask array had been previously lacking this information. See a previous section for a functional description of update nghbr_mask( ).</p>
  <p num="p-0371">The function region_list_init( ) is now called with the following input variable:</p>
  <p num="p-0372"> <tables id="TABLE-US-00112" num="00112"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions in the</entry> </row> <row> <entry> </entry> <entry>current section of segmented data</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The following data array is output by region_list_init( ):
</p>
  <p num="p-0373"> <tables id="TABLE-US-00113" num="00113"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about each</entry> </row> <row> <entry> </entry> <entry>region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">      </tbody>  </table> </tables> <br/>
See a previous section for a functional description of the region_list_init( ) function. The purpose of the region_list_init( ) function is to initialize the region_list structure.
</p>
  <p num="p-0374">After the call to either region_data_init( ) or lrhseg( ), update_nghbr_mask( ) and region_list_list( ) are completed, the following parameters are set: init_flg=TRUE, onregions=nregions and cvnbregs=minregions (note that minregions is a user set parameter). If nregions&lt;=minregions, the calls below to the functions lhseg( ) and read_region_list( ) are skipped. Otherwise, the function recur_hseg( ) calls the function lhseg( ) with the following input variable and array data:</p>
  <p num="p-0375"> <tables id="TABLE-US-00114" num="00114"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>init_flag</entry> <entry>An int variable which indicates whether or not the</entry> </row> <row> <entry> </entry> <entry>region_list has just been initialized (in this case</entry> </row> <row> <entry> </entry> <entry>init_flag = TRUE).</entry> </row> <row> <entry>onregions</entry> <entry>An int variable containing the number of regions</entry> </row> <row> <entry> </entry> <entry>existing when lhseg( ) is initially called.</entry> </row> <row> <entry>cvnbregs</entry> <entry>An int variable indicating the number of regions at</entry> </row> <row> <entry> </entry> <entry>which that this call to lhseg( ) will converge (exit).</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number of</entry> </row> <row> <entry> </entry> <entry>pixels list stored as a vector. The j<sup>th </sup>element of the</entry> </row> <row> <entry> </entry> <entry>vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region. (Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) Element j + nregions*b is the sum square</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band is</entry> </row> <row> <entry> </entry> <entry>band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial feature</entry> </row> <row> <entry> </entry> <entry>value list stored as a vector. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th</sup> element of</entry> </row> <row> <entry> </entry> <entry>the vector is the spatial feature value for region</entry> </row> <row> <entry> </entry> <entry>j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating whether</entry> </row> <row> <entry> </entry> <entry>or not a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array element j +</entry> </row> <row> <entry> </entry> <entry>max_nregions*k is TRUE if and only if regions j +</entry> </row> <row> <entry> </entry> <entry>1 and k + 1 are spatially adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                    </tbody>  </table> </tables> <br/>
The global variables nbands, max_regions, simcrit, extmean, spclust, spatial_wght, and spatial_type are also used as inputs to lhseg( ). The following variables and arrays are modified and output by lhseg( ):
</p>
  <p num="p-0376"> <tables id="TABLE-US-00115" num="00115"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the initial number of</entry> </row> <row> <entry> </entry> <entry>regions in the section of data processed.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number of</entry> </row> <row> <entry> </entry> <entry>pixels list stored as a vector. The j<sup>th </sup>element of the</entry> </row> <row> <entry> </entry> <entry>vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region. (Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) Element j + nregions*b is the sum square</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band is</entry> </row> <row> <entry> </entry> <entry>band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial feature</entry> </row> <row> <entry> </entry> <entry>value list stored as a vector. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th </sup>element of</entry> </row> <row> <entry> </entry> <entry>the vector is the spatial feature value for region</entry> </row> <row> <entry> </entry> <entry>j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating whether</entry> </row> <row> <entry> </entry> <entry>or not a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array element j +</entry> </row> <row> <entry> </entry> <entry>max_nregions*k is TRUE if and only if regions j + 1</entry> </row> <row> <entry> </entry> <entry>and k + 1 are spatially adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                               </tbody>  </table> </tables> <br/>
The arrays sort_store, and nbsort_store are also passed to the lhseg( ) function to use as work space. See a previous section for a functional description of the lhseg( ) function. The purpose of the lhseg( ) function is to perform multiple iterations of region growing intermixed with spectral clustering (if requested) until the number of regions becomes less than or equal to cvnbregs (in this case, minregions).
</p>
  <p num="p-0377">After the lhseg function exits, the function read_region_list( ) is called with the following input variable and array data:</p>
  <p num="p-0378"> <tables id="TABLE-US-00116" num="00116"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>nregions</entry> <entry>An int variable containing the number of regions in</entry> </row> <row> <entry> </entry> <entry>the section of data processed.</entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number of</entry> </row> <row> <entry> </entry> <entry>pixels list stored as a vector. The j<sup>th</sup> element of the</entry> </row> <row> <entry> </entry> <entry>vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region</entry> </row> <row> <entry> </entry> <entry>j + 1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region. (Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) Element j + nregions*b is the sum square</entry> </row> <row> <entry> </entry> <entry>value for region j + 1 and band b (first band is</entry> </row> <row> <entry> </entry> <entry>band number 0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial feature</entry> </row> <row> <entry> </entry> <entry>value list stored as a vector. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th</sup> element of</entry> </row> <row> <entry> </entry> <entry>the vector is the spatial feature value for region</entry> </row> <row> <entry> </entry> <entry>j + 1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating whether</entry> </row> <row> <entry> </entry> <entry>or not a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array element j +</entry> </row> <row> <entry> </entry> <entry>max_nregions*k is TRUE if and only if regions j + 1</entry> </row> <row> <entry> </entry> <entry>and k + 1 are spatially adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about</entry> </row> <row> <entry> </entry> <entry>each region.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                               </tbody>  </table> </tables> <br/>
The global variables nbands, max_nregions and spatial_wght are also used as input by read_region_list( ). The following variables and arrays are modified and/or output by read_region_list( ):
</p>
  <p num="p-0379"> <tables id="TABLE-US-00117" num="00117"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="42pt" align="left"> </colspec> <colspec colname="2" colwidth="175pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>npix_data</entry> <entry>An unsigned int array containing the region number of</entry> </row> <row> <entry> </entry> <entry>pixels list stored as a vector. The j<sup>th </sup>element of the</entry> </row> <row> <entry> </entry> <entry>vector is the number of pixels in region j + 1.</entry> </row> <row> <entry>sum_data</entry> <entry>A double array containing the sum of the normalized</entry> </row> <row> <entry> </entry> <entry>input data values over all pixels in each region.</entry> </row> <row> <entry> </entry> <entry>Element j + nregions*b is the sum value for region j +</entry> </row> <row> <entry> </entry> <entry>1 and band b (first band is band number 0).</entry> </row> <row> <entry>sumsq_data</entry> <entry>A double array containing the sum of the square of the</entry> </row> <row> <entry> </entry> <entry>normalized input data values over all pixels in each</entry> </row> <row> <entry> </entry> <entry>region. (Actually contains values only if spatial_wght &gt;</entry> </row> <row> <entry> </entry> <entry>0.0.) Element j + nregions*b is the sum square value</entry> </row> <row> <entry> </entry> <entry>for region j + 1 and band b (first band is band number</entry> </row> <row> <entry> </entry> <entry>0).</entry> </row> <row> <entry>spatial_data</entry> <entry>A double array containing the region spatial feature</entry> </row> <row> <entry> </entry> <entry>value list stored as a vector. (Actually contains</entry> </row> <row> <entry> </entry> <entry>values only if spatial_wght &gt; 0.0.) The j<sup>th</sup> element of</entry> </row> <row> <entry> </entry> <entry>the vector is the spatial feature value for region j +</entry> </row> <row> <entry> </entry> <entry>1.</entry> </row> <row> <entry>nghbr_mask</entry> <entry>An unsigned char array of numbers designating whether</entry> </row> <row> <entry> </entry> <entry>or not a pair of regions are spatially adjacent (i.e.,</entry> </row> <row> <entry> </entry> <entry>neighbors). The value of the mask at array element j +</entry> </row> <row> <entry> </entry> <entry>max_nregions*k is TRUE if and only if regions j + 1 and</entry> </row> <row> <entry> </entry> <entry>k + 1 are spatially adjacent.</entry> </row> <row> <entry>region_list</entry> <entry>A reg_list (R_LIST) structure array pointing to a</entry> </row> <row> <entry> </entry> <entry>sequence of reg_struct (REGION) structure elements</entry> </row> <row> <entry> </entry> <entry>containing label and comparative information about each</entry> </row> <row> <entry> </entry> <entry>region.</entry> </row> <row> <entry>relabel_list</entry> <entry>An unsigned short array consisting of pairs of region</entry> </row> <row> <entry> </entry> <entry>labelings representing a renumbering of the region map</entry> </row> <row> <entry> </entry> <entry>labeling.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">                                </tbody>  </table> </tables> <br/>
The array nghbr_tmp is also passed to the read_region_list( ) function for use as work space. The read_region_list( ) function finds a renumbering (relabel_list) of the current region map labeling into the smallest possible range of labels starting at label “1, ” and adjusts the various data arrays and structures accordingly (npix_data, sum_data, nghbr_mask, region_list, and, if necessary, sumsq_data and spatial_data).
</p>
  <p num="p-0380">After the read_region_list( ) function exits, the variable nelements is found as the number of non-zero elements in the relabel_list array output by read_region_list( ), and the function update_rlblmap( ) is called with the following input variable and array data:</p>
  <p num="p-0381"> <tables id="TABLE-US-00118" num="00118"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="49pt" align="left"> </colspec> <colspec colname="2" colwidth="168pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>ncols</entry> <entry>An int variable containing the number of columns in the</entry> </row> <row> <entry> </entry> <entry>input image data</entry> </row> <row> <entry>nrows</entry> <entry>An int variable containing the number of rows in the</entry> </row> <row> <entry> </entry> <entry>input image data</entry> </row> <row> <entry>nelements</entry> <entry>An int variable containing the number of non-zero</entry> </row> <row> <entry> </entry> <entry>elements in the relabel_list array</entry> </row> <row> <entry>relabel_list</entry> <entry>An unsigned short array consisting of pairs of region</entry> </row> <row> <entry> </entry> <entry>labelings representing a renumbering of the region map</entry> </row> <row> <entry> </entry> <entry>labeling.</entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the region label map</entry> </row> <row> <entry> </entry> <entry>data as it existed prior to the call to lhseg( ).</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">             </tbody>  </table> </tables> <br/>
The following data array is modified by update_rlblmap( ):
</p>
  <p num="p-0382"> <tables id="TABLE-US-00119" num="00119"> <tgroup align="left" colsep="0" rowsep="0" cols="2"> <colspec colname="1" colwidth="56pt" align="left"> </colspec> <colspec colname="2" colwidth="161pt" align="left"> </colspec> </tgroup> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <row> <entry>rlblmap_data</entry> <entry>An unsigned short array containing the region label</entry> </row> <row> <entry> </entry> <entry>map data renumbered according to relabel_list.</entry> </row> <row> <entry namest="1" nameend="2" align="center" rowsep="1"> </entry> </row> <table frame="none" colsep="0" rowsep="0" class="description-table"> <thead>  </thead> <tbody valign="top">    </tbody>  </table> </tables> <br/>
The update_rlblmap( ) function renumbers the rlblmap_data array according to the input relabel_list array. This updates the rlblmap_data to reflect the merges performed by the call to lhseg( ) and the compacting of the region labeling representation performed by the function read_region_list( ).
</p>
  <p num="p-0383">At this point the function recur_hseg( ) exits returning the number of regions, nregions, to the calling function.</p>

</div>
  </div>
  </section>

  <section itemprop="claims" itemscope>
    <h2>Claims (<span itemprop="count">24</span>)</h2>
    
    <div itemprop="content" html><div mxw-id="PCLM8846938" lang="EN" load-source="patent-office" class="claims">
  <div class="claim"> <div id="CLM-00001" num="00001" class="claim">
    <div class="claim-text">1. A method of implementing a recursive hierarchical segmentation algorithm on a parallel computing platform, comprising:
<div class="claim-text">setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing; </div>
<div class="claim-text">setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation; and </div>
<div class="claim-text">implementing the segmentation algorithm according to the set bottom level and the set intermediate level. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00002" num="00002" class="claim">
    <div class="claim-text">2. A method as recited in <claim-ref idref="CLM-00001">claim 1</claim-ref>, further comprising setting a convergence check level of recursion, wherein after the recursive division is complete, a convergence check is performed which communicates data between processes running at the convergence check level and a top level.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00003" num="00003" class="claim">
    <div class="claim-text">3. A method as recited in <claim-ref idref="CLM-00002">claim 2</claim-ref>, wherein when the convergence check results in a favorable result, the convergence check level processes send their region label map data to a master program.</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00004" num="00004" class="claim">
    <div class="claim-text">4. A method of implementing a recursive hierarchical segmentation algorithm on a parallel computer, comprising:
<div class="claim-text">dividing an image from a first level of recursion to a bottom level of recursion, by: 
<div class="claim-text">when a current level of recursion is less than a preset intermediate level, recursively dividing an image into sections and spawning a new parallel process for each of the divided sections; </div>
<div class="claim-text">when a bottom level of recursion is greater than the current level of recursion which is greater than or equal to the preset intermediate level, recursively dividing the image into sections serially; and </div>
</div>
<div class="claim-text">implementing the segmentation algorithm using the divided sections and each section&#39;s respective process. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00005" num="00005" class="claim">
    <div class="claim-text">5. A method as recited in <claim-ref idref="CLM-00004">claim 4</claim-ref>, further comprising performing a convergence check when the current level of recursion equals the first level, and communicating between a preset convergence check level of recursion and the first level in performing the convergence check.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00006" num="00006" class="claim">
    <div class="claim-text">6. A method as recited in <claim-ref idref="CLM-00005">claim 5</claim-ref>, wherein the convergence check farther comprises communicating dissimilarity criterion values (critvals) from each process at the convergence check level of recursion to a process at the first level of recursion.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00007" num="00007" class="claim">
    <div class="claim-text">7. A method as recited in <claim-ref idref="CLM-00006">claim 6</claim-ref>, wherein the convergence check further comprises using the process at the first level of recursion, receiving the communicated critvals, summing the received critvals, and calculating a ratio of the summed critvals and the previously summed critvals.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00008" num="00008" class="claim">
    <div class="claim-text">8. A method as recited in <claim-ref idref="CLM-00007">claim 7</claim-ref>, wherein if the calculated ratio is higher than a preset threshold then the image data from the convergence check level processes are saved by a master program.</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00009" num="00009" class="claim">
    <div class="claim-text">9. A method of implementing a recursive hierarchical segmentation algorithm on a parallel computer, comprising:
<div class="claim-text">recursively dividing an image into sections from a top level of recursion to an intermediate level of recursion using parallel processes; </div>
<div class="claim-text">recursively dividing the image into sections from the intermediate level of recursion to a bottom level of recursion using serial processing; and </div>
<div class="claim-text">implementing the segmentation algorithm from the bottom level of recursion to the top level of recursion for each divided section using the section&#39;s respective process. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00010" num="00010" class="claim">
    <div class="claim-text">10. A method as recited in <claim-ref idref="CLM-00009">claim 9</claim-ref>, further comprising:</div>
    <div class="claim-text">performing a convergence check when a current level of recursion reaches the first level, and communicating between a preset convergence check level of recursion and the first level in performing the convergence check.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00011" num="00011" class="claim">
    <div class="claim-text">11. A method as recited in <claim-ref idref="CLM-00010">claim 10</claim-ref>, further comprising:
<div class="claim-text">sending, by processes running at the convergence check level, region label map data to a master program if the convergence check results in a favorable result. </div>
</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00012" num="00012" class="claim">
    <div class="claim-text">12. A computer readable storage medium, storing a method of implementing a recursive hierarchical segmentation algorithm on a parallel computing platform, the computer readable storage medium instructing a computer to perform:
<div class="claim-text">setting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing; </div>
<div class="claim-text">setting an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation; and </div>
<div class="claim-text">implementing the segmentation algorithm according to the set bottom level and the set intermediate level. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00013" num="00013" class="claim">
    <div class="claim-text">13. A computer readable storage medium as recited in <claim-ref idref="CLM-00012">claim 12</claim-ref>, further comprising setting a convergence check level of recursion, wherein after the recursive division is complete, a convergence check is performed which communicates data between processes running at the convergence check level and a top level.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00014" num="00014" class="claim">
    <div class="claim-text">14. A computer readable storage medium as recited in <claim-ref idref="CLM-00013">claim 13</claim-ref>, wherein when the convergence check results in a favorable result, the convergence check level processes send their region label map data to a master program.</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00015" num="00015" class="claim">
    <div class="claim-text">15. A computer readable storage medium, storing a method of implementing a recursive hierarchical segmentation algorithm on a parallel computing platform, the computer readable storage medium instructing a computer to perform:
<div class="claim-text"> <div class="claim-text">dividing an image from a first level of recursion to a bottom level of recursion, by: </div> <div class="claim-text">when a current level of recursion is less than a preset intermediate level, recursively dividing an image into sections and spawning a new parallel process for each of the divided sections; </div> </div>
<div class="claim-text">when a bottom level of recursion is greater than the current level of recursion which is greater than or equal to the preset intermediate level, recursively dividing the image into sections serially; and </div>
<div class="claim-text">implementing the segmentation algorithm using the divided sections and each section&#39;s respective process. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00016" num="00016" class="claim">
    <div class="claim-text">16. A computer readable storage medium as recited in <claim-ref idref="CLM-00015">claim 15</claim-ref>, further comprising performing a convergence check when the current level of recursion equals the first level, and communicating between a preset convergence check level of recursion and the first level in performing the convergence check.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00017" num="00017" class="claim">
    <div class="claim-text">17. A computer readable storage medium as recited in <claim-ref idref="CLM-00016">claim 16</claim-ref>, wherein the convergence check further comprises communicating dissimilarity criterion values (critvals) from each process at the convergence check level of recursion to a process at the first level of recursion.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00018" num="00018" class="claim">
    <div class="claim-text">18. A computer readable storage medium as recited in <claim-ref idref="CLM-00017">claim 17</claim-ref>, wherein the convergence check further comprises using the process at the first level of recursion, receiving the communicated critvals, summing the received critvals, and calculating a ratio of the summed critvals and the previously summed critvals.</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00019" num="00019" class="claim">
    <div class="claim-text">19. A computer readable storage medium as recited in <claim-ref idref="CLM-00018">claim 18</claim-ref>, wherein if the calculated ratio is higher than a preset threshold then the image data from the convergence check level processes are saved by a master program.</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00020" num="00020" class="claim">
    <div class="claim-text">20. A computer readable storage medium, storing a method of implementing a recursive hierarchical segmentation algorithm on a parallel computing platform, the computer readable storage medium instructing a computer to perform:
<div class="claim-text">recursively dividing an image into sections from a top level of recursion to an intermediate level of recursion using parallel processes; </div>
<div class="claim-text">recursively dividing the image into sections from the intermediate level of recursion to a bottom level of recursion using serial processing; and </div>
<div class="claim-text">implementing the segmentation algorithm from the bottom level of recursion to the top level of recursion for each divided section using the section&#39;s respective process. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00021" num="00021" class="claim">
    <div class="claim-text">21. A computer readable storage medium as recited in <claim-ref idref="CLM-00020">claim 20</claim-ref>, further comprising:
<div class="claim-text">performing a convergence check when a current level of recursion reaches the first level, and communicating between a preset convergence check level of recursion and the first level in performing the convergence check. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00022" num="00022" class="claim">
    <div class="claim-text">22. A computer readable storage medium as recited in <claim-ref idref="CLM-00021">claim 21</claim-ref>, further comprising:
<div class="claim-text">sending, by processes running at the convergence check level, region label map data to a master program if the convergence check results in a favorable result. </div>
</div>
  </div>
  </div> <div class="claim"> <div id="CLM-00023" num="00023" class="claim">
    <div class="claim-text">23. An apparatus comprising:
<div class="claim-text">an input unit, inputting a bottom level of recursion that defines where a recursive division of an image into sections stops dividing, and an intermediate level of recursion where the recursive division changes from a parallel implementation into a serial implementation; </div>
<div class="claim-text">a processing unit, implementing a recursive hierarchical segmentation algorithm using the levels input from the input unit. </div>
</div>
  </div>
  </div> <div class="claim-dependent"> <div id="CLM-00024" num="00024" class="claim">
    <div class="claim-text">24. An apparatus as recited in <claim-ref idref="CLM-00023">claim 23</claim-ref>, wherein the input unit further comprises inputting a convergence check level of recursion, wherein after the recursive division is complete, a convergence check is performed which communicates data between processes running at the convergence check level and a top level.</div>
  </div>
</div> </div>
  </div>
  </section>

  <section itemprop="application" itemscope>

    <section itemprop="metadata" itemscope>
        <span itemprop="applicationNumber">US09/839,147</span>
        <span itemprop="priorityDate">2001-04-23</span>
        <span itemprop="filingDate">2001-04-23</span>
        <span itemprop="title">Method for implementation of recursive hierarchical segmentation on parallel computers 
       </span>
        <span itemprop="ifiStatus">Active</span>
        <span itemprop="ifiExpiration">2023-04-09</span>
        <a href="/patent/US6895115B2/en">
            <span itemprop="representativePublication">US6895115B2</span>
            (<span itemprop="primaryLanguage">en</span>)
        </a>
    </section>

    <h2>Priority Applications (1)</h2>
        <table>
            <thead>
                <tr>
                    <th>Application Number</th>
                    <th>Priority Date</th>
                    <th>Filing Date</th>
                    <th>Title</th>
                </tr>
            </thead>
            <tbody>
            <tr itemprop="priorityApps" itemscope repeat>
                <td>
                   <span itemprop="applicationNumber">US09/839,147</span>
                   
                   <a href="/patent/US6895115B2/en">
                        <span itemprop="representativePublication">US6895115B2</span>
                          (<span itemprop="primaryLanguage">en</span>)
                      </a>
                <td itemprop="priorityDate">2001-04-23</td>
                <td itemprop="filingDate">2001-04-23</td>
                <td itemprop="title">Method for implementation of recursive hierarchical segmentation on parallel computers 
       </td>
              </tr>
           </tbody>
       </table>

    <h2>Applications Claiming Priority (1)</h2>
        <table>
            <thead>
                <tr>
                    <th>Application Number</th>
                    <th>Priority Date</th>
                    <th>Filing Date</th>
                    <th>Title</th>
                </tr>
            </thead>
            <tbody>
            <tr itemprop="appsClaimingPriority" itemscope repeat>
                <td>
                   <span itemprop="applicationNumber">US09/839,147</span>
                   <a href="/patent/US6895115B2/en">
                        <span itemprop="representativePublication">US6895115B2</span>
                          (<span itemprop="primaryLanguage">en</span>)
                      </a>
                <td itemprop="priorityDate">2001-04-23</td>
                <td itemprop="filingDate">2001-04-23</td>
                <td itemprop="title">Method for implementation of recursive hierarchical segmentation on parallel computers 
       </td>
              </tr>
           </tbody>
       </table>

    

    

    <h2>Publications (2)</h2>
        <table>
            <thead>
                <tr>
                    <th>Publication Number</th>
                    <th>Publication Date</th>
                </tr>
            </thead>
            <tbody>
            <tr itemprop="pubs" itemscope repeat>
                <td>
                   <span itemprop="publicationNumber">US20030081833A1</span>
                   
                   <a href="/patent/US20030081833A1/en">US20030081833A1
                       (<span itemprop="primaryLanguage">en</span>)
                   </a>
                </td>
                <td itemprop="publicationDate">2003-05-01</td>
              </tr><tr itemprop="pubs" itemscope repeat>
                <td>
                   <span itemprop="publicationNumber">US6895115B2</span>
                   
                   <span itemprop="thisPatent">true</span>
                   <a href="/patent/US6895115B2/en">US6895115B2
                       (<span itemprop="primaryLanguage">en</span>)
                   </a>
                </td>
                <td itemprop="publicationDate">2005-05-17</td>
              </tr>
           </tbody>
        </table>

  </section>

  <section itemprop="family" itemscope>
    <h1>Family</h1>
    <h2>ID=25278968</h2>

    <h2>Family Applications (1)</h2>
        <table>
            <thead>
                <tr>
                    <th>Application Number</th>
                    <th>Title</th>
                    <th>Priority Date</th>
                    <th>Filing Date</th>
                </tr>
            </thead>
            <tbody>
            <tr itemprop="applications" itemscope repeat>
                <td>
                    <span itemprop="applicationNumber">US09/839,147</span>
                    <span itemprop="ifiStatus">Active</span>
                    <span itemprop="ifiExpiration">2023-04-09</span>
                    <a href="/patent/US6895115B2/en">
                        <span itemprop="representativePublication">US6895115B2</span>
                          (<span itemprop="primaryLanguage">en</span>)
                      </a>
                </td>
                <td itemprop="priorityDate">2001-04-23</td>
                <td itemprop="filingDate">2001-04-23</td>
                <td itemprop="title">Method for implementation of recursive hierarchical segmentation on parallel computers 
       </td>
              </tr>
           </tbody>
        </table>

    

    

    <h2>Country Status (1)</h2>
      <table>
        <thead>
          <tr>
            <th>Country</th>
            <th>Link</th>
          </tr>
        </thead>
        <tbody>
        <tr itemprop="countryStatus" itemscope repeat>
            <td>
              <span itemprop="countryCode">US</span>
                (<span itemprop="num">1</span>)
              <meta itemprop="thisCountry" content="true">
            </td>
            <td>
              <a href="/patent/US6895115B2/en">
                <span itemprop="representativePublication">US6895115B2</span>
                  (<span itemprop="primaryLanguage">en</span>)
              </a>
            </td>
          </tr>
      </tbody>
    </table>

    <h2>Cited By (16)</h2>
    <table>
      <caption>* Cited by examiner, † Cited by third party</caption>
      <thead>
        <tr>
          <th>Publication number</th>
          <th>Priority date</th>
          <th>Publication date</th>
          <th>Assignee</th>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20060050984A1/en">
              <span itemprop="publicationNumber">US20060050984A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2004-05-11</td>
          <td itemprop="publicationDate">2006-03-09</td>
          <td><span itemprop="assigneeOriginal">National Aeronautics And Space Administration As Representing The United States Government</span></td>
          <td itemprop="title">Split-remerge method for eliminating processing window artifacts in recursive hierarchical segmentation 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US7346205B2/en">
              <span itemprop="publicationNumber">US7346205B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2003-03-27</td>
          <td itemprop="publicationDate">2008-03-18</td>
          <td><span itemprop="assigneeOriginal">Bartron Medical Imaging, Llc</span></td>
          <td itemprop="title">System and method for rapidly identifying pathogens, bacteria and abnormal cells 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20080294686A1/en">
              <span itemprop="publicationNumber">US20080294686A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2007-05-25</td>
          <td itemprop="publicationDate">2008-11-27</td>
          <td><span itemprop="assigneeOriginal">The Research Foundation Of State University Of New York</span></td>
          <td itemprop="title">Spectral clustering for multi-type relational data 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20080301211A1/en">
              <span itemprop="publicationNumber">US20080301211A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2007-06-01</td>
          <td itemprop="publicationDate">2008-12-04</td>
          <td><span itemprop="assigneeOriginal">United States of America as represented by the Administrator of the National Aeronautics and</span></td>
          <td itemprop="title">Systems, methods and apparatus for d-dimensional formulation and implementation of recursive hierarchical segmentation 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20090123070A1/en">
              <span itemprop="publicationNumber">US20090123070A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2007-11-14</td>
          <td itemprop="publicationDate">2009-05-14</td>
          <td><span itemprop="assigneeOriginal">Itt Manufacturing Enterprises Inc.</span></td>
          <td itemprop="title">Segmentation-based image processing system 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20090320005A1/en">
              <span itemprop="publicationNumber">US20090320005A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2008-06-04</td>
          <td itemprop="publicationDate">2009-12-24</td>
          <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
          <td itemprop="title">Controlling parallelization of recursion using pluggable policies 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20100097456A1/en">
              <span itemprop="publicationNumber">US20100097456A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2008-04-24</td>
          <td itemprop="publicationDate">2010-04-22</td>
          <td><span itemprop="assigneeOriginal">Gm Global Technology Operations, Inc.</span></td>
          <td itemprop="title">Clear path detection using a hierachical approach 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20100097457A1/en">
              <span itemprop="publicationNumber">US20100097457A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2008-04-24</td>
          <td itemprop="publicationDate">2010-04-22</td>
          <td><span itemprop="assigneeOriginal">Gm Global Technology Opetations, Inc.</span></td>
          <td itemprop="title">Clear path detection with patch smoothing approach 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20110060891A1/en">
              <span itemprop="publicationNumber">US20110060891A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2009-09-04</td>
          <td itemprop="publicationDate">2011-03-10</td>
          <td><span itemprop="assigneeOriginal">International Business Machines Corporation</span></td>
          <td itemprop="title">Parallel pipelined vector reduction in a data processing system 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20110221926A1/en">
              <span itemprop="publicationNumber">US20110221926A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2010-03-12</td>
          <td itemprop="publicationDate">2011-09-15</td>
          <td><span itemprop="assigneeOriginal">Kanaev Andrey V</span></td>
          <td itemprop="title">Spectral Anomaly Detection in Deep Shadows 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20120076408A1/en">
              <span itemprop="publicationNumber">US20120076408A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2010-09-29</td>
          <td itemprop="publicationDate">2012-03-29</td>
          <td><span itemprop="assigneeOriginal">Andong University Industry-Academic Cooperation Foundation</span></td>
          <td itemprop="title">Method and system for detecting object 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20120089954A1/en">
              <span itemprop="publicationNumber">US20120089954A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2008-11-04</td>
          <td itemprop="publicationDate">2012-04-12</td>
          <td><span itemprop="assigneeOriginal">Cadence Design Systems, Inc.</span></td>
          <td itemprop="title">Methods, systems, and computer program product for parallelizing tasks in processing an electronic circuit design 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8204842B1/en">
              <span itemprop="publicationNumber">US8204842B1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2006-01-31</td>
          <td itemprop="publicationDate">2012-06-19</td>
          <td><span itemprop="assigneeOriginal">The Research Foundation Of State University Of New York</span></td>
          <td itemprop="title">System and method for image annotation and multi-modal image retrieval using probabilistic semantic models comprising at least one joint probability distribution 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8839214B2/en">
              <span itemprop="publicationNumber">US8839214B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2010-06-30</td>
          <td itemprop="publicationDate">2014-09-16</td>
          <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
          <td itemprop="title">Indexable type transformations 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/CN104331336A/en">
              <span itemprop="publicationNumber">CN104331336A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2014-11-21</td>
          <td itemprop="publicationDate">2015-02-04</td>
          <td><span itemprop="assigneeOriginal">北京应用物理与计算数学研究所</span></td>
          <td itemprop="title">Multilayer nest load balancing method matched with high-performance computer structure 
       </td>
        </tr><tr itemprop="forwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US10165488B2/en">
              <span itemprop="publicationNumber">US10165488B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2016-06-16</td>
          <td itemprop="publicationDate">2018-12-25</td>
          <td><span itemprop="assigneeOriginal">Yandex Europe Ag</span></td>
          <td itemprop="title">Method of and system for processing a transaction request in distributed data processing systems 
       </td>
        </tr>
      </tbody>
    </table>

    <h2>Families Citing this family (11)</h2>
    <table>
      <caption>* Cited by examiner, † Cited by third party</caption>
      <thead>
        <tr>
          <th>Publication number</th>
          <th>Priority date</th>
          <th>Publication date</th>
          <th>Assignee</th>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US7379421B1/en">
              <span itemprop="publicationNumber">US7379421B1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2002-07-23</td>
          <td itemprop="publicationDate">2008-05-27</td>
          <td><span itemprop="assigneeOriginal">At&amp;T Delaware Intellectual Property, Inc.</span></td>
          <td itemprop="title">System and method for forwarding messages 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US7779008B2/en">
              <span itemprop="publicationNumber">US7779008B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2005-02-16</td>
          <td itemprop="publicationDate">2010-08-17</td>
          <td><span itemprop="assigneeOriginal">Oracle International Corporation</span></td>
          <td itemprop="title">Parallel partition-wise aggregation 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8144123B2/en">
              <span itemprop="publicationNumber">US8144123B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2007-08-14</td>
          <td itemprop="publicationDate">2012-03-27</td>
          <td><span itemprop="assigneeOriginal">Fuji Xerox Co., Ltd.</span></td>
          <td itemprop="title">Dynamically controlling a cursor on a screen when using a video camera as a pointing device 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8996846B2/en">
              <span itemprop="publicationNumber">US8996846B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2007-09-27</td>
          <td itemprop="publicationDate">2015-03-31</td>
          <td><span itemprop="assigneeOriginal">Nvidia Corporation</span></td>
          <td itemprop="title">System, method and computer program product for performing a scan operation 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8661226B2/en">
              <span itemprop="publicationNumber">US8661226B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2007-11-15</td>
          <td itemprop="publicationDate">2014-02-25</td>
          <td><span itemprop="assigneeOriginal">Nvidia Corporation</span></td>
          <td itemprop="title">System, method, and computer program product for performing a scan operation on a sequence of single-bit values using a parallel processor architecture 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US8155433B2/en">
              <span itemprop="publicationNumber">US8155433B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2008-07-10</td>
          <td itemprop="publicationDate">2012-04-10</td>
          <td><span itemprop="assigneeOriginal">Goodrich Corporation</span></td>
          <td itemprop="title">Method of object location in airborne imagery using recursive quad space image processing 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20140307055A1/en">
              <span itemprop="publicationNumber">US20140307055A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            
            
          </td>
          <td itemprop="priorityDate">2013-04-15</td>
          <td itemprop="publicationDate">2014-10-16</td>
          <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
          <td itemprop="title">Intensity-modulated light pattern for active stereo 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US9685056B2/en">
              <span itemprop="publicationNumber">US9685056B2</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2014-03-21</td>
          <td itemprop="publicationDate">2017-06-20</td>
          <td><span itemprop="assigneeOriginal">Qognify Ltd.</span></td>
          <td itemprop="title">Robust change-detection system and method 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/CN106408572A/en">
              <span itemprop="publicationNumber">CN106408572A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2016-09-23</td>
          <td itemprop="publicationDate">2017-02-15</td>
          <td><span itemprop="assigneeOriginal">交通运输部规划研究院</span></td>
          <td itemprop="title">Method and system for monitoring container storage yard at port by utilizing remote sensing image 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/CN106408027A/en">
              <span itemprop="publicationNumber">CN106408027A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2016-09-23</td>
          <td itemprop="publicationDate">2017-02-15</td>
          <td><span itemprop="assigneeOriginal">交通运输部规划研究院</span></td>
          <td itemprop="title">Method and system for extracting image of logistics warehouse behind storage yard at port 
       </td>
        </tr><tr itemprop="forwardReferencesFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/CN106407941A/en">
              <span itemprop="publicationNumber">CN106407941A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">2016-09-23</td>
          <td itemprop="publicationDate">2017-02-15</td>
          <td><span itemprop="assigneeOriginal">交通运输部规划研究院</span></td>
          <td itemprop="title">Method and system for monitoring port sea reclamation based on object-oriented image analysis 
       </td>
        </tr>
      </tbody>
    </table>

    <h2>Citations (2)</h2>
    <table>
      <caption>* Cited by examiner, † Cited by third party</caption>
      <thead>
        <tr>
          <th>Publication number</th>
          <th>Priority date</th>
          <th>Publication date</th>
          <th>Assignee</th>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="backwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US4791486A/en">
              <span itemprop="publicationNumber">US4791486A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">1985-02-05</td>
          <td itemprop="publicationDate">1988-12-13</td>
          <td><span itemprop="assigneeOriginal">British Telecommunications Public Limited Company</span></td>
          <td itemprop="title">Recursive image encoding/decoding using interpolation within variably sub-divided picture areas 
       </td>
        </tr><tr itemprop="backwardReferencesOrig" itemscope repeat>
          <td>
            
            
            <a href="/patent/US5995668A/en">
              <span itemprop="publicationNumber">US5995668A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">1995-10-25</td>
          <td itemprop="publicationDate">1999-11-30</td>
          <td><span itemprop="assigneeOriginal">U.S. Philips Corporation</span></td>
          <td itemprop="title">Segmented picture coding method and system, and corresponding decoding method and system 
       </td>
        </tr>
      </tbody>
    </table>

    

    
    <ul>
      
      <li itemprop="applicationsByYear" itemscope repeat>
        <span itemprop="year">2001</span>
        <ul>
          
          <li itemprop="application" itemscope repeat>
            <span itemprop="filingDate">2001-04-23</span>
            <span itemprop="countryCode">US</span>
            <span itemprop="applicationNumber">US09/839,147</span>
            <a href="/patent/US6895115B2/en"><span itemprop="documentId">patent/US6895115B2/en</span></a>
            <span itemprop="legalStatusCat">active</span>
            <span itemprop="legalStatus">Active</span>
            
            <span itemprop="thisApp" content="true" bool></span>
            
          </li>
          
        </ul>
      </li>
      
    </ul>
    

    </section>

  <section>
    <h2>Patent Citations (2)</h2>
    <table>
      <caption>* Cited by examiner, † Cited by third party</caption>
      <thead>
        <tr>
          <th>Publication number</th>
          <th>Priority date</th>
          <th>Publication date</th>
          <th>Assignee</th>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="backwardReferences" itemscope repeat>
          <td>
            
            
            <a href="/patent/US4791486A/en">
              <span itemprop="publicationNumber">US4791486A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">1985-02-05</td>
          <td itemprop="publicationDate">1988-12-13</td>
          <td><span itemprop="assigneeOriginal">British Telecommunications Public Limited Company</span></td>
          <td itemprop="title">Recursive image encoding/decoding using interpolation within variably sub-divided picture areas 
       </td>
        </tr><tr itemprop="backwardReferences" itemscope repeat>
          <td>
            
            
            <a href="/patent/US5995668A/en">
              <span itemprop="publicationNumber">US5995668A</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
            <span itemprop="examinerCited">*</span>
            
          </td>
          <td itemprop="priorityDate">1995-10-25</td>
          <td itemprop="publicationDate">1999-11-30</td>
          <td><span itemprop="assigneeOriginal">U.S. Philips Corporation</span></td>
          <td itemprop="title">Segmented picture coding method and system, and corresponding decoding method and system 
       </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Non-Patent Citations (5)</h2>
    <table>
      <caption>* Cited by examiner, † Cited by third party</caption>
      <thead>
        <tr>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="detailedNonPatentLiterature" itemscope repeat>
          <td>
            <span itemprop="title">Beaulieu et al, Hierarchy in Picture Segmentation: A Stepwise Optimization Approach, IEEE Transactions on Pattern Analysis and Machine Intelligence, Feb. 1989, vol. 11, No. 2, pp. 150-163.*</span>
            <span itemprop="examinerCited">*</span>
            
          </td>
        </tr><tr itemprop="detailedNonPatentLiterature" itemscope repeat>
          <td>
            <span itemprop="title">J.A. Hird, Multiresolution object detection and segmentation using top-down algorithms, Third International Conference on Image Processing and its Applications, Jul. 18-20, 1989, pp. 416-420.*</span>
            <span itemprop="examinerCited">*</span>
            
          </td>
        </tr><tr itemprop="detailedNonPatentLiterature" itemscope repeat>
          <td>
            <span itemprop="title">J.C. Tilton, A recursive PVM implementation of an image segmentation algorithm with performance results comparing the HIVE and the Cray T3E, The Seventh Symposium on the Frontiers of Massively Parallel Computation, Feb. 21-25, 1999, pp. 146-153.</span>
            <span itemprop="examinerCited">*</span>
            
          </td>
        </tr><tr itemprop="detailedNonPatentLiterature" itemscope repeat>
          <td>
            <span itemprop="title">Schachter et al, Some experiments in image segmentation by clustering of local feature values, Pattern Recognition, 1979, vol. 11, No. 1, pp. 19-28.*</span>
            <span itemprop="examinerCited">*</span>
            
          </td>
        </tr><tr itemprop="detailedNonPatentLiterature" itemscope repeat>
          <td>
            <span itemprop="title">Tilton et al, Segmentation of remotely sensed data using parallel region growing, Proceedings of the Ninth International Symposium on Machine Processing of Remotely Sensed Data, Jun. 1983, pp. 130-137.*</span>
            <span itemprop="examinerCited">*</span>
            
          </td>
        </tr>
      </tbody>
    </table>
  </section>

  <h2>Cited By (27)</h2>
  <table>
    <caption>* Cited by examiner, † Cited by third party</caption>
    <thead>
      <tr>
        <th>Publication number</th>
        <th>Priority date</th>
        <th>Publication date</th>
        <th>Assignee</th>
        <th>Title</th>
      </tr>
    </thead>
    <tbody>
      <tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US7346205B2/en">
            <span itemprop="publicationNumber">US7346205B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2003-03-27</td>
        <td itemprop="publicationDate">2008-03-18</td>
        <td><span itemprop="assigneeOriginal">Bartron Medical Imaging, Llc</span></td>
        <td itemprop="title">System and method for rapidly identifying pathogens, bacteria and abnormal cells 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US7697759B2/en">
            <span itemprop="publicationNumber">US7697759B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2004-05-11</td>
        <td itemprop="publicationDate">2010-04-13</td>
        <td><span itemprop="assigneeOriginal">The United States Of America As Represented By The Administrator Of The National Aeronautics And Space Administration</span></td>
        <td itemprop="title">Split-remerge method for eliminating processing window artifacts in recursive hierarchical segmentation 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20060050984A1/en">
            <span itemprop="publicationNumber">US20060050984A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2004-05-11</td>
        <td itemprop="publicationDate">2006-03-09</td>
        <td><span itemprop="assigneeOriginal">National Aeronautics And Space Administration As Representing The United States Government</span></td>
        <td itemprop="title">Split-remerge method for eliminating processing window artifacts in recursive hierarchical segmentation 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8204842B1/en">
            <span itemprop="publicationNumber">US8204842B1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2006-01-31</td>
        <td itemprop="publicationDate">2012-06-19</td>
        <td><span itemprop="assigneeOriginal">The Research Foundation Of State University Of New York</span></td>
        <td itemprop="title">System and method for image annotation and multi-modal image retrieval using probabilistic semantic models comprising at least one joint probability distribution 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20080294686A1/en">
            <span itemprop="publicationNumber">US20080294686A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2007-05-25</td>
        <td itemprop="publicationDate">2008-11-27</td>
        <td><span itemprop="assigneeOriginal">The Research Foundation Of State University Of New York</span></td>
        <td itemprop="title">Spectral clustering for multi-type relational data 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8185481B2/en">
            <span itemprop="publicationNumber">US8185481B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2007-05-25</td>
        <td itemprop="publicationDate">2012-05-22</td>
        <td><span itemprop="assigneeOriginal">The Research Foundation Of State University Of New York</span></td>
        <td itemprop="title">Spectral clustering for multi-type relational data 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20080301211A1/en">
            <span itemprop="publicationNumber">US20080301211A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2007-06-01</td>
        <td itemprop="publicationDate">2008-12-04</td>
        <td><span itemprop="assigneeOriginal">United States of America as represented by the Administrator of the National Aeronautics and</span></td>
        <td itemprop="title">Systems, methods and apparatus for d-dimensional formulation and implementation of recursive hierarchical segmentation 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20090123070A1/en">
            <span itemprop="publicationNumber">US20090123070A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2007-11-14</td>
        <td itemprop="publicationDate">2009-05-14</td>
        <td><span itemprop="assigneeOriginal">Itt Manufacturing Enterprises Inc.</span></td>
        <td itemprop="title">Segmentation-based image processing system 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8260048B2/en">
            <span itemprop="publicationNumber">US8260048B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2007-11-14</td>
        <td itemprop="publicationDate">2012-09-04</td>
        <td><span itemprop="assigneeOriginal">Exelis Inc.</span></td>
        <td itemprop="title">Segmentation-based image processing system 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8421859B2/en">
            <span itemprop="publicationNumber">US8421859B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-04-24</td>
        <td itemprop="publicationDate">2013-04-16</td>
        <td><span itemprop="assigneeOriginal">GM Global Technology Operations LLC</span></td>
        <td itemprop="title">Clear path detection using a hierachical approach 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20100097456A1/en">
            <span itemprop="publicationNumber">US20100097456A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-04-24</td>
        <td itemprop="publicationDate">2010-04-22</td>
        <td><span itemprop="assigneeOriginal">Gm Global Technology Operations, Inc.</span></td>
        <td itemprop="title">Clear path detection using a hierachical approach 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20100097457A1/en">
            <span itemprop="publicationNumber">US20100097457A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-04-24</td>
        <td itemprop="publicationDate">2010-04-22</td>
        <td><span itemprop="assigneeOriginal">Gm Global Technology Opetations, Inc.</span></td>
        <td itemprop="title">Clear path detection with patch smoothing approach 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8890951B2/en">
            <span itemprop="publicationNumber">US8890951B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-04-24</td>
        <td itemprop="publicationDate">2014-11-18</td>
        <td><span itemprop="assigneeOriginal">GM Global Technology Operations LLC</span></td>
        <td itemprop="title">Clear path detection with patch smoothing approach 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20090320005A1/en">
            <span itemprop="publicationNumber">US20090320005A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-06-04</td>
        <td itemprop="publicationDate">2009-12-24</td>
        <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
        <td itemprop="title">Controlling parallelization of recursion using pluggable policies 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8719803B2/en">
            <span itemprop="publicationNumber">US8719803B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2008-06-04</td>
        <td itemprop="publicationDate">2014-05-06</td>
        <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
        <td itemprop="title">Controlling parallelization of recursion using pluggable policies 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20120089954A1/en">
            <span itemprop="publicationNumber">US20120089954A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-11-04</td>
        <td itemprop="publicationDate">2012-04-12</td>
        <td><span itemprop="assigneeOriginal">Cadence Design Systems, Inc.</span></td>
        <td itemprop="title">Methods, systems, and computer program product for parallelizing tasks in processing an electronic circuit design 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8418094B2/en">
            <span itemprop="publicationNumber">US8418094B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2008-11-04</td>
        <td itemprop="publicationDate">2013-04-09</td>
        <td><span itemprop="assigneeOriginal">Cadence Design Systems, Inc.</span></td>
        <td itemprop="title">Methods, systems, and computer program product for parallelizing tasks in processing an electronic circuit design 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20110060891A1/en">
            <span itemprop="publicationNumber">US20110060891A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2009-09-04</td>
        <td itemprop="publicationDate">2011-03-10</td>
        <td><span itemprop="assigneeOriginal">International Business Machines Corporation</span></td>
        <td itemprop="title">Parallel pipelined vector reduction in a data processing system 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8447954B2/en">
            <span itemprop="publicationNumber">US8447954B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2009-09-04</td>
        <td itemprop="publicationDate">2013-05-21</td>
        <td><span itemprop="assigneeOriginal">International Business Machines Corporation</span></td>
        <td itemprop="title">Parallel pipelined vector reduction in a data processing system 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8559719B2/en">
            <span itemprop="publicationNumber">US8559719B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2010-03-12</td>
        <td itemprop="publicationDate">2013-10-15</td>
        <td><span itemprop="assigneeOriginal">The United States Of America, As Represented By The Secretary Of The Navy</span></td>
        <td itemprop="title">Spectral anomaly detection in deep shadows 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20110221926A1/en">
            <span itemprop="publicationNumber">US20110221926A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2010-03-12</td>
        <td itemprop="publicationDate">2011-09-15</td>
        <td><span itemprop="assigneeOriginal">Kanaev Andrey V</span></td>
        <td itemprop="title">Spectral Anomaly Detection in Deep Shadows 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8839214B2/en">
            <span itemprop="publicationNumber">US8839214B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2010-06-30</td>
        <td itemprop="publicationDate">2014-09-16</td>
        <td><span itemprop="assigneeOriginal">Microsoft Corporation</span></td>
        <td itemprop="title">Indexable type transformations 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US8520893B2/en">
            <span itemprop="publicationNumber">US8520893B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2010-09-29</td>
        <td itemprop="publicationDate">2013-08-27</td>
        <td><span itemprop="assigneeOriginal">Electronics And Telecommunications Research Institute</span></td>
        <td itemprop="title">Method and system for detecting object 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US20120076408A1/en">
            <span itemprop="publicationNumber">US20120076408A1</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2010-09-29</td>
        <td itemprop="publicationDate">2012-03-29</td>
        <td><span itemprop="assigneeOriginal">Andong University Industry-Academic Cooperation Foundation</span></td>
        <td itemprop="title">Method and system for detecting object 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/CN104331336A/en">
            <span itemprop="publicationNumber">CN104331336A</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2014-11-21</td>
        <td itemprop="publicationDate">2015-02-04</td>
        <td><span itemprop="assigneeOriginal">北京应用物理与计算数学研究所</span></td>
        <td itemprop="title">Multilayer nest load balancing method matched with high-performance computer structure 
       </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/CN104331336B/en">
            <span itemprop="publicationNumber">CN104331336B</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          <span itemprop="examinerCited">*</span>
          
        </td>
        <td itemprop="priorityDate">2014-11-21</td>
        <td itemprop="publicationDate">2016-01-20</td>
        <td><span itemprop="assigneeOriginal">北京应用物理与计算数学研究所</span></td>
        <td itemprop="title">  The multilayer structure adapted to the high-performance computer nesting load balancing method  </td>
      </tr><tr itemprop="forwardReferences" itemscope repeat>
        <td>
          
          
          <a href="/patent/US10165488B2/en">
            <span itemprop="publicationNumber">US10165488B2</span>
            (<span itemprop="primaryLanguage">en</span>)
          </a>
          
          
        </td>
        <td itemprop="priorityDate">2016-06-16</td>
        <td itemprop="publicationDate">2018-12-25</td>
        <td><span itemprop="assigneeOriginal">Yandex Europe Ag</span></td>
        <td itemprop="title">Method of and system for processing a transaction request in distributed data processing systems 
       </td>
      </tr>
    </tbody>
  </table>

  <section>
    <h2>Also Published As</h2>
    <table>
      <thead>
        <tr>
          <th>Publication number</th>
          <th>Publication date</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="docdbFamily" itemscope repeat>
          <td>
            
            
            <a href="/patent/US20030081833A1/en">
              <span itemprop="publicationNumber">US20030081833A1</span>
              (<span itemprop="primaryLanguage">en</span>)
            </a>
          </td>
          <td itemprop="publicationDate">2003-05-01</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Similar Documents</h2>
    <table>
      <thead>
        <tr>
          <th>Publication</th>
          <th>Publication Date</th>
          <th>Title</th>
        </tr>
      </thead>
      <tbody>
        <tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="2971321719576210987">
              <a href="/scholar/2971321719576210987"><span itemprop="scholarAuthors">Sarkar et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1996">1996</time>
            
          </td>
          <td itemprop="title">Quantitative measures of change based on feature organization: Eigenvalues and eigenvectors</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US7567252B2/en">
                <span itemprop="publicationNumber">US7567252B2</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="2009-07-28">2009-07-28</time>
            
            
          </td>
          <td itemprop="title">Optimizing performance of a graphics processing unit for efficient execution of general matrix operations 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="8802554828017156616">
              <a href="/scholar/8802554828017156616"><span itemprop="scholarAuthors">Tsitsiklis</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1995">1995</time>
            
          </td>
          <td itemprop="title">Efficient algorithms for globally optimal trajectories</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="2921820400002994359">
              <a href="/scholar/2921820400002994359"><span itemprop="scholarAuthors">Miranker et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1984">1984</time>
            
          </td>
          <td itemprop="title">Spacetime representations of computational structures</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="12212388259805771983">
              <a href="/scholar/12212388259805771983"><span itemprop="scholarAuthors">Prager</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1980">1980</time>
            
          </td>
          <td itemprop="title">Extracting and labeling boundary segments in natural scenes</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US6744923B1/en">
                <span itemprop="publicationNumber">US6744923B1</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="2004-06-01">2004-06-01</time>
            
            
          </td>
          <td itemprop="title">System and method for fast approximate energy minimization via graph cuts 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="12997878014783874303">
              <a href="/scholar/12997878014783874303"><span itemprop="scholarAuthors">Atallah et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1989">1989</time>
            
          </td>
          <td itemprop="title">Cascading divide-and-conquer: A technique for designing parallel algorithms</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US5832182A/en">
                <span itemprop="publicationNumber">US5832182A</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="1998-11-03">1998-11-03</time>
            
            
          </td>
          <td itemprop="title">Method and system for data clustering for very large databases 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="13550043991549961680">
              <a href="/scholar/13550043991549961680"><span itemprop="scholarAuthors">Li</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1994">1994</time>
            
          </td>
          <td itemprop="title">Markov random field models in computer vision</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="13608334447867482516">
              <a href="/scholar/13608334447867482516"><span itemprop="scholarAuthors">Owens et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="2002">2002</time>
            
          </td>
          <td itemprop="title">Media processing applications on the Imagine stream processor</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="2605265563930760679">
              <a href="/scholar/2605265563930760679"><span itemprop="scholarAuthors">Du et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1999">1999</time>
            
          </td>
          <td itemprop="title">Centroidal Voronoi tessellations: Applications and algorithms</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="12281070452827033267">
              <a href="/scholar/12281070452827033267"><span itemprop="scholarAuthors">Nagao et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1979">1979</time>
            
          </td>
          <td itemprop="title">Region extraction and shape analysis in aerial photographs</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="16967943047182880760">
              <a href="/scholar/16967943047182880760"><span itemprop="scholarAuthors">Kolmogorov et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="2002">2002</time>
            
          </td>
          <td itemprop="title">What energy functions can be minimized via graph cuts?</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US20060125838A1/en">
                <span itemprop="publicationNumber">US20060125838A1</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="2006-06-15">2006-06-15</time>
            
            
          </td>
          <td itemprop="title">System for reducing the number of programs necessary to render an image 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="14579000822913180531">
              <a href="/scholar/14579000822913180531"><span itemprop="scholarAuthors">Baumann</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1994">1994</time>
            
          </td>
          <td itemprop="title">Management of multidimensional discrete data</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="12534448656874855751">
              <a href="/scholar/12534448656874855751"><span itemprop="scholarAuthors">Jolion et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="2012">2012</time>
            
          </td>
          <td itemprop="title">A pyramid framework for early vision: multiresolutional computer vision</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US20030108237A1/en">
                <span itemprop="publicationNumber">US20030108237A1</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="2003-06-12">2003-06-12</time>
            
            
          </td>
          <td itemprop="title">Method of image segmentation for object-based image retrieval 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="6217082802021313982">
              <a href="/scholar/6217082802021313982"><span itemprop="scholarAuthors">Le Moigne et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1995">1995</time>
            
          </td>
          <td itemprop="title">Refining image segmentation by integration of edge and region data</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/CA1235514A/en">
                <span itemprop="publicationNumber">CA1235514A</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="1988-04-19">1988-04-19</time>
            
            
          </td>
          <td itemprop="title">Video recognition system 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="14891000834322893736">
              <a href="/scholar/14891000834322893736"><span itemprop="scholarAuthors">Roerdink et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="2000">2000</time>
            
          </td>
          <td itemprop="title">The watershed transform: Definitions, algorithms and parallelization strategies</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US4809347A/en">
                <span itemprop="publicationNumber">US4809347A</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="1989-02-28">1989-02-28</time>
            
            
          </td>
          <td itemprop="title">Computer vision architecture 
       </td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="14739376079313873260">
              <a href="/scholar/14739376079313873260"><span itemprop="scholarAuthors">Saber et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1997">1997</time>
            
          </td>
          <td itemprop="title">Fusion of color and edge information for improved segmentation and edge linking</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="10108289699435979465">
              <a href="/scholar/10108289699435979465"><span itemprop="scholarAuthors">Clausi et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1998">1998</time>
            
          </td>
          <td itemprop="title">A fast method to determine co-occurrence texture features</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            
            <meta itemprop="isScholar" content="true">
              <meta itemprop="scholarID" content="899641009598970449">
              <a href="/scholar/899641009598970449"><span itemprop="scholarAuthors">Dai et al.</span></a>
            
          </td>
          <td>
            
            <time itemprop="publicationDate" datetime="1999">1999</time>
            
          </td>
          <td itemprop="title">Remotely sensed change detection based on artificial neural networks</td>
        </tr><tr itemprop="similarDocuments" itemscope repeat>
          <td>
            <meta itemprop="isPatent" content="true">
              
              
              <a href="/patent/US5974521A/en">
                <span itemprop="publicationNumber">US5974521A</span>
                (<span itemprop="primaryLanguage">en</span>)
              </a>
            
            
          </td>
          <td>
            <time itemprop="publicationDate" datetime="1999-10-26">1999-10-26</time>
            
            
          </td>
          <td itemprop="title">Apparatus and method for signal processing 
       </td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Legal Events</h2>
    <table>
      <thead>
        <tr>
          <th>Date</th>
          <th>Code</th>
          <th>Title</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2001-04-23">2001-04-23</time></td>
          <td itemprop="code">AS</td>
          <td itemprop="title">Assignment</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Owner name</strong>:
              <span itemprop="value">NATIONAL AERONAUTICS AND SPACE ADMINISTRATION, UNI</span>
            </p>
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Free format text</strong>:
              <span itemprop="value">ASSIGNMENT OF ASSIGNORS INTEREST;ASSIGNOR:TILTON, JAMES C.;REEL/FRAME:011752/0963</span>
            </p>
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Effective date</strong>:
              <span itemprop="value">20010423</span>
            </p>
          </td>
        </tr>
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2005-04-27">2005-04-27</time></td>
          <td itemprop="code">STCF</td>
          <td itemprop="title">Information on status: patent grant</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Free format text</strong>:
              <span itemprop="value">PATENTED CASE</span>
            </p>
          </td>
        </tr>
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2008-07-15">2008-07-15</time></td>
          <td itemprop="code">FPAY</td>
          <td itemprop="title">Fee payment</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Year of fee payment</strong>:
              <span itemprop="value">4</span>
            </p>
          </td>
        </tr>
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2012-07-31">2012-07-31</time></td>
          <td itemprop="code">FPAY</td>
          <td itemprop="title">Fee payment</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Year of fee payment</strong>:
              <span itemprop="value">8</span>
            </p>
          </td>
        </tr>
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2016-11-23">2016-11-23</time></td>
          <td itemprop="code">FPAY</td>
          <td itemprop="title">Fee payment</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Year of fee payment</strong>:
              <span itemprop="value">12</span>
            </p>
          </td>
        </tr>
        <tr itemprop="legalEvents" itemscope repeat>
          <td><time itemprop="date" datetime="2016-11-23">2016-11-23</time></td>
          <td itemprop="code">SULP</td>
          <td itemprop="title">Surcharge for late payment</td>
          <td>
            
            <p itemprop="attributes" itemscope repeat>
              <strong itemprop="label">Year of fee payment</strong>:
              <span itemprop="value">11</span>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </section>
</article>

    </search-app>
    <script type="text/javascript" src="//www.gstatic.com/feedback/api.js"></script>
    <script async="" defer="" src="//www.google.com/insights/consumersurveys/async_survey?site=cxkjf7ipxgbnnjy6k35ezcvbbe"></script>
  </body>
</html>
